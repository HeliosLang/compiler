declare module "helios" {
    /**
     * Needed by transfer() methods
     * @typedef {{
     *   transferByteArrayData: (bytes: number[]) => any,
     *   transferConstrData: (index: number, fields: any[]) => any,
     *   transferIntData: (value: bigint) => any,
     *   transferListData: (items: any[]) => any,
     *   transferMapData: (pairs: [any, any][]) => any,
     *   transferSite: (src: any, startPos: number, endPos: number, codeMapSite: null | any) => any,
     *   transferSource: (raw: string, name: string) => any,
     *   transferUplcBool: (site: any, value: boolean) => any,
     *   transferUplcBuiltin: (site: any, name: string | number) => any,
     *   transferUplcByteArray: (site: any, bytes: number[]) => any,
     *   transferUplcCall: (site: any, a: any, b: any) => any,
     *   transferUplcConst: (value: any) => any,
     *   transferUplcDataValue: (site: any, data: any) => any,
     *   transferUplcDelay: (site: any, expr: any) => any,
     *   transferUplcError: (site: any, msg: string) => any,
     *   transferUplcForce: (site: any, expr: any) => any,
     *   transferUplcInt: (site: any, value: bigint, signed: boolean) => any,
     *   transferUplcLambda: (site: any, rhs: any, name: null | string) => any,
     *   transferUplcList: (site: any, itemType: any, items: any[]) => any,
     *   transferUplcPair: (site: any, first: any, second: any) => any,
     *   transferUplcString: (site: any, value: string) => any,
     *   transferUplcType: (typeBits: string) => any,
     *   transferUplcUnit: (site: any) => any,
     *   transferUplcVariable: (site: any, index: any) => any
     * }} TransferUplcAst
     */
    /**
     * Throws an error if 'cond' is false.
     * @internal
     * @param {boolean} cond
     * @param {string} msg
     */
    export function assert(cond: boolean, msg?: string): void;
    /**
     * Throws an error if 'obj' is undefined. Returns 'obj' itself (for chained application).
     * @internal
     * @template T
     * @param {T | undefined | null} obj
     * @param {string} msg
     * @returns {T}
     */
    export function assertDefined<T>(obj: T | null | undefined, msg?: string): T;
    /**
     * @internal
     * @template Tin, Tout
     * @param {Tin} obj
     * @param {{new(...any): Tout}} C
     * @returns {Tout}
     */
    export function assertClass<Tin, Tout>(obj: Tin, C: new (...any: any[]) => Tout, msg?: string): Tout;
    /**
     * @internal
     * @param {string} str
     * @param {string} msg
     * @returns {string}
     */
    export function assertNonEmpty(str: string, msg?: string): string;
    /**
     * @internal
     * @param {any} obj
     * @param {string} msg
     * @returns {number}
     */
    export function assertNumber(obj: any, msg?: string): number;
    /**
     * @internal
     * @template T
     * @param {(T | null)[]} lst
     * @returns {null | (T[])}
     */
    export function reduceNull<T>(lst: (T | null)[]): T[] | null;
    /**
     * @internal
     * @template Ta
     * @template Tb
     * @param {[Ta | null, Tb | null][]} pairs
     * @returns {null | [Ta, Tb][]}
     */
    export function reduceNullPairs<Ta, Tb>(pairs: [Ta | null, Tb | null][]): [Ta, Tb][] | null;
    /**
     * Compares two objects (deep recursive comparison)
     * @internal
     * @template T
     * @param {T} a
     * @param {T} b
     * @returns {boolean}
     */
    export function eq<T>(a: T, b: T): boolean;
    /**
     * Throws an error if two object aren't equal (deep comparison).
     * Used by unit tests that are autogenerated from JSDoc inline examples.
     * @internal
     * @template T
     * @param {T} a
     * @param {T} b
     * @param {string} msg
     */
    export function assertEq<T>(a: T, b: T, msg: string): void;
    /**
     * Divides two integers. Assumes a and b are whole numbers. Rounds down the result.
     * @example
     * idiv(355, 113) == 3
     * @internal
     * @param {number} a
     * @param {number} b
     */
    export function idiv(a: number, b: number): number;
    /**
     * 2 to the power 'p' for bigint.
     * @internal
     * @param {bigint} p
     * @returns {bigint}
     */
    export function ipow2(p: bigint): bigint;
    /**
     * Masks bits of 'b' by setting bits outside the range ['i0', 'i1') to 0.
     * 'b' is an 8 bit integer (i.e. number between 0 and 255).
     * The return value is also an 8 bit integer, shift right by 'i1'.
     
     * @example
     * imask(0b11111111, 1, 4) == 0b0111 // (i.e. 7)
     * @internal
     * @param {number} b
     * @param {number} i0
     * @param {number} i1
     * @returns {number}
     */
    export function imask(b: number, i0: number, i1: number): number;
    /**
     * Make sure resulting number fits in uint8
     * @internal
     * @param {number} x
     */
    export function imod8(x: number): number;
    /**
     * Converts an unbounded integer into a list of uint8 numbers (big endian)
     * Used by the CBOR encoding of data structures, and by Ed25519
     * @internal
     * @param {bigint} x
     * @returns {number[]}
     */
    export function bigIntToBytes(x: bigint): number[];
    /**
     * Converts a list of uint8 numbers into an unbounded int (big endian)
     * Used by the CBOR decoding of data structures.
     * @internal
     * @param {number[]} b
     * @return {bigint}
     */
    export function bytesToBigInt(b: number[]): bigint;
    /**
     * Little Endian 32 bytes
     * @internal
     * @param {number[]} b
     * @returns {bigint}
     */
    export function leBytesToBigInt(b: number[]): bigint;
    /**
     * Little Endian 32 bytes
     * @internal
     * @param {bigint} x
     * @returns {number[]}
     */
    export function bigIntToLe32Bytes(x: bigint): number[];
    /**
     * Prepends zeroes to a bit-string so that 'result.length == n'.
     * @example
     * padZeroes("1111", 8) == "00001111"
     * @internal
     * @param {string} bits
     * @param {number} n
     * @returns {string}
     */
    export function padZeroes(bits: string, n: number): string;
    /**
     * Converts a 8 bit integer number into a bit string with an optional "0b" prefix.
     * The result is padded with leading zeroes to become 'n' chars long ('2 + n' chars long if you count the "0b" prefix).
     * @example
     * byteToBitString(7) == "0b00000111"
     * @internal
     * @param {number} b
     * @param {number} n
     * @param {boolean} prefix
     * @returns {string}
     */
    export function byteToBitString(b: number, n?: number, prefix?: boolean): string;
    /**
     * Converts a hexadecimal string into a list of bytes.
     * @example
     * hexToBytes("00ff34") == [0, 255, 52]
     * @param {string} hex
     * @returns {number[]}
     */
    export function hexToBytes(hex: string): number[];
    /**
     * Converts a list of uint8 bytes into its hexadecimal string representation.
     * @example
     * bytesToHex([0, 255, 52]) == "00ff34"
     * @param {number[]} bytes
     * @returns {string}
     */
    export function bytesToHex(bytes: number[]): string;
    /**
     * Encodes a string into a list of uint8 bytes using UTF-8 encoding.
     * @example
     * textToBytes("hello world") == [104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]
     * @param {string} str
     * @returns {number[]}
     */
    export function textToBytes(str: string): number[];
    /**
     * Decodes a list of uint8 bytes into a string using UTF-8 encoding.
     * @example
     * bytesToText([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]) == "hello world"
     * @param {number[]} bytes
     * @returns {string}
     */
    export function bytesToText(bytes: number[]): string;
    /**
     * Replaces the tab characters of a string with spaces.
     * This is used to create a prettier IR (which is built-up from many template js strings in this file, which might contain tabs depending on the editor used)
     * @example
     * replaceTabs("\t\t\t") == [TAB, TAB, TAB].join("")
     * @internal
     * @param {string} str
     * @returns {string}
     */
    export function replaceTabs(str: string): string;
    /**
     * Template string tag function that doesn't do anything and just returns the template string as a string.
     * Can be used as a marker of Helios sources so that syntax highlighting can work inside JS/TS files.
     * @example
     * hl`hello ${"world"}!` == "hello world!"
     * @param {string[]} a
     * @param  {...any} b
     * @returns {string}
     */
    export function hl(a: string[], ...b: any[]): string;
    /**
     * Display a warning message that a certain feature will be deprecated at some point in the future.
     * @internal
     * @param {string} feature
     * @param {string} futureVersion
     * @param {string} alternative
     * @param {string} docUrl
     */
    export function deprecationWarning(feature: string, futureVersion: string, alternative: string, docUrl?: string): void;
    /**
     * @internal
     * @param {undefined | null | Token} t
     * @param {Site} site
     * @param {string} msg
     * @returns {null | Token}
     */
    export function assertToken(t: undefined | null | Token, site: Site, msg?: string): null | Token;
    /**
     * Changes the value of BLAKE2B_DIGEST_SIZE
     *  (because the nodejs crypto module only supports
     *   blake2b-512 and not blake2b-256, and we want to avoid non-standard dependencies in the
     *   test-suite)
     * @internal
     * @param {number} s - 32 or 64
     */
    export function setBlake2bDigestSize(s: number): void;
    /**
     * @internal
     * @param {NumberGenerator} random
     * @param {number} n
     * @returns {number[]}
     */
    export function randomBytes(random: NumberGenerator, n: number): number[];
    /**
     * Dynamically constructs a new List class, depending on the item type.
     * @internal
     * @template {HeliosData} T
     * @param {HeliosDataClass<T>} ItemClass
     * @returns {HeliosDataClass<HList_>}
     */
    export function HList<T extends HeliosData>(ItemClass: HeliosDataClass<T>): HeliosDataClass<{
        /**
         * @type {T[]}
         */
        "__#1@#items": T[];
        /**
         * @internal
         * @type {string}
         */
        readonly _listTypeName: string;
        /**
         * @type {T[]}
         */
        readonly items: T[];
        /**
         * @internal
         * @returns {UplcData}
         */
        _toUplcData(): UplcData;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
        /**
         * Defaults to cbor encoding of uplc data structure.
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @returns {string}
         */
        toCborHex(): string;
    }>;
    /**
     * @internal
     * @template {HeliosData} TKey
     * @template {HeliosData} TValue
     * @param {HeliosDataClass<TKey>} KeyClass
     * @param {HeliosDataClass<TValue>} ValueClass
     * @returns {HeliosDataClass<HMap_>}
     */
    export function HMap<TKey extends HeliosData, TValue extends HeliosData>(KeyClass: HeliosDataClass<TKey>, ValueClass: HeliosDataClass<TValue>): HeliosDataClass<{
        /**
         * @type {[TKey, TValue][]}
         */
        "__#2@#pairs": [TKey, TValue][];
        /**
         * @internal
         * @type {string}
         */
        readonly _mapTypeName: string;
        /**
         * @type {[TKey, TValue][]}
         */
        readonly pairs: [TKey, TValue][];
        /**
         * @internal
         * @returns {UplcData}
         */
        _toUplcData(): UplcData;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
        /**
         * Defaults to cbor encoding of uplc data structure.
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @returns {string}
         */
        toCborHex(): string;
    }>;
    /**
     * @internal
     * @template {HeliosData} T
     * @param {HeliosDataClass<T>} SomeClass
     * @returns {HeliosDataClass<Option_>}
     */
    export function Option<T extends HeliosData>(SomeClass: HeliosDataClass<T>): HeliosDataClass<{
        /**
         * @type {?T}
         */
        "__#3@#value": T | null;
        /**
         * @internal
         * @type {string}
         */
        readonly _optionTypeName: string;
        /**
         * @type {?T}
         */
        readonly some: T | null;
        /**
         * @internal
         * @returns {UplcData}
         */
        _toUplcData(): UplcData;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
        /**
         * Defaults to cbor encoding of uplc data structure.
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @returns {string}
         */
        toCborHex(): string;
    }>;
    /**
     * Use this function to check cost-model parameters
     * @internal
     * @param {NetworkParams} networkParams
     */
    export function dumpCostModels(networkParams: NetworkParams): void;
    /**
     * Returns index of a named builtin
     * Throws an error if builtin doesn't exist
     * @internal
     * @param {string} name
     * @returns
     */
    export function findUplcBuiltin(name: string): number;
    /**
     * Checks if a named builtin exists
     * @internal
     * @param {string} name
     * @param {boolean} strict - if true then throws an error if builtin doesn't exist
     * @returns {boolean}
     */
    export function isUplcBuiltin(name: string, strict?: boolean): boolean;
    /**
     * @internal
     * @typedef {UplcConst | AppliedUplcBuiltin | UplcLambdaWithEnv | UplcDelayWithEnv} CekValue
     */
    /**
     * @internal
     * @typedef {{
     * 	 values: CekValue[],
     *   callSites: Site[]
     * }} CekEnv
     */
    /**
     * @internal
     * @typedef {{computing: UplcTerm, env: CekEnv}} ComputingState
     */
    /**
     * @internal
     * @typedef {{reducing: CekValue}} ReducingState
     */
    /**
     * @internal
     * @typedef {{error: string | RuntimeError, env: CekEnv}} ErrorState
     */
    /**
     * @internal
     * @typedef {ComputingState | ReducingState | ErrorState} CekState
     */
    /**
     * @internal
     * @param {UplcRte} rte
     * @param {UplcTerm} start
     * @param {null | UplcValue[]} args
     * @returns {Promise<UplcValue>}
     */
    export function evalCek(rte: UplcRte, start: UplcTerm, args?: null | UplcValue[]): Promise<UplcValue>;
    /**
     * Deserializes a flat encoded `UplcProgram`.
     * @param {number[]} bytes
     * @param {ProgramProperties} properties
     * @returns {UplcProgram}
     */
    export function deserializeUplcBytes(bytes: number[], properties?: ProgramProperties): UplcProgram;
    /**
     * Parses a plutus core program. Returns a `UplcProgram` instance.
     * @param {string | {cborHex: string}} json a raw JSON string or a parsed JSON object
     * @returns {UplcProgram}
     */
    export function deserializeUplc(json: string | {
        cborHex: string;
    }): UplcProgram;
    /**
     * Tokenizes a string (wrapped in Source)
     * Also used by VSCode plugin
     * @internal
     * @param {Source} src
     * @returns {Token[] | null}
     */
    export function tokenize(src: Source): Token[] | null;
    /**
     * Tokenizes an IR string with a codemap to the original source
     * @internal
     * @param {string} rawSrc
     * @param {CodeMap} codeMap
     * @returns {Token[]}
     */
    export function tokenizeIR(rawSrc: string, codeMap?: CodeMap): Token[];
    /**
     * @template {HeliosData} T
     */
    /**
     * @internal
     * @typedef {{
     *   type:  string
     * } | {
     *   type:     "List"
     *   itemType: TypeSchema
     * } | {
     *   type:      "Map"
     *   keyType:   TypeSchema
     *   valueType: TypeSchema
     * } | {
     *   type:     "Option"
     *   someType: TypeSchema
     * } | {
     *   type:       "Struct"
     *   fieldTypes: NamedTypeSchema[]
     * } | {
     *   type:         "Enum"
     *   variantTypes: {name: string, fieldTypes: NamedTypeSchema[]}[]
     * }} TypeSchema
     */
    /**
     * @internal
     * @typedef {{
     * 	 name: string
     * } & TypeSchema} NamedTypeSchema
     */
    /**
     * @internal
     * @typedef {{
     *   name: string
     *   typeClass: TypeClass
     * }} ParameterI
     */
    /**
     * @internal
     * @typedef {Map<ParameterI, Type>} InferenceMap
     */
    /**
     * Used by the bundle cli command to generate a typescript annotations and (de)serialization code
     * inputTypes form a type union
     * @internal
     * @typedef {{
     *   inputType:    string
     *   outputType:   string
     *   internalType: TypeSchema
     * }} TypeDetails
     */
    /**
     * @internal
     * @typedef {{[name: string]: (obj: any) => Promise<UplcData>}} JsToUplcHelpers
     */
    /**
     * @internal
     * @typedef {{[name: string]: (data: UplcData) => Promise<any>}} UplcToJsHelpers
     */
    /**
     * @internal
     * @typedef {(obj: any, helpers: JsToUplcHelpers) => Promise<UplcData>} JsToUplcConverter
     */
    /**
     * @internal
     * @typedef {(data: UplcData, helpers: UplcToJsHelpers) => Promise<any>} UplcToJsConverter
     */
    /**
     * @internal
     * @typedef {Named & Type & {
     *   asDataType:   DataType
     *   fieldNames:   string[]
     *   offChainType: (null | HeliosDataClass<HeliosData>)
     *   typeDetails?: TypeDetails
     *   jsToUplc:     JsToUplcConverter
     *   uplcToJs:     UplcToJsConverter
     *   ready:        boolean
     * }} DataType
     */
    /**
     * @internal
     * @typedef {DataType & {
     *   asEnumMemberType: EnumMemberType
     *   constrIndex:      number
     *   parentType:       DataType
     * }} EnumMemberType
     */
    /**
     * EvalEntities assert themselves
     * @internal
     * @typedef {{
     *   asDataType:       (null | DataType)
     *   asEnumMemberType: (null | EnumMemberType)
     *   asFunc:           (null | Func)
     *   asInstance:       (null | Instance)
     *   asMulti:          (null | Multi)
     *   asNamed:          (null | Named)
     *   asNamespace:      (null | Namespace)
     *   asParametric:     (null | Parametric)
     * 	 asType:           (null | Type)
     *   asTyped:          (null | Typed)
     *   asTypeClass:      (null | TypeClass)
     *   toString():       string
     * }} EvalEntity
     */
    /**
     * @internal
     * @typedef {Typed & {
     *   asFunc: Func
     * 	 funcType: FuncType
     *   call(site: Site, args: Typed[], namedArgs?: {[name: string]: Typed}): (null | Typed | Multi)
     * }} Func
     */
    /**
     * @internal
     * @typedef {Typed & {
     *   asInstance:      Instance
     *   fieldNames:      string[]
     *   instanceMembers: InstanceMembers
     * }} Instance
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *	 asMulti: Multi
     *   values:  Typed[]
     * }} Multi
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asNamed: Named
     *   name:    string
     *   path:    string
     * }} Named
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asNamespace: Namespace
     *   namespaceMembers: NamespaceMembers
     * }} Namespace
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asParametric: Parametric
     *   offChainType: (null | ((...any) => HeliosDataClass<HeliosData>))
     *   typeClasses: TypeClass[]
     *   apply(types: Type[], site?: Site): EvalEntity
     *   inferCall(site: Site, args: Typed[], namedArgs?: {[name: string]: Typed}, paramTypes?: Type[]): Func
     * 	 infer(site: Site, map: InferenceMap): Parametric
     * }} Parametric
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asType:               Type
     *   instanceMembers:      InstanceMembers
     *   typeMembers:          TypeMembers
     *   isBaseOf(type: Type): boolean
     *   infer(site: Site, map: InferenceMap, type: null | Type): Type
     *   toTyped():            Typed
     *   isParametric():       boolean
     * }} Type
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asTyped: Typed
     *   type: Type
     * }} Typed
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asTypeClass:                        TypeClass
     *   genInstanceMembers(impl: Type):     TypeClassMembers
     *   genTypeMembers(impl: Type):         TypeClassMembers
     *   isImplementedBy(type: Type):        boolean
     *   toType(name: string, path: string, parameter?: null | ParameterI): Type
     * }} TypeClass
     */
    /**
     * @internal
     * @typedef {{[name: string]: (Parametric | Type)}} InstanceMembers
     */
    /**
     * @internal
     * @typedef {{[name: string]: EvalEntity}} NamespaceMembers
     */
    /**
     * @internal
     * @typedef {{[name: string]: (Parametric | Type | Typed)}} TypeMembers
     */
    /**
     * @internal
     * @typedef {{[name: string]: Type}} TypeClassMembers
     */
    /**
     * @internal
     * @param {Parametric} parametric
     * @param {Type[]} types
     * @returns {DataType}
     */
    export function applyTypes(parametric: Parametric, ...types: Type[]): DataType;
    /**
     * @internal
     * @param {Type} type
     * @returns {InstanceMembers}
     */
    export function genCommonInstanceMembers(type: Type): InstanceMembers;
    /**
     * @internal
     * @param {Type} type
     * @returns {TypeMembers}
     */
    export function genCommonTypeMembers(type: Type): TypeMembers;
    /**
     * @internal
     * @param {Type} type
     * @param {Type} parentType
     * @returns {TypeMembers}
     */
    export function genCommonEnumTypeMembers(type: Type, parentType: Type): TypeMembers;
    /**
     * @internal
     * @param {Type[]} itemTypes
     * @returns {Type}
     */
    export function IteratorType$(itemTypes: Type[]): Type;
    /**
     * @internal
     * @param {Type} itemType
     * @returns {DataType}
     */
    export function ListType$(itemType: Type): DataType;
    /**
     * @internal
     * @param {Type} keyType
     * @param {Type} valueType
     * @returns {DataType}
     */
    export function MapType$(keyType: Type, valueType: Type): DataType;
    /**
     * @internal
     * @param {Type} someType
     * @returns {DataType}
     */
    export function OptionType$(someType: Type): DataType;
    /**
     * Set the statistics collector (used by the test-suite)
     * @internal
     * @param {(name: string, count: number) => void} callback
     */
    export function setRawUsageNotifier(callback: (name: string, count: number) => void): void;
    /**
     * Load all raw generics so all possible implementations can be generated correctly during type parameter injection phase
     * @internal
     * @param {ToIRContext} ctx
     * @returns {IRDefinitions}
     */
    export function fetchRawGenerics(ctx: ToIRContext): IRDefinitions;
    /**
     * Doesn't add templates
     * @internal
     * @param {ToIRContext} ctx
     * @param {IR} ir
     * @param {null | IRDefinitions} userDefs - some userDefs might have the __helios prefix
     * @returns {IRDefinitions}
     */
    export function fetchRawFunctions(ctx: ToIRContext, ir: IR, userDefs?: null | IRDefinitions): IRDefinitions;
    /**
     * @internal
     * @param {ToIRContext} ctx
     * @param {IR} ir
     * @returns {IR}
     */
    export function wrapWithRawFunctions(ctx: ToIRContext, ir: IR): IR;
    /**
     * Used by VSCode plugin and CLI
     * The sources can't be modified directly because that messes up the codemapping
     * @internal
     * @param {(path: StringLiteral) => (string | null)} fn
     */
    export function setImportPathTranslator(fn: (path: StringLiteral) => (string | null)): void;
    /**
     * @internal
     * @param {Token[]} ts
     * @returns {Statement[]}
     */
    export function buildProgramStatements(ts: Token[]): Statement[];
    /**
     * @internal
     * @param {Token[]} ts
     * @param {null | ScriptPurpose} expectedPurpose
     * @returns {[ScriptPurpose, Word] | null} - [purpose, name] (ScriptPurpose is an integer)
     * @internal
     */
    export function buildScriptPurpose(ts: Token[], expectedPurpose?: null | ScriptPurpose): [ScriptPurpose, Word] | null;
    /**
     * Also used by VSCode plugin
     * @internal
     * @param {Token[]} ts
     * @param {null | ScriptPurpose} expectedPurpose
     * @returns {[null | ScriptPurpose, Word | null, Statement[], number]}
     */
    export function buildScript(ts: Token[], expectedPurpose?: null | ScriptPurpose): [null | ScriptPurpose, Word | null, Statement[], number];
    /**
     * Quickly extract the script purpose header of a script source, by parsing only the minimally necessary characters.
     * @param {string} rawSrc
     * @returns {null | [ScriptPurpose, string]} Returns `null` if the script header is missing or syntactically incorrect. The first string returned is the script purpose, the second value returned is the script name.
     */
    export function extractScriptPurposeAndName(rawSrc: string): null | [ScriptPurpose, string];
    /**
     * @internal
     * @param {number | string | boolean} x
     * @param {number} start
     * @returns {number}
     */
    export function hashCode(x: number | string | boolean, start?: number): number;
    /**
     * @internal
     * @param {IRExpr} root
     * @param {{
     *   nameExpr?: (expr: IRNameExpr) => void
     *   errorExpr?: (expr: IRErrorExpr) => void
     *   literalExpr?: (expr: IRLiteralExpr) => void
     *   callExpr?: (expr: IRCallExpr) => void
     *   funcExpr?: (expr: IRFuncExpr) => void
     *   exit?: () => boolean
     * }} callbacks
     * @returns
     */
    export function loopIRExprs(root: IRExpr, callbacks: {
        nameExpr?: ((expr: IRNameExpr) => void) | undefined;
        errorExpr?: ((expr: IRErrorExpr) => void) | undefined;
        literalExpr?: ((expr: IRLiteralExpr) => void) | undefined;
        callExpr?: ((expr: IRCallExpr) => void) | undefined;
        funcExpr?: ((expr: IRFuncExpr) => void) | undefined;
        exit?: (() => boolean) | undefined;
    }): void;
    /**
     * Build an Intermediate Representation expression
     * @param {Token[]} ts
     * @param {IRExprTagger | null} funcTagger // each IRFuncExpr needs a unique tag, so that hashing different IRFuncExprs with the same args and bodies leads to a different hash
     * @returns {IRExpr}
     * @internal
     */
    export function buildIRExpr(ts: Token[], funcTagger?: IRExprTagger | null): IRExpr;
    /**
     * Used to debug the result of IREvalation
     * @internal
     * @param {IREvaluator} evaluation
     * @param {IRExpr} expr
     * @returns {string}
     */
    export function annotateIR(evaluation: IREvaluator, expr: IRExpr): string;
    /**
     * Returns Uint8Array with the same length as the number of chars in the script.
     * Each resulting byte respresents a different syntax category.
     * This approach should be faster than a RegExp based a approach.
     * @param {string} src
     * @returns {Uint8Array}
     */
    export function highlight(src: string): Uint8Array;
    /**
     * @internal
     * @param {TypeSchema} schema
     * @param {any} obj
     * @param {JsToUplcHelpers} helpers
     * @returns {Promise<UplcData>}
     */
    export function jsToUplcInternal(schema: TypeSchema, obj: any, helpers: JsToUplcHelpers): Promise<UplcData>;
    /**
     * @internal
     * @param {TypeSchema} schema
     * @param {any} obj
     * @param {JsToUplcHelpers} helpers
     * @returns {Promise<UplcData>}
     */
    export function jsToUplc(schema: TypeSchema, obj: any, helpers: JsToUplcHelpers): Promise<UplcData>;
    /**
     * @internal
     * @param {TypeSchema} schema
     * @param {UplcData} data
     * @param {UplcToJsHelpers} helpers
     * @returns {Promise<any>}
     */
    export function uplcToJs(schema: TypeSchema, data: UplcData, helpers: UplcToJsHelpers): Promise<any>;
    /**
     * Current version of the Helios library.
     */
    export const VERSION: "0.15.14";
    /**
     * A tab used for indenting of the IR.
     * 2 spaces.
     * @internal
     * @type {string}
     */
    export const TAB: string;
    /**
     * A Real in Helios is a fixed point number with REAL_PRECISION precision
     * @internal
     * @type {number}
     */
    export const REAL_PRECISION: number;
    export namespace config {
        function set(props: {
            DEBUG?: boolean | undefined;
            STRICT_BABBAGE?: boolean | undefined;
            IS_TESTNET?: boolean | undefined;
            N_DUMMY_INPUTS?: number | undefined;
            AUTO_SET_VALIDITY_RANGE?: boolean | undefined;
            VALIDITY_RANGE_START_OFFSET?: number | undefined;
            VALIDITY_RANGE_END_OFFSET?: number | undefined;
            IGNORE_UNEVALUATED_CONSTANTS?: boolean | undefined;
            CHECK_CASTS?: boolean | undefined;
            MAX_ASSETS_PER_CHANGE_OUTPUT?: number | undefined;
        }): void;
        const DEBUG: boolean;
        const STRICT_BABBAGE: boolean;
        const IS_TESTNET: boolean;
        const N_DUMMY_INPUTS: number;
        const AUTO_SET_VALIDITY_RANGE: boolean;
        const VALIDITY_RANGE_START_OFFSET: number;
        const VALIDITY_RANGE_END_OFFSET: number;
        const IGNORE_UNEVALUATED_CONSTANTS: boolean;
        const CHECK_CASTS: boolean;
        const MAX_ASSETS_PER_CHANGE_OUTPUT: undefined;
    }
    /**
     * Read non-byte aligned numbers
     * @internal
     */
    export class BitReader {
        /**
         * @param {number[]} bytes
         * @param {boolean} truncate - if true then read last bits as low part of number, if false pad with zero bits
         */
        constructor(bytes: number[], truncate?: boolean);
        /**
         * @internal
         * @returns {boolean}
         */
        eof(): boolean;
        /**
         * Reads a number of bits (<= 8) and returns the result as an unsigned number
         * @internal
         * @param {number} n - number of bits to read
         * @returns {number}
         */
        readBits(n: number): number;
        /**
         * Moves position to next byte boundary
         * @internal
         * @param {boolean} force - if true then move to next byte boundary if already at byte boundary
         */
        moveToByteBoundary(force?: boolean): void;
        /**
         * Reads 8 bits
         * @internal
         * @returns {number}
         */
        readByte(): number;
        /**
         * Dumps remaining bits we #pos isn't yet at end.
         * This is intended for debugging use.
         * @internal
         */
        dumpRemainingBits(): void;
        #private;
    }
    /**
     * BitWriter turns a string of '0's and '1's into a list of bytes.
     * Finalization pads the bits using '0*1' if not yet aligned with the byte boundary.
     * @internal
     */
    export class BitWriter {
        /**
         * @internal
         * @type {number}
         */
        get length(): number;
        /**
         * Write a string of '0's and '1's to the BitWriter.
         * @internal
         * @param {string} bitChars
         */
        write(bitChars: string): void;
        /**
         * @internal
         * @param {number} byte
         */
        writeByte(byte: number): void;
        /**
         * Add padding to the BitWriter in order to align with the byte boundary.
         * If 'force == true' then 8 bits are added if the BitWriter is already aligned.
         * @internal
         * @param {boolean} force
         */
        padToByteBoundary(force?: boolean): void;
        /**
         * Pop n bits of the end
         * @param {number} n
         * @returns {string}
         */
        pop(n: number): string;
        /**
         * Pads the BitWriter to align with the byte boundary and returns the resulting bytes.
         * @internal
         * @param {boolean} force - force padding (will add one byte if already aligned)
         * @returns {number[]}
         */
        finalize(force?: boolean): number[];
        #private;
    }
    /**
     * Function that generates a random number between 0 and 1
     * @typedef {() => number} NumberGenerator
     */
    /**
     * A Source instance wraps a string so we can use it cheaply as a reference inside a Site.
     * Also used by VSCode plugin
     */
    export class Source {
        /**
         * @param {string} raw
         * @param {string} name
         */
        constructor(raw: string, name: string);
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * @internal
         * @type {string}
         */
        get raw(): string;
        /**
         * @internal
         * @type {string}
         */
        get name(): string;
        /**
         * @type {Error[]}
         */
        get errors(): Error[];
        throwErrors(): void;
        /**
         * Get char from the underlying string.
         * Should work fine utf-8 runes.
         * @internal
         * @param {number} pos
         * @returns {string}
         */
        getChar(pos: number): string;
        /**
         * Returns word under pos
         * @internal
         * @param {number} pos
         * @returns {?string}
         */
        getWord(pos: number): string | null;
        /**
         * @internal
         * @type {number}
         */
        get length(): number;
        /**
         * Calculates the line number of the line where the given character is located (0-based).
         * @internal
         * @param {number} pos
         * @returns {number}
         */
        posToLine(pos: number): number;
        /**
         * Calculates the column and line number where the given character is located (0-based).
         * @internal
         * @param {number} pos
         * @returns {[number, number]}
         */
        posToLineAndCol(pos: number): [number, number];
        /**
         * Creates a more human-readable version of the source by prepending the line-numbers to each line.
         * The line-numbers are at least two digits.
         * @example
         * (new Source("hello\nworld")).pretty() == "01  hello\n02  world"
         * @internal
         * @returns {string}
         */
        pretty(): string;
        #private;
    }
    /**
     * Each Token/Expression/Statement has a Site, which encapsulates a position in a Source
     */
    export class Site {
        static dummy(): Site;
        /**
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {Site | null} codeMapSite
         */
        constructor(src: Source, startPos: number, endPos?: number, codeMapSite?: Site | null);
        /**
         *
         * @param {TransferUplcAst} other
         */
        transfer(other: TransferUplcAst): any;
        get src(): Source;
        get startPos(): number;
        get endPos(): number;
        get endSite(): Site | null;
        /**
         * @param {Site} other
         * @returns {Site}
         */
        merge(other: Site): Site;
        /**
         * @param {?Site} site
         */
        setEndSite(site: Site | null): void;
        /**
         * @type {?Site}
         */
        get codeMapSite(): Site | null;
        /**
         * @param {Site} site
         */
        setCodeMapSite(site: Site): void;
        /**
         * Returns a SyntaxError
         * @param {string} info
         * @returns {UserError}
         */
        syntaxError(info?: string): UserError;
        /**
         * Returns a TypeError
         * @param {string} info
         * @returns {UserError}
         */
        typeError(info?: string): UserError;
        /**
         * Returns a ReferenceError
         * @param {string} info
         * @returns {UserError}
         */
        referenceError(info?: string): UserError;
        /**
         * Calculates the column,line position in 'this.#src'
         * @returns {[number, number, number, number]} - [startLine, startCol, endLine, endCol]
         */
        getFilePos(): [number, number, number, number];
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * UserErrors are generated when the user of Helios makes a mistake (eg. a syntax error).
     */
    export class UserError extends Error {
        /**
         * @internal
         * @param {string} type
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {string} info
         */
        static new(type: string, src: Source, startPos: number, endPos: number, info?: string): UserError;
        /**
         * Constructs a SyntaxError
         * @internal
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {string} info
         * @returns {UserError}
         */
        static syntaxError(src: Source, startPos: number, endPos: number, info?: string): UserError;
        /**
         * Constructs a TypeError
         * @internal
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {string} info
         * @returns {UserError}
         */
        static typeError(src: Source, startPos: number, endPos: number, info?: string): UserError;
        /**
         * @param {Error} e
         * @returns {boolean}
         */
        static isTypeError(e: Error): boolean;
        /**
         * Constructs a ReferenceError (i.e. name undefined, or name unused)
         * @internal
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {string} info
         * @returns {UserError}
         */
        static referenceError(src: Source, startPos: number, endPos: number, info?: string): UserError;
        /**
         * @param {Error} e
         * @returns {boolean}
         */
        static isReferenceError(e: Error): boolean;
        /**
         * Catches any UserErrors thrown inside 'fn()`.
         * Dumps the error
         * @template T
         * @param {() => T} fn
         * @param {boolean} verbose
         * @returns {T | undefined}
         */
        static catch<T>(fn: () => T, verbose?: boolean): T | undefined;
        /**
         * @internal
         * @param {string} msg
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         */
        constructor(msg: string, src: Source, startPos: number, endPos?: number);
        /**
         * @internal
         * @type {Source}
         */
        get src(): Source;
        /**
         * Filled with CBOR hex representations of Datum, Redeemer and ScriptContext by validation scripts throwing errors during `tx.finalize()`; and Redeemer and ScriptContext by minting scripts throwing errors.
         * @type {Object}
         */
        get context(): any;
        /**
         * @internal
         */
        get data(): void;
        /**
         * @internal
         * @type {number}
         */
        get startPos(): number;
        /**
         * Calculates column/line position in 'this.src'.
         * @internal
         * @returns {[number, number, number, number]} - [startLine, startCol, endLine, endCol]
         */
        getFilePos(): [number, number, number, number];
        /**
         * Dumps the error without throwing.
         * If 'verbose == true' the Source is also pretty printed with line-numbers.
         * @internal
         * @param {boolean} verbose
         */
        dump(verbose?: boolean): void;
        #private;
    }
    /**
     * Used for errors thrown during Uplc evaluation
     */
    export class RuntimeError extends Error {
        /**
         * @internal
         * @param {string} msg
         */
        constructor(msg: string);
        get context(): any;
        #private;
    }
    /**
     * Token is the base class of all Expressions and Statements
     * @internal
     */
    export class Token {
        /**
         * @param {Site} site
         */
        constructor(site: Site);
        get site(): Site;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * Returns 'true' if 'this' is a literal primitive, a literal struct constructor, or a literal function expression.
         * @returns {boolean}
         */
        isLiteral(): boolean;
        /**
         * Returns 'true' if 'this' is a Word token.
         * @param {?(string | string[])} value
         * @returns {boolean}
         */
        isWord(value?: (string | string[]) | null): boolean;
        /**
         * @returns {boolean}
         */
        isKeyword(): boolean;
        /**
         * Returns 'true' if 'this' is a Symbol token (eg. '+', '(' etc.)
         * @param {?(string | string[])} value
         * @returns {boolean}
         */
        isSymbol(value?: (string | string[]) | null): boolean;
        /**
         * Returns 'true' if 'this' is a group (eg. '(...)').
         * @param {?string} value
         * @param {number | null} nFields
         * @returns {boolean}
         */
        isGroup(value: string | null, nFields?: number | null): boolean;
        /**
         * Returns a SyntaxError at the current Site.
         * @param {string} msg
         * @returns {UserError}
         */
        syntaxError(msg: string): UserError;
        /**
         * Returns a TypeError at the current Site.
         * @param {string} msg
         * @returns {UserError}
         */
        typeError(msg: string): UserError;
        /**
         * Returns a ReferenceError at the current Site.
         * @param {string} msg
         * @returns {UserError}
         */
        referenceError(msg: string): UserError;
        /**
         * Throws a SyntaxError if 'this' isn't a Word.
         * @param {?(string | string[])} value
         * @returns {Word | null}
         */
        assertWord(value?: (string | string[]) | null): Word | null;
        /**
         * Throws a SyntaxError if 'this' isn't a Symbol.
         * @param {?(string | string[])} value
         * @returns {SymbolToken | null}
         */
        assertSymbol(value?: (string | string[]) | null): SymbolToken | null;
        /**
         * Throws a SyntaxError if 'this' isn't a Group.
         * @param {?string} type
         * @param {?number} nFields
         * @returns {Group | null}
         */
        assertGroup(type?: string | null, nFields?: number | null): Group | null;
        #private;
    }
    /**
     * A Word token represents a token that matches /[A-Za-z_][A-Za-z_0-9]/
     * @internal
     */
    export class Word extends Token {
        /**
         * @param {string} value
         * @returns {Word}
         */
        static new(value: string): Word;
        /**
         * Finds the index of the first Word(value) in a list of tokens
         * Returns -1 if none found
         * @param {Token[]} ts
         * @param {string | string[]} value
         * @returns {number}
         */
        static find(ts: Token[], value: string | string[]): number;
        /**
         * @param {Site} site
         * @param {string} value
         */
        constructor(site: Site, value: string);
        get value(): string;
        /**
         * @param {?(string | string[])} value
         * @returns {Word}
         */
        assertWord(value?: (string | string[]) | null): Word;
        /**
         * @returns {Word}
         */
        assertNotInternal(): Word;
        /**
         * @returns {Word | null}
         */
        assertNotKeyword(): Word | null;
        #private;
    }
    /**
     * Symbol token represent anything non alphanumeric
     * @internal
     */
    export class SymbolToken extends Token {
        /**
         * Finds the index of the first Symbol(value) in a list of tokens.
         * Returns -1 if none found.
         * @param {Token[]} ts
         * @param {string | string[]} value
         * @returns {number}
         */
        static find(ts: Token[], value: string | string[]): number;
        /**
         * Finds the index of the last Symbol(value) in a list of tokens.
         * Returns -1 if none found.
         * @param {Token[]} ts
         * @param {string | string[]} value
         * @returns {number}
         */
        static findLast(ts: Token[], value: string | string[]): number;
        /**
         * @param {Site} site
         * @param {string} value
         */
        constructor(site: Site, value: string);
        get value(): string;
        /**
         * @param {?(string | string[])} value
         * @returns {SymbolToken}
         */
        assertSymbol(value: (string | string[]) | null): SymbolToken;
        #private;
    }
    /**
     * Group token can '(...)', '[...]' or '{...}' and can contain comma separated fields.
     * @internal
     */
    export class Group extends Token {
        /**
         * @param {Token} t
         * @returns {boolean}
         */
        static isOpenSymbol(t: Token): boolean;
        /**
         * @param {Token} t
         * @returns {boolean}
         */
        static isCloseSymbol(t: Token): boolean;
        /**
         * Returns the corresponding closing bracket, parenthesis or brace.
         * Throws an error if not a group symbol.
         * @example
         * Group.matchSymbol("(") == ")"
         * @param {string | SymbolToken} t
         * @returns {string}
         */
        static matchSymbol(t: string | SymbolToken): string;
        /**
         * Finds the index of first Group(type) in list of tokens
         * Returns -1 if none found.
         * @param {Token[]} ts
         * @param {string} type
         * @returns {number}
         */
        static find(ts: Token[], type: string): number;
        /**
         * @param {Site} site
         * @param {string} type - "(", "[" or "{"
         * @param {Token[][]} fields
         * @param {?SymbolToken} firstComma
         */
        constructor(site: Site, type: string, fields: Token[][], firstComma?: SymbolToken | null);
        get fields(): Token[][];
        /**
         * @param {?string} type
         * @param {number | null} nFields
         * @returns {boolean}
         */
        isGroup(type?: string | null, nFields?: number | null): boolean;
        #private;
    }
    /**
     * Base class of literal tokens
     * @internal
     */
    export class PrimitiveLiteral extends Token {
    }
    /**
     * Signed int literal token
     * @internal
     */
    export class IntLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {bigint} value
         */
        constructor(site: Site, value: bigint);
        get value(): bigint;
        #private;
    }
    /**
     * Fixed point number literal token
     * @internal
     */
    export class RealLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {bigint} value
         */
        constructor(site: Site, value: bigint);
        get value(): bigint;
        #private;
    }
    /**
     * Bool literal token
     * @internal
     */
    export class BoolLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {boolean} value
         */
        constructor(site: Site, value: boolean);
        get value(): boolean;
        #private;
    }
    /**
     * ByteArray literal token
     * @internal
     */
    export class ByteArrayLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {number[]} bytes
         */
        constructor(site: Site, bytes: number[]);
        get bytes(): number[];
        #private;
    }
    /**
     * String literal token (utf8)
     * @internal
     */
    export class StringLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {string} value
         */
        constructor(site: Site, value: string);
        get value(): string;
        #private;
    }
    /**
     * @internal
     * @typedef {[number, Site][]} CodeMap
     */
    /**
     * @internal
     * @typedef {Map<string, IR>} IRDefinitions
     */
    /**
     * The IR class combines a string of intermediate representation sourcecode with an optional site.
     * The site is used for mapping IR code to the original source code.
     * @internal
     */
    export class IR {
        /**
         * Can be used as a template literal tag function
         * @param {string | TemplateStringsArray | IR[]} content
         * @param  {...(Site | string | IR | IR[] | null | number)} args
         * @returns {IR}
         */
        static new(content: string | TemplateStringsArray | IR[], ...args: (Site | string | IR | IR[] | null | number)[]): IR;
        /**
         * Wraps 'inner' IR source with some definitions (used for top-level statements and for builtins)
         * @internal
         * @param {IR} inner
         * @param {IRDefinitions} definitions - name -> definition
         * @returns {IR}
         */
        static wrapWithDefinitions(inner: IR, definitions: IRDefinitions): IR;
        /**
         * @param {string | IR[]} content
         * @param {null | Site} site
         */
        constructor(content: string | IR[], site?: null | Site);
        /**
         * @internal
         * @type {string | IR[]}
         */
        get content(): string | IR[];
        /**
         * @internal
         * @type {?Site}
         */
        get site(): Site | null;
        /**
         * @returns {any}
         */
        dump(): any;
        /**
         * Returns a list containing IR instances that themselves only contain strings
         * @internal
         * @returns {IR[]}
         */
        flatten(): IR[];
        /**
         * Intersperse nested IR content with a separator
         * @internal
         * @param {string} sep
         * @returns {IR}
         */
        join(sep: string): IR;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @internal
         * @returns {[string, CodeMap]}
         */
        generateSource(): [string, CodeMap];
        /**
         * @returns {string}
         */
        pretty(): string;
        /**
         * @param {string} str
         * @returns {boolean}
         */
        includes(str: string): boolean;
        /**
         * @param {RegExp} re
         * @param {string} newStr
         * @returns {IR}
         */
        replace(re: RegExp, newStr: string): IR;
        /**
         *
         * @param {RegExp} re
         * @param {(match: string) => void} callback
         */
        search(re: RegExp, callback: (match: string) => void): void;
        #private;
    }
    /**
     * @internal
     */
    export const RE_IR_PARAMETRIC_NAME: RegExp;
    /**
     * Type type parameter prefix
     * @internal
     */
    export const TTPP: "__T";
    /**
     * Func type parameter prefix
     * @internal
     */
    export const FTPP: "__F";
    /**
     * @internal
     */
    export class IRParametricName {
        /**
         * @param {string} base
         * @param {number} nTtps
         * @param {string} fn
         * @param {number} nFtps
         * @returns
         */
        static newTemplate(base: string, nTtps: number, fn?: string, nFtps?: number): IRParametricName;
        /**
         * @example
         * IRParametricName.matches("__helios__map[__T0@__T1]__fold[__F2@__F3]") == true
         * @example
         * IRParametricName.matches("__helios__int") == false
         * @example
         * IRParametricName.matches("__helios__option[__T0]__none__new") == true
         * @param {string} str
         * @returns {boolean}
         */
        static matches(str: string): boolean;
        /**
         * @param {string} name
         * @returns {boolean}
         */
        static isTemplate(name: string): boolean;
        /**
         * @example
         * IRParametricName.parse("__helios__map[__T0@__T1]__fold[__F0@__F1]").toString() == "__helios__map[__T0@__T1]__fold[__F0@__F1]"
         * @example
         * IRParametricName.parse("__helios__map[__helios__bytearray@__helios__map[__helios__bytearray@__helios__int]]__fold[__F0@__F1]").toString() == "__helios__map[__helios__bytearray@__helios__map[__helios__bytearray@__helios__int]]__fold[__F0@__F1]"
         * @example
         * IRParametricName.parse("__helios__map[__helios__bytearray@__helios__map[__helios__bytearray@__helios__list[__T0]]]__fold[__F0@__F1]").toString() == "__helios__map[__helios__bytearray@__helios__map[__helios__bytearray@__helios__list[__T0]]]__fold[__F0@__F1]"
         * @param {string} str
         * @param {boolean} preferType
         * @returns {IRParametricName}
         */
        static parse(str: string, preferType?: boolean): IRParametricName;
        /**
         * @param {string} base
         * @param {string[]} ttp
         * @param {string} fn
         * @param {string[]} ftp
         */
        constructor(base: string, ttp: string[], fn?: string, ftp?: string[]);
        /**
         * @type {string}
         */
        get base(): string;
        /**
         * @param {string[]} ttp
         * @param {string[]} ftp
         * @returns {IRParametricName}
         */
        toImplementation(ttp: string[], ftp?: string[]): IRParametricName;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @return {string}
         */
        toTemplate(): string;
        /**
         * @param {IR} ir
         * @returns {IR}
         */
        replaceTemplateNames(ir: IR): IR;
        #private;
    }
    export namespace Crypto {
        function mulberry32(seed: number): NumberGenerator;
        function rand(seed: number): NumberGenerator;
        function encodeBase32(bytes: number[], alphabet?: string): string;
        function decodeBase32(encoded: string, alphabet?: string): number[];
        function encodeBech32(hrp: string, data: number[]): string;
        function decodeBech32(addr: string): [string, number[]];
        function verifyBech32(encoded: string): boolean;
        function sha2_256(bytes: number[]): number[];
        function sha2_512(bytes: number[]): number[];
        function sha3(bytes: number[]): number[];
        function blake2b(bytes: number[], digestSize?: number): number[];
        function hmacSha2_256(key: number[], message: number[]): number[];
        function hmacSha2_512(key: number[], message: number[]): number[];
        function pbkdf2(prf: (key: number[], msg: number[]) => number[], password: number[], salt: number[], iters: number, dkLength: number): number[];
    }
    export namespace Ed25519 {
        function deriveBip32PublicKey(extendedKey: number[]): number[];
        function derivePublicKey(privateKey: number[]): number[];
        function signBip32(message: number[], extendedKey: number[]): number[];
        function sign(message: number[], privateKey: number[]): number[];
        function verify(signature: number[], message: number[], publicKey: number[]): boolean;
    }
    /**
     * Standard English Bip39 dictionary consisting of 2048 words allowing wallet root keys to be formed by a phrase of 12, 15, 18, 21 or 24 of these words.
     */
    export const BIP39_DICT_EN: string[];
    /**
     * @typedef {(i: number, bytes: number[]) => void} Decoder
     */
    /**
     * Base class of any Cbor serializable data class
     * Also
     */
    export class CborData {
        /**
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @returns {string}
         */
        toCborHex(): string;
    }
    export namespace Cbor {
        function encodeHead(m: number, n: bigint): number[];
        function decodeHead(bytes: number[]): [number, bigint];
        function encodeIndefHead(m: number): number[];
        function decodeIndefHead(bytes: number[]): number;
        function isNull(bytes: number[]): boolean;
        function encodeNull(): number[];
        function decodeNull(bytes: number[]): void;
        function encodeBool(b: boolean): number[];
        function decodeBool(bytes: number[]): boolean;
        function isBytes(bytes: number[]): boolean;
        function isDefBytes(bytes: number[]): boolean;
        function isIndefBytes(bytes: number[]): boolean;
        function encodeBytes(bytes: number[], splitIntoChunks?: boolean): number[];
        function decodeBytes(bytes: number[]): number[];
        function isUtf8(bytes: number[]): boolean;
        function encodeUtf8(str: string, split?: boolean): number[];
        function decodeUtf8Internal(bytes: number[]): string;
        function decodeUtf8(bytes: number[]): string;
        function encodeInteger(n: bigint): number[];
        function decodeInteger(bytes: number[]): bigint;
        function isIndefList(bytes: number[]): boolean;
        function encodeIndefListStart(): number[];
        function encodeListInternal(list: CborData[] | number[][]): number[];
        function encodeIndefListEnd(): number[];
        function encodeList(list: CborData[] | number[][]): number[];
        function encodeIndefList(list: CborData[] | number[][]): number[];
        function isDefList(bytes: number[]): boolean;
        function encodeDefListStart(n: bigint): number[];
        function encodeDefList(list: CborData[] | number[][]): number[];
        function isList(bytes: number[]): boolean;
        function decodeList(bytes: number[], itemDecoder: Decoder): void;
        function isTuple(bytes: number[]): boolean;
        function encodeTuple(tuple: number[][]): number[];
        function decodeTuple(bytes: number[], tupleDecoder: Decoder): number;
        function isMap(bytes: number[]): boolean;
        function encodeMapInternal(pairList: [number[] | CborData, number[] | CborData][]): number[];
        function encodeMap(pairList: [number[] | CborData, number[] | CborData][]): number[];
        function decodeMap(bytes: number[], pairDecoder: Decoder): void;
        function isObject(bytes: number[]): boolean;
        function encodeObject(object: Map<number, number[] | CborData>): number[];
        function decodeObject(bytes: number[], fieldDecoder: Decoder): Set<number>;
        function encodeTag(tag: bigint): number[];
        function decodeTag(bytes: number[]): bigint;
        function isConstr(bytes: number[]): boolean;
        function encodeConstrTag(tag: number): number[];
        function encodeConstr(tag: number, fields: CborData[] | number[][]): number[];
        function decodeConstrTag(bytes: number[]): number;
        function decodeConstr(bytes: number[], fieldDecoder: Decoder): number;
    }
    /**
     * Base class for Plutus-core data classes (not the same as Plutus-core value classes!)
     */
    export class UplcData extends CborData {
        /**
         * @param {number[] | string} bytes
         * @returns {UplcData}
         */
        static fromCbor(bytes: number[] | string): UplcData;
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * Estimate of memory usage during validation
         * @type {number}
         */
        get memSize(): number;
        /**
         * Compares the schema jsons
         * @param {UplcData} other
         * @returns {boolean}
         */
        isSame(other: UplcData): boolean;
        /**
         * @internal
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @internal
         * @type {bigint}
         */
        get int(): bigint;
        /**
         * @internal
         * @type {number}
         */
        get index(): number;
        /**
         * @internal
         * @type {UplcData[]}
         */
        get fields(): UplcData[];
        /**
         * @internal
         * @type {UplcData[]}
         */
        get list(): UplcData[];
        /**
         * @internal
         * @type {[UplcData, UplcData][]}
         */
        get map(): [UplcData, UplcData][];
        /**
         * @internal
         * @returns {IR}
         */
        toIR(): IR;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
    }
    /**
     * Represents an unbounded integer (bigint).
     */
    export class IntData extends UplcData {
        /**
         * Calculate the mem size of a integer (without the DATA_NODE overhead)
         * @internal
         * @param {bigint} value
         * @returns {number}
         */
        static memSizeInternal(value: bigint): number;
        /**
         * @param {number[]} bytes
         * @returns {IntData}
         */
        static fromCbor(bytes: number[]): IntData;
        /**
         * @param {bigint} value
         */
        constructor(value: bigint);
        /**
         * @type {bigint}
         */
        get value(): bigint;
        #private;
    }
    /**
     * Plutus-core bytearray data class.
     * Wraps a regular list of uint8 numbers (so not Uint8Array)
     */
    export class ByteArrayData extends UplcData {
        /**
         * Applies utf-8 encoding
         * @param {string} s
         * @returns {ByteArrayData}
         */
        static fromString(s: string): ByteArrayData;
        /**
         * Calculates the mem size of a byte array without the DATA_NODE overhead.
         * @param {number[]} bytes
         * @returns {number}
         */
        static memSizeInternal(bytes: number[]): number;
        /**
         * @param {number[]} bytes
         * @returns {ByteArrayData}
         */
        static fromCbor(bytes: number[]): ByteArrayData;
        /**
         * Bytearray comparison, which can be used for sorting bytearrays
         * @internal
         * @example
         * ByteArrayData.comp(hexToBytes("0101010101010101010101010101010101010101010101010101010101010101"), hexToBytes("0202020202020202020202020202020202020202020202020202020202020202")) == -1
         * @param {number[]} a
         * @param {number[]} b
         * @returns {number} - 0 -> equals, 1 -> gt, -1 -> lt
         */
        static comp(a: number[], b: number[]): number;
        /**
         * @param {number[]} bytes
         */
        constructor(bytes: number[]);
        /**
         * @returns {string}
         */
        toHex(): string;
        /**
         * @type {string}
         */
        get hex(): string;
        #private;
    }
    /**
     * Represents a list of other `UplcData` instances.
     */
    export class ListData extends UplcData {
        /**
         * @param {number[]} bytes
         * @returns {ListData}
         */
        static fromCbor(bytes: number[]): ListData;
        /**
         * @param {UplcData[]} items
         */
        constructor(items: UplcData[]);
        #private;
    }
    /**
     * Represents a list of pairs of other `UplcData` instances.
     */
    export class MapData extends UplcData {
        /**
         * @param {number[]} bytes
         * @returns {MapData}
         */
        static fromCbor(bytes: number[]): MapData;
        /**
         * @param {[UplcData, UplcData][]} pairs
         */
        constructor(pairs: [UplcData, UplcData][]);
        #private;
    }
    /**
     * Represents a tag index and a list of `UplcData` fields.
     */
    export class ConstrData extends UplcData {
        /**
         * @param {number[]} bytes
         * @returns {ConstrData}
         */
        static fromCbor(bytes: number[]): ConstrData;
        /**
         * @param {number} index
         * @param {UplcData[]} fields
         */
        constructor(index: number, fields: UplcData[]);
        #private;
    }
    /**
     * Base-type of all data-types that exist both on- and off-chain, and map directly to Helios instances.
     * @deprecated
     */
    export class HeliosData extends CborData {
        /**
         * Most HeliosData classes are builtins.
         * @internal
         * @returns {boolean}
         */
        static isBuiltin(): boolean;
        /**
         * Name begins with underscore so it can never conflict with structure field names.
         * @internal
         * @returns {UplcData}
         */
        _toUplcData(): UplcData;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
    }
    /**
     * Deprecated
     * @internal
     * @template {HeliosData} T
     * @typedef {{
     *   new(...args: any[]): T
     *   fromUplcCbor: (bytes: (string | number[])) => T
     *   fromUplcData: (data: UplcData) => T
     *   isBuiltin(): boolean
     * }} HeliosDataClass
     */
    /**
     * @deprecated
     * @typedef {number | bigint} HIntProps
     */
    /**
     * Helios Int type
     * @deprecated
     */
    export class HInt extends HeliosData {
        /**
         * @internal
         * @param {HIntProps} rawValue
         * @returns {bigint}
         */
        static cleanConstructorArg(rawValue: HIntProps): bigint;
        /**
         * @param {HInt | HIntProps} props
         * @returns {HInt}
         */
        static fromProps(props: HInt | HIntProps): HInt;
        /**
         * @param {UplcData} data
         * @returns {HInt}
         */
        static fromUplcData(data: UplcData): HInt;
        /**
         * @param {string | number[]} bytes
         * @returns {HInt}
         */
        static fromUplcCbor(bytes: string | number[]): HInt;
        /**
         * @param {number[]} bytes
         * @returns {HInt}
         */
        static fromCbor(bytes: number[]): HInt;
        /**
         * @param {HIntProps} rawValue
         */
        constructor(rawValue: HIntProps);
        /**
         * @type {bigint}
         */
        get value(): bigint;
        /**
         * @returns {string}
         */
        dump(): string;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        eq(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        neq(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        ge(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        gt(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        le(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        lt(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt| HIntProps} other
         * @returns {HInt}
         */
        add(other: HInt | HIntProps): HInt;
        /**
         * @param {HInt | HIntProps} other
         * @returns {HInt}
         */
        sub(other: HInt | HIntProps): HInt;
        /**
         * @param {HInt| HIntProps} other
         * @returns {HInt}
         */
        mul(other: HInt | HIntProps): HInt;
        #private;
    }
    /**
     * @internal
     * @typedef {number | bigint | string | Date} TimeProps
     */
    /**
     * Milliseconds since 1 jan 1970
     * @internal
     */
    export class Time extends HInt {
        /**
        * @internal
        * @param {TimeProps} props
        * @returns {bigint}
        */
        static cleanConstructorArg(props: TimeProps): bigint;
        /**
         * @param {Time | TimeProps} props
         * @returns {Time}
         */
        static fromProps(props: Time | TimeProps): Time;
        /**
         * @param {TimeProps} props
         */
        constructor(props: TimeProps);
    }
    /**
     * @internal
     * @typedef {HIntProps} DurationProps
     */
    /**
     * Difference between two time values in milliseconds.
     * @internal
     */
    export class Duration extends HInt {
    }
    /**
     * @internal
     * @typedef {boolean | string} BoolProps
     */
    /**
     * Helios Bool type
     * @internal
     */
    export class Bool extends HeliosData {
        /**
         * @internal
         * @param {BoolProps} props
         * @returns {boolean}
         */
        static cleanConstructorArg(props: BoolProps): boolean;
        /**
         * @param {Bool | BoolProps} props
         * @returns {Bool}
         */
        static fromProps(props: Bool | BoolProps): Bool;
        /**
         * @param {UplcData} data
         * @returns {Bool}
         */
        static fromUplcData(data: UplcData): Bool;
        /**
         * @param {string | number[]} bytes
         * @returns {Bool}
         */
        static fromUplcCbor(bytes: string | number[]): Bool;
        /**
         * @param {BoolProps} props
         */
        constructor(props: BoolProps);
        /**
         * @type {boolean}
         */
        get bool(): boolean;
        #private;
    }
    /**
     * @internal
     * @typedef {string} HStringProps
     */
    /**
     * Helios String type.
     * Can't be named 'String' because that would interfere with the javascript 'String'-type
     * @internal
     */
    export class HString extends HeliosData {
        /**
         * @param {HString | HStringProps} props
         * @returns {HString}
         */
        static fromProps(props: HString | HStringProps): HString;
        /**
         * @param {UplcData} data
         * @returns {HString}
         */
        static fromUplcData(data: UplcData): HString;
        /**
         * @param {string | number[]} bytes
         * @returns {HString}
         */
        static fromUplcCbor(bytes: string | number[]): HString;
        /**
         * @param {HStringProps} props
         */
        constructor(props: HStringProps);
        /**
         * @type {string}
         */
        get string(): string;
        #private;
    }
    /**
     * @deprecated
     * @typedef {number[] | string} ByteArrayProps
     */
    /**
     * Helios ByteArray type
     * @deprecated
     */
    export class ByteArray extends HeliosData {
        /**
         * @internal
         * @param {ByteArrayProps} props
         */
        static cleanConstructorArg(props: ByteArrayProps): number[];
        /**
         * @param {ByteArray | ByteArrayProps} props
         * @returns {ByteArray}
         */
        static fromProps(props: ByteArray | ByteArrayProps): ByteArray;
        /**
         * @param {UplcData} data
         * @returns {ByteArray}
         */
        static fromUplcData(data: UplcData): ByteArray;
        /**
         * @param {string | number[]} bytes
         * @returns {ByteArray}
         */
        static fromUplcCbor(bytes: string | number[]): ByteArray;
        /**
         * @param {number[]} bytes
         * @returns {ByteArray}
         */
        static fromCbor(bytes: number[]): ByteArray;
        /**
         * @param {ByteArrayProps} props
         */
        constructor(props: ByteArrayProps);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * Hexadecimal representation.
         * @type {string}
         */
        get hex(): string;
        /**
         * @param {ByteArray | ByteArrayProps} other
         * @returns {boolean}
         */
        eq(other: ByteArray | ByteArrayProps): boolean;
        #private;
    }
    /**
     * @typedef {number[] | string} HashProps
     */
    /**
     * Base class of all hash-types
     */
    export class Hash extends HeliosData {
        /**
         * @internal
         * @param {HashProps} props
         * @returns {number[]}
         */
        static cleanConstructorArg(props: HashProps): number[];
        /**
         * @param {Hash | HashProps} props
         * @returns {Hash}
         */
        static fromProps(props: Hash | HashProps): Hash;
        /**
         * Used internally for metadataHash and scriptDataHash
         * @param {number[]} bytes
         * @returns {Hash}
         */
        static fromCbor(bytes: number[]): Hash;
        /**
         * Might be needed for internal use
         * @param {string} str
         * @returns {Hash}
         */
        static fromHex(str: string): Hash;
        /**
         * @param {Hash} a
         * @param {Hash} b
         * @returns {number}
         */
        static compare(a: Hash, b: Hash): number;
        /**
         * @param {HashProps} props
         */
        constructor(props: HashProps);
        /**
         * @readonly
         * @type {number[]}
         */
        readonly bytes: number[];
        /**
         * Hexadecimal representation.
         * @returns {string}
         */
        get hex(): string;
        /**
         * @internal
         * @returns {string}
         */
        dump(): string;
        /**
         * @param {Hash} other
         * @returns {boolean}
         */
        eq(other: Hash): boolean;
    }
    /**
     * @typedef {HashProps} DatumHashProps
     */
    /**
     * Represents a blake2b-256 hash of datum data.
     */
    export class DatumHash extends Hash {
        /**
         * @param {UplcData} data
         * @returns {DatumHash}
         */
        static fromUplcData(data: UplcData): DatumHash;
        /**
         * @param {string | number[]} bytes
         * @returns {DatumHash}
         */
        static fromUplcCbor(bytes: string | number[]): DatumHash;
    }
    /**
     * @typedef {number[] | string} PubKeyProps
     */
    export class PubKey extends HeliosData {
        /**
         * @param {PubKey | PubKeyProps} props
         * @returns {PubKey}
         */
        static fromProps(props: PubKey | PubKeyProps): PubKey;
        /**
         * @returns {PubKey}
         */
        static dummy(): PubKey;
        /**
         * @param {UplcData} data
         * @returns {PubKey}
         */
        static fromUplcData(data: UplcData): PubKey;
        /**
         * @param {string | number[]} bytes
         * @returns {PubKey}
         */
        static fromUplcCbor(bytes: string | number[]): PubKey;
        /**
         * @param {number[]} bytes
         * @returns {PubKey}
         */
        static fromCbor(bytes: number[]): PubKey;
        /**
         * @param {PubKeyProps} props
         */
        constructor(props: PubKeyProps);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * Hexadecimal representation.
         * @type {string}
         */
        get hex(): string;
        /**
         * Can also be used as a Stake key hash
         * @type {PubKeyHash}
         */
        get pubKeyHash(): PubKeyHash;
        /**
         * @returns {boolean}
         */
        isDummy(): boolean;
        /**
         * @returns {number[]}
         */
        hash(): number[];
        /**
         * @returns {string}
         */
        dump(): string;
        #private;
    }
    /**
     * Represents a blake2b-224 hash of a PubKey
     *
     * **Note**: A `PubKeyHash` can also be used as the second part of a payment `Address`, or to construct a `StakeAddress`.
     * @typedef {HashProps} PubKeyHashProps
     */
    export class PubKeyHash extends Hash {
        /**
         * @returns {PubKeyHash}
         */
        static dummy(): PubKeyHash;
        /**
         * @param {UplcData} data
         * @returns {PubKeyHash}
         */
        static fromUplcData(data: UplcData): PubKeyHash;
        /**
         * @param {string | number[]} bytes
         * @returns {PubKeyHash}
         */
        static fromUplcCbor(bytes: string | number[]): PubKeyHash;
    }
    /**
     * @internal
     * @typedef {HashProps} ScriptHashProps
     */
    /**
     * Base class of MintingPolicyHash, ValidatorHash and StakingValidatorHash
     */
    export class ScriptHash extends Hash {
    }
    /**
     * @typedef {HashProps} MintingPolicyHashProps
     */
    /**
     * Represents a blake2b-224 hash of a minting policy script
     *
     * **Note**: to calculate this hash the script is first encoded as a CBOR byte-array and then prepended by a script version byte.
     */
    export class MintingPolicyHash extends ScriptHash {
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} props
         * @returns {MintingPolicyHash}
         */
        static fromProps(props: MintingPolicyHash | MintingPolicyHashProps): MintingPolicyHash;
        /**
         * @param {number[]} bytes
         * @returns {MintingPolicyHash}
         */
        static fromCbor(bytes: number[]): MintingPolicyHash;
        /**
         * @param {UplcData} data
         * @returns {MintingPolicyHash}
         */
        static fromUplcData(data: UplcData): MintingPolicyHash;
        /**
         * @param {string | number[]} bytes
         * @returns {MintingPolicyHash}
         */
        static fromUplcCbor(bytes: string | number[]): MintingPolicyHash;
        /**
         * @param {string} str
         * @returns {MintingPolicyHash}
         */
        static fromHex(str: string): MintingPolicyHash;
        /**
         * Encodes as bech32 string using 'asset' as human readable part
         * @returns {string}
         */
        toBech32(): string;
    }
    /**
     * @typedef {HashProps} StakingValidatorHashProps
     */
    /**
     * Represents a blake2b-224 hash of a staking script.
     *
     * **Note**: before hashing, the staking script is first encoded as a CBOR byte-array and then prepended by a script version byte.
     */
    export class StakingValidatorHash extends ScriptHash {
        /**
         * @param {UplcData} data
         * @returns {StakingValidatorHash}
         */
        static fromUplcData(data: UplcData): StakingValidatorHash;
        /**
         * @param {string | number[]} bytes
         * @returns {StakingValidatorHash}
         */
        static fromUplcCbor(bytes: string | number[]): StakingValidatorHash;
    }
    /**
     * @typedef {HashProps} ValidatorHashProps
     */
    /**
     * Represents a blake2b-224 hash of a spending validator script (first encoded as a CBOR byte-array and prepended by a script version byte).
     */
    export class ValidatorHash extends ScriptHash {
        /**
         * @param {UplcData} data
         * @returns {ValidatorHash}
         */
        static fromUplcData(data: UplcData): ValidatorHash;
        /**
         * @param {string | number[]} bytes
         * @returns {ValidatorHash}
         */
        static fromUplcCbor(bytes: string | number[]): ValidatorHash;
    }
    /**
     * @typedef {HashProps} TxIdProps
     */
    /**
     * Represents the hash of a transaction.
     *
     * This is also used to identify an UTxO (along with the index of the UTxO in the list of UTxOs created by the transaction).
     */
    export class TxId extends Hash {
        /**
         * @param {UplcData} data
         * @returns {TxId}
         */
        static fromUplcData(data: UplcData): TxId;
        /**
         * @param {string | number[]} bytes
         * @returns {TxId}
         */
        static fromUplcCbor(bytes: string | number[]): TxId;
        /**
         * Filled with 255 so that the internal show() function has max execution budget cost
         * @param {number} fill
         * @returns {TxId}
         */
        static dummy(fill?: number): TxId;
    }
    /**
     * @typedef {string | [
     * 	 TxId | TxIdProps,
     *   HInt | HIntProps
     * ] | {
     *   txId: TxId | TxIdProps
     *   utxoId: HInt | HIntProps
     * }} TxOutputIdProps
     */
    /**
     * Id of a Utxo
     */
    export class TxOutputId extends HeliosData {
        /**
         * @param  {TxOutputIdProps} props
         * @returns {[TxId | TxIdProps, HInt | HIntProps]}
         */
        static cleanConstructorArgs(props: TxOutputIdProps): [TxId | TxIdProps, HInt | HIntProps];
        /**
         * @returns {TxOutputId}
         */
        static dummy(): TxOutputId;
        /**
         * @param {TxOutputId | TxOutputIdProps} props
         * @returns {TxOutputId}
         */
        static fromProps(props: TxOutputId | TxOutputIdProps): TxOutputId;
        /**
         * @param {UplcData} data
         * @returns {TxOutputId}
         */
        static fromUplcData(data: UplcData): TxOutputId;
        /**
         * @param {string | number[]} bytes
         * @returns {TxOutputId}
         */
        static fromUplcCbor(bytes: string | number[]): TxOutputId;
        /**
         * @param {string | number[]} rawBytes
         * @returns {TxOutputId}
         */
        static fromCbor(rawBytes: string | number[]): TxOutputId;
        /**
         *
         * @param {TxOutputId} a
         * @param {TxOutputId} b
         * @returns {number}
         */
        static comp(a: TxOutputId, b: TxOutputId): number;
        /**
         * @overload
         * @param {TxId} txId
         * @param {bigint | number} utxoId
         */
        /**
         * @overload
         * @param {TxOutputIdProps} props
         */
        /**
         * @param {([TxOutputIdProps] | [TxId, bigint | number])} args
         */
        constructor(...args: ([TxOutputIdProps] | [TxId, bigint | number]));
        /**
         * @type {TxId}
         */
        get txId(): TxId;
        /**
         * @type {number}
         */
        get utxoIdx(): number;
        /**
         * @param {TxOutputId} other
         * @returns {boolean}
         */
        eq(other: TxOutputId): boolean;
        /**
         * @returns {ConstrData}
         */
        _toUplcData(): ConstrData;
        #private;
    }
    /**
     * An array of bytes, a Bech32 encoded address, or the hexadecimal representation of the underlying bytes.
     * @typedef {number[] | string} AddressProps
     */
    /**
     * Wrapper for Cardano address bytes. An `Address` consists of three parts internally:
     *   * Header (1 byte, see [CIP 19](https://cips.cardano.org/cips/cip19/))
     *   * Witness hash (28 bytes that represent the `PubKeyHash` or `ValidatorHash`)
     *   * Optional staking credential (0 or 28 bytes)
     */
    export class Address extends HeliosData {
        /**
         * @internal
         * @param {AddressProps} props
         * @returns {number[]}
         */
        static cleanConstructorArg(props: AddressProps): number[];
        /**
         * @param {Address | AddressProps} props
         * @returns {Address}
         */
        static fromProps(props: Address | AddressProps): Address;
        /**
         * Returns a dummy address (based on a PubKeyHash with all null bytes)
         * @returns {Address}
         */
        static dummy(): Address;
        /**
         * Deserializes bytes into an `Address`.
         * @param {number[]} bytes
         * @returns {Address}
         */
        static fromCbor(bytes: number[]): Address;
        /**
         * Converts a Bech32 string into an `Address`.
         * @param {string} str
         * @returns {Address}
         */
        static fromBech32(str: string): Address;
        /**
         * Constructs an `Address` using a hexadecimal string representation of the address bytes.
         * Doesn't check validity.
         * @param {string} hex
         * @returns {Address}
         */
        static fromHex(hex: string): Address;
        /**
        * Constructs an Address using either a `PubKeyHash` (i.e. simple payment address)
        * or `ValidatorHash` (i.e. script address),
        * without a staking hash.
        * @param {PubKeyHash | ValidatorHash} hash
        * @param {boolean} isTestnet Defaults to `config.IS_TESTNET`
        * @returns {Address}
        */
        static fromHash(hash: PubKeyHash | ValidatorHash, isTestnet?: boolean): Address;
        /**
         * Constructs an Address using either a `PubKeyHash` (i.e. simple payment address)
         * or `ValidatorHash` (i.e. script address),
         * in combination with an optional staking hash (`PubKeyHash` or `StakingValidatorHash`).
         * @param {PubKeyHash | ValidatorHash} hash
         * @param {null | (PubKeyHash | StakingValidatorHash)} stakingHash
         * @param {boolean} isTestnet Defaults to `config.IS_TESTNET`
         * @returns {Address}
         */
        static fromHashes(hash: PubKeyHash | ValidatorHash, stakingHash?: null | (PubKeyHash | StakingValidatorHash), isTestnet?: boolean): Address;
        /**
         * Simple payment address with an optional staking hash (`PubKeyHash` or `StakingValidatorHash`).
         * @internal
         * @param {PubKeyHash} hash
         * @param {null | (PubKeyHash | StakingValidatorHash)} stakingHash
         * @param {boolean} isTestnet Defaults to `config.IS_TESTNET`
         * @returns {Address}
         */
        static fromPubKeyHash(hash: PubKeyHash, stakingHash?: null | (PubKeyHash | StakingValidatorHash), isTestnet?: boolean): Address;
        /**
         * Simple script address with an optional staking hash (`PubKeyHash` or `StakingValidatorHash`).
         * @internal
         * @param {ValidatorHash} hash
         * @param {null | (PubKeyHash | StakingValidatorHash)} stakingHash
         * @param {boolean} isTestnet Defaults to `config.IS_TESTNET`
         * @returns {Address}
         */
        static fromValidatorHash(hash: ValidatorHash, stakingHash?: null | (PubKeyHash | StakingValidatorHash), isTestnet?: boolean): Address;
        /**
         * Returns `true` if the given `Address` is a testnet address.
         * @param {Address} address
         * @returns {boolean}
         */
        static isForTestnet(address: Address): boolean;
        /**
         * @param {UplcData} data
         * @param {boolean} isTestnet
         * @returns {Address}
         */
        static fromUplcData(data: UplcData, isTestnet?: boolean): Address;
        /**
         * @internal
         * @param {string | number[]} bytes
         * @param {boolean} isTestnet
         * @returns {Address}
         */
        static fromUplcCbor(bytes: string | number[], isTestnet?: boolean): Address;
        /**
         * Used to sort txbody withdrawals.
         * @internal
         * @param {Address} a
         * @param {Address} b
         * @return {number}
         */
        static compStakingHashes(a: Address, b: Address): number;
        /**
         * @param {number[] | string} bytesOrBech32String
         */
        constructor(bytesOrBech32String: number[] | string);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * Converts a `Address` into its hexadecimal representation.
         * @returns {string}
         */
        toHex(): string;
        /**
         * Converts a `Address` into its hexadecimal representation.
         * @returns {string}
         */
        get hex(): string;
        /**
         * Converts an `Address` into its Bech32 representation.
         * @returns {string}
         */
        toBech32(): string;
        /**
         * @param {Address} other
         * @returns {boolean}
         */
        eq(other: Address): boolean;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @internal
         * @returns {ConstrData}
         */
        toCredentialData(): ConstrData;
        /**
         * @internal
         * @returns {ConstrData}
         */
        toStakingData(): ConstrData;
        /**
         * Returns the underlying `PubKeyHash` of a simple payment address, or `null` for a script address.
         * @type {null | PubKeyHash}
         */
        get pubKeyHash(): PubKeyHash | null;
        /**
         * Returns the underlying `ValidatorHash` of a script address, or `null` for a regular payment address.
         * @type {null | ValidatorHash}
         */
        get validatorHash(): ValidatorHash | null;
        /**
         * Returns the underlying `PubKeyHash` or `StakingValidatorHash`, or `null` for non-staked addresses.
         * @type {null | PubKeyHash | StakingValidatorHash}
         */
        get stakingHash(): PubKeyHash | StakingValidatorHash | null;
        #private;
    }
    /**
     * @typedef {string | [
     *   MintingPolicyHash | MintingPolicyHashProps,
     *   ByteArray | ByteArrayProps
     * ] | {
     *   mph: MintingPolicyHash | MintingPolicyHashProps,
     *   tokenName: ByteArray | ByteArrayProps
     * }} AssetClassProps
     */
    /**
     * Represents a `MintingPolicyHash` combined with a token name.
     */
    export class AssetClass extends HeliosData {
        /**
         * @internal
         * @param {AssetClassProps} props
         * @returns {[MintingPolicyHash | MintingPolicyHashProps, ByteArray | ByteArrayProps]}
         */
        static cleanConstructorArgs(props: AssetClassProps): [MintingPolicyHash | MintingPolicyHashProps, ByteArray | ByteArrayProps];
        /**
         * @param {AssetClass | AssetClassProps} props
         * @returns {AssetClass}
         */
        static fromProps(props: AssetClass | AssetClassProps): AssetClass;
        /**
         *
         * @param {UplcData} data
         * @returns {AssetClass}
         */
        static fromUplcData(data: UplcData): AssetClass;
        /**
         * Deserializes bytes into an `AssetClass`.
         * @param {number[]} bytes
         * @returns {AssetClass}
         */
        static fromCbor(bytes: number[]): AssetClass;
        /**
         * @param {string | number[]} bytes
         * @returns {AssetClass}
         */
        static fromUplcCbor(bytes: string | number[]): AssetClass;
        /**
         * @type {AssetClass}
         */
        static get ADA(): AssetClass;
        /**
         * Intelligently converts arguments.
         *
         * The format for single argument string is "<hex-encoded-mph>.<hex-encoded-token-name>".
         * @param {AssetClassProps} props
         */
        constructor(props: AssetClassProps);
        /**
         * @type {MintingPolicyHash}
         */
        get mintingPolicyHash(): MintingPolicyHash;
        /**
         * @type {ByteArray}
         */
        get tokenName(): ByteArray;
        /**
         * Used when generating script contexts for running programs
         * @returns {ConstrData}
         */
        _toUplcData(): ConstrData;
        /**
         * Cip14 fingerprint
         * This involves a hash, so you can't use a fingerprint to calculate the underlying policy/tokenName.
         * @returns {string}
         */
        toFingerprint(): string;
        #private;
    }
    /**
     * @typedef {[
     *   AssetClass | AssetClassProps,
     *   HInt | HIntProps
     * ][] | [
     *   MintingPolicyHash | MintingPolicyHashProps,
     *   [
     *     ByteArray | ByteArrayProps,
     *     HInt | HIntProps
     *   ][]
     * ][]} AssetsProps
     */
    /**
     * Represents a list of non-Ada tokens.
     */
    export class Assets extends CborData {
        /**
         * @param {Assets | AssetsProps} props
         * @returns {Assets}
         */
        static fromProps(props: Assets | AssetsProps): Assets;
        /**
         * @param {number[]} bytes
         * @returns {Assets}
         */
        static fromCbor(bytes: number[]): Assets;
        /**
         * **Note**: the assets are normalized by removing entries with 0 tokens, and merging all entries with the same MintingPolicyHash and token name.
         * @param {AssetsProps} props Either a list of `AssetClass`/quantity pairs, or a list of `MintingPolicyHash`/`tokens` pairs (where each `tokens` entry is a bytearray/quantity pair).
         */
        constructor(props?: AssetsProps);
        /**
         * @private
         * @type {[MintingPolicyHash, [ByteArray, HInt][]][]}
         */
        private assets;
        /**
         * Returns a list of all the minting policies.
         * @type {MintingPolicyHash[]}
         */
        get mintingPolicies(): MintingPolicyHash[];
        /**
         * @type {number}
         */
        get nTokenTypes(): number;
        /**
         * Returns empty if mph not found
         * @param {MintingPolicyHash} mph
         * @returns {[ByteArray, HInt][]}
         */
        getTokens(mph: MintingPolicyHash): [ByteArray, HInt][];
        /**
         * @returns {boolean}
         */
        isZero(): boolean;
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {ByteArray | ByteArrayProps} tokenName
         * @returns {boolean}
         */
        has(mph: MintingPolicyHash | MintingPolicyHashProps, tokenName: ByteArray | ByteArrayProps): boolean;
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {ByteArray | ByteArrayProps} tokenName
         * @returns {bigint}
         */
        get(mph: MintingPolicyHash | MintingPolicyHashProps, tokenName: ByteArray | ByteArrayProps): bigint;
        /**
         * Mutates 'this'
         */
        removeZeroes(): void;
        /**
         * Removes zeros and merges duplicates.
         * In-place algorithm.
         * Keeps the same order as much as possible.
         */
        normalize(): void;
        /**
         * Mutates 'this'.
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {ByteArray | ByteArrayProps} tokenName
         * @param {HInt | HIntProps} qty
         */
        addComponent(mph: MintingPolicyHash | MintingPolicyHashProps, tokenName: ByteArray | ByteArrayProps, qty: HInt | HIntProps): void;
        /**
         * @internal
         * @param {Assets} other
         * @param {(a: bigint, b: bigint) => bigint} op
         * @returns {Assets}
         */
        applyBinOp(other: Assets, op: (a: bigint, b: bigint) => bigint): Assets;
        /**
         * @param {Assets} other
         * @returns {Assets}
         */
        add(other: Assets): Assets;
        /**
         * @param {Assets} other
         * @returns {Assets}
         */
        sub(other: Assets): Assets;
        /**
         * @param {HInt | HIntProps} scalar
         * @returns {Assets}
         */
        mul(scalar: HInt | HIntProps): Assets;
        /**
         * Mutates 'this'.
         * Throws error if mph is already contained in 'this'.
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {[ByteArray | ByteArrayProps, HInt | HIntProps][]} tokens
         */
        addTokens(mph: MintingPolicyHash | MintingPolicyHashProps, tokens: [ByteArray | ByteArrayProps, HInt | HIntProps][]): void;
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @returns {ByteArray[]}
         */
        getTokenNames(mph: MintingPolicyHash | MintingPolicyHashProps): ByteArray[];
        /**
         * @param {Assets} other
         * @returns {boolean}
         */
        eq(other: Assets): boolean;
        /**
         * Strict gt, if other contains assets this one doesn't contain => return false
         * @param {Assets} other
         * @returns {boolean}
         */
        gt(other: Assets): boolean;
        /**
         * @param {Assets} other
         * @returns {boolean}
         */
        ge(other: Assets): boolean;
        /**
         * @returns {boolean}
         */
        allPositive(): boolean;
        /**
         * Throws an error if any contained quantity <= 0n
         */
        assertAllPositive(): void;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * Used when generating script contexts for running programs
         * @returns {MapData}
         */
        _toUplcData(): MapData;
        /**
         * Makes sure minting policies are in correct order, and for each minting policy make sure the tokens are in the correct order
         * Mutates 'this'
         */
        sort(): void;
        assertSorted(): void;
    }
    /**
     * @typedef {HInt | HIntProps | [
     *   HInt | HIntProps,
     *   Assets | AssetsProps
     * ] | {
     *   lovelace: HInt| HIntProps,
     *   assets?:   Assets | AssetsProps
     * }} ValueProps
     */
    /**
     * Represents a collection of tokens.
     */
    export class Value extends HeliosData {
        /**
         * @param {ValueProps} props
         * @param {null | Assets | AssetsProps} maybeAssets
         * @returns {[HInt | HIntProps, Assets | AssetsProps]}
         */
        static cleanConstructorArgs(props: ValueProps, maybeAssets: null | Assets | AssetsProps): [HInt | HIntProps, Assets | AssetsProps];
        /**
         * @param {ValueProps | Value} props
         * @returns {Value}
         */
        static fromProps(props: ValueProps | Value): Value;
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {ByteArray | ByteArrayProps} tokenName
         * @param {HInt | HIntProps} qty
         * @returns {Value}
         */
        static asset(mph: MintingPolicyHash | MintingPolicyHashProps, tokenName: ByteArray | ByteArrayProps, qty: HInt | HIntProps): Value;
        /**
         * @param {number[]} bytes
         * @returns {Value}
         */
        static fromCbor(bytes: number[]): Value;
        /**
         * @param {Value[]} values
         * @returns {Value}
         */
        static sum(values: Value[]): Value;
        /**
         * Converts a `UplcData` instance into a `Value`. Throws an error if it isn't in the right format.
         * @param {UplcData} data
         * @returns {Value}
         */
        static fromUplcData(data: UplcData): Value;
        /**
         * @param {string | number[]} bytes
         * @returns {Value}
         */
        static fromUplcCbor(bytes: string | number[]): Value;
        /**
         * @param {ValueProps} props
         * @param {null | Assets | AssetsProps} assets
         */
        constructor(props?: ValueProps, assets?: null | Assets | AssetsProps);
        /**
         * Gets the `Assets` contained in the `Value`.
         * @type {Assets}
         */
        get assets(): Assets;
        /**
         * Gets the lovelace quantity contained in the `Value`.
         * @type {bigint}
         */
        get lovelace(): bigint;
        /**
         * Mutates the quantity of lovelace in a `Value`.
         * @param {HInt | HIntProps} lovelace
         */
        setLovelace(lovelace: HInt | HIntProps): void;
        /**
         * Adds two `Value` instances together. Returns a new `Value` instance.
         * @param {Value} other
         * @returns {Value}
         */
        add(other: Value): Value;
        /**
         * Substracts one `Value` instance from another. Returns a new `Value` instance.
         * @param {Value} other
         * @returns {Value}
         */
        sub(other: Value): Value;
        /**
         * Multiplies a `Value` by a whole number.
         * @param {HInt | HIntProps} scalar
         * @returns {Value}
         */
        mul(scalar: HInt | HIntProps): Value;
        /**
         * Checks if two `Value` instances are equal (`Assets` need to be in the same order).
         * @param {Value} other
         * @returns {boolean}
         */
        eq(other: Value): boolean;
        /**
         * Checks if a `Value` instance is strictly greater than another `Value` instance. Returns false if any asset is missing.
         * @param {Value} other
         * @returns {boolean}
         */
        gt(other: Value): boolean;
        /**
         * Checks if a `Value` instance is strictly greater or equal to another `Value` instance. Returns false if any asset is missing.
         * @param {Value} other
         * @returns {boolean}
         */
        ge(other: Value): boolean;
        /**
         * Throws an error if any of the `Value` entries is negative.
         *
         * Used when building transactions because transactions can't contain negative values.
         * @returns {Value} - returns this
         */
        assertAllPositive(): Value;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * Used when building script context
         * @param {boolean} isInScriptContext
         * @returns {MapData}
         */
        _toUplcData(isInScriptContext?: boolean): MapData;
        #private;
    }
    /**
     * @typedef {Object} Cost
     * @property {bigint} mem
     * @property {bigint} cpu
     */
    /**
     * @typedef {() => bigint} LiveSlotGetter
     */
    /**
     * Wrapper for the raw JSON containing all the current network parameters.
     *
     * NetworkParams is needed to be able to calculate script budgets and perform transaction building checks.
     *
     * The raw JSON can be downloaded from the following CDN locations:
     *
     *  - Preview: [https://d1t0d7c2nekuk0.cloudfront.net/preview.json](https://d1t0d7c2nekuk0.cloudfront.net/preview.json)
     *  - Preprod: [https://d1t0d7c2nekuk0.cloudfront.net/preprod.json](https://d1t0d7c2nekuk0.cloudfront.net/preprod.json)
     *  - Mainnet: [https://d1t0d7c2nekuk0.cloudfront.net/mainnet.json](https://d1t0d7c2nekuk0.cloudfront.net/mainnet.json)
     *
     * These JSONs are updated every 15 minutes.
     */
    export class NetworkParams {
        /**
         * @param {Object} raw
         * @param {null | LiveSlotGetter} liveSlotGetter
         */
        constructor(raw: any, liveSlotGetter?: null | LiveSlotGetter);
        /**
         * @type {Object}
         */
        get raw(): any;
        /**
         * @type {null | bigint}
         */
        get liveSlot(): bigint | null;
        /**
         * @internal
         * @type {Object}
         */
        get costModel(): any;
        /**
         * @internal
         * @param {string} key
         * @returns {number}
         */
        getCostModelParameter(key: string): number;
        /**
         * @internal
         * @param {string} name
         * @returns {Cost}
         */
        getTermCost(name: string): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreStartupCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreVariableCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreLambdaCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreDelayCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreCallCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreConstCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreForceCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreBuiltinCost(): Cost;
        /**
         * @internal
         * @type {[number, number]} - a + b*size
         */
        get txFeeParams(): [number, number];
        /**
         * @internal
         * @type {[number, number]} - [memFee, cpuFee]
         */
        get exFeeParams(): [number, number];
        /**
         * @internal
         * @type {number[]}
         */
        get sortedCostParams(): number[];
        /**
         * @internal
         * @type {number}
         */
        get lovelacePerUTXOByte(): number;
        /**
         * @internal
         * @type {number}
         */
        get minCollateralPct(): number;
        /**
         * @internal
         * @type {number}
         */
        get maxCollateralInputs(): number;
        /**
         * @internal
         * @type {[number, number]} - [mem, cpu]
         */
        get maxTxExecutionBudget(): [number, number];
        /**
         * @internal
         * @type {number}
         */
        get maxTxSize(): number;
        /**
         * @type {bigint}
         */
        get stakeAddressDeposit(): bigint;
        /**
         * Tx balancing picks additional inputs by starting from maxTxFee.
         * This is done because the order of the inputs can have a huge impact on the tx fee, so the order must be known before balancing.
         * If there aren't enough inputs to cover the maxTxFee and the min deposits of newly created UTxOs, the balancing will fail.
         * @type {bigint}
         */
        get maxTxFee(): bigint;
        /**
         * Calculates the time (in milliseconds in 01/01/1970) associated with a given slot number.
         * @param {bigint} slot
         * @returns {bigint}
         */
        slotToTime(slot: bigint): bigint;
        /**
         * Calculates the slot number associated with a given time. Time is specified as milliseconds since 01/01/1970.
         * @param {bigint} time Milliseconds since 1970
         * @returns {bigint}
         */
        timeToSlot(time: bigint): bigint;
        #private;
    }
    /**
     * Each builtin has an associated CostModel.
     * The CostModel calculates the execution cost of a builtin, depending on the byte-size of the inputs.
     * @internal
     */
    export class CostModel {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName
         * @returns {CostModel}
         */
        static fromParams(params: NetworkParams, baseName: string): CostModel;
        /**
         * @param {number[]} args
         * @returns {bigint}
         */
        calc(args: number[]): bigint;
        /**
         * @returns {string}
         */
        dump(): string;
    }
    /**
     * A simple constant cost, independent of arg size.
     * @internal
     */
    export class ConstCost extends CostModel {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {ConstCost}
         */
        static fromParams(params: NetworkParams, baseName: string): ConstCost;
        /**
         * @param {bigint} constant
         */
        constructor(constant: bigint);
        #private;
    }
    /**
     * cost = a + b*size(arg)
     * @internal
     */
    export class LinearCost extends CostModel {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {[bigint, bigint]}
         */
        static getParams(params: NetworkParams, baseName: string): [bigint, bigint];
        /**
         * a + b*SizeFn(x, y)
         * @param {bigint} a - intercept
         * @param {bigint} b - slope
         */
        constructor(a: bigint, b: bigint);
        /**
         * @param  {number} size
         * @returns {bigint}
         */
        calcInternal(size: number): bigint;
        #private;
    }
    /**
     * cost = a + b*size(args[i])
     * @internal
     */
    export class ArgSizeCost extends LinearCost {
        /**
         * @param {bigint} a - intercept
         * @param {bigint} b - slope
         * @param {number} i - index of the arg
         */
        constructor(a: bigint, b: bigint, i: number);
        #private;
    }
    /**
     * cost = a + b*size(arg0)
     * @internal
     */
    export class Arg0SizeCost extends ArgSizeCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {Arg0SizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): Arg0SizeCost;
        /**
         * @param {bigint} a
         * @param {bigint} b
         */
        constructor(a: bigint, b: bigint);
    }
    /**
     * cost = a + b*size(arg1)
     * @internal
     */
    export class Arg1SizeCost extends ArgSizeCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {Arg1SizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): Arg1SizeCost;
        /**
         * @param {bigint} a
         * @param {bigint} b
         */
        constructor(a: bigint, b: bigint);
    }
    /**
     * cost = a + b*size(arg2)
     * @internal
     */
    export class Arg2SizeCost extends ArgSizeCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {Arg2SizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): Arg2SizeCost;
        /**
         * @param {bigint} a
         * @param {bigint} b
         */
        constructor(a: bigint, b: bigint);
    }
    /**
     * cost = a + b*min(args)
     * @internal
     */
    export class MinArgSizeCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {MaxArgSizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): MaxArgSizeCost;
    }
    /**
     * cost = a + b*max(args)
     * @internal
     */
    export class MaxArgSizeCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {MaxArgSizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): MaxArgSizeCost;
    }
    /**
     * cost = a + b*sum(sizes(args))
     * @internal
     */
    export class SumArgSizesCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {MaxArgSizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): MaxArgSizeCost;
    }
    /**
     * cost = a + b*max(size(arg0)-size(arg1), min)
     * (only for Uplc functions with two arguments)
     * @internal
     */
    export class ArgSizeDiffCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {ArgSizeDiffCost}
         */
        static fromParams(params: NetworkParams, baseName: string): ArgSizeDiffCost;
        /**
         * @param {bigint} a - intercept
         * @param {bigint} b - slope
         * @param {number} min
         */
        constructor(a: bigint, b: bigint, min: number);
        #private;
    }
    /**
     * cost = (size(arg0) > size(arg1)) ? constant : a + b*size(arg0)*size(arg1)
     * (only for Uplc functions with two arguments)
     * @internal
     */
    export class ArgSizeProdCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {MaxArgSizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): MaxArgSizeCost;
        /**
         * @param {bigint} a - intercept
         * @param {bigint} b - slope
         * @param {bigint} constant
         */
        constructor(a: bigint, b: bigint, constant: bigint);
        #private;
    }
    /**
     * cost = (size(arg0) != size(arg1)) ? constant : a + b*size(arg0)
     * (only for Uplc functions with two arguments)
     * @internal
     */
    export class ArgSizeDiagCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {ArgSizeDiagCost}
         */
        static fromParams(params: NetworkParams, baseName: string): ArgSizeDiagCost;
        /**
         * @param {bigint} a
         * @param {bigint} b
         * @param {bigint} constant
         */
        constructor(a: bigint, b: bigint, constant: bigint);
        #private;
    }
    /**
     * @internal
     * @typedef CostModelClass
     * @property {(params: NetworkParams, baseName: string) => CostModel} fromParams
     */
    /**
     * @internal
     */
    export const BUILTIN_PREFIX: "__core__";
    /**
     * @internal
     */
    export const SAFE_BUILTIN_SUFFIX: "__safe";
    /**
     * Cost-model configuration of UplcBuiltin.
     * Also specifies the number of times a builtin must be 'forced' before being callable.
     * @internal
     */
    export class UplcBuiltinConfig {
        /**
         * @param {string} name
         * @param {number} forceCount - number of type parameters of a Plutus-core builtin function (0, 1 or 2)
         * @param {number} nArgs
         * @param {boolean} allowAny
         * @param {CostModelClass} memCostModelClass
         * @param {CostModelClass} cpuCostModelClass
         */
        constructor(name: string, forceCount: number, nArgs: number, allowAny: boolean, memCostModelClass: CostModelClass, cpuCostModelClass: CostModelClass);
        get name(): string;
        get forceCount(): number;
        get nArgs(): number;
        get allowAny(): boolean;
        /**
         * @param {NetworkParams} params
         * @returns {[CostModel, CostModel]}
         */
        instantiateCostModels(params: NetworkParams): [CostModel, CostModel];
        /**
         * @param {NetworkParams} params
         * @param {number[]} argSizes
         * @returns {Cost}
         */
        calcCost(params: NetworkParams, argSizes: number[]): Cost;
        /**
         * @param {NetworkParams} params
         */
        dumpCostModel(params: NetworkParams): void;
        #private;
    }
    /**
     * A list of all PlutusScript builins, with associated costmodels (actual costmodel parameters are loaded from NetworkParams during runtime)
     * @internal
     * @type {UplcBuiltinConfig[]}
     */
    export const UPLC_BUILTINS: UplcBuiltinConfig[];
    /**
     * @internal
     */
    export const UPLC_MACROS_OFFSET: number;
    /**
     * Index to helios-specific macro mapping
     * @internal
     */
    export const UPLC_MACROS: string[];
    /**
     * A Helios/Uplc Program can have different purposes
     * @typedef {"testing" | "minting" | "spending" | "staking" | "endpoint" | "module" | "unknown"} ScriptPurpose
     */
    /**
     * a UplcValue is passed around by Plutus-core expressions.
     */
    export class UplcValue {
        /**
         * @param {Site} site
         */
        constructor(site: Site);
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * Return a copy of the UplcValue at a different Site.
         * @internal
         * @param {Site} newSite
         * @returns {UplcValue}
         */
        copy(newSite: Site): UplcValue;
        /**
         * @internal
         * @type {Site}
         */
        get site(): Site;
        /**
         * @internal
         * @type {number}
         */
        get length(): number;
        /**
         * Size in words (8 bytes, 64 bits) occupied in target node
         * @internal
         * @type {number}
         */
        get memSize(): number;
        /**
         * @returns {boolean}
         */
        isAny(): boolean;
        /**
         * @type {bigint}
         */
        get int(): bigint;
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {string}
         */
        get string(): string;
        /**
         * @type {boolean}
         */
        get bool(): boolean;
        /**
         * Distinguishes a pair from a mapItem
         * @returns {boolean}
         */
        isPair(): boolean;
        /**
         * @type {UplcValue}
         */
        get first(): UplcValue;
        /**
         * @type {UplcValue}
         */
        get second(): UplcValue;
        /**
         * Distinguishes a list from a map
         * @returns {boolean}
         */
        isList(): boolean;
        /**
         * @type {UplcType}
         */
        get itemType(): UplcType;
        /**
         * @type {UplcValue[]}
         */
        get list(): UplcValue[];
        /**
         * @returns {boolean}
         */
        isData(): boolean;
        /**
         * @type {UplcData}
         */
        get data(): UplcData;
        /**
         * @internal
         * @returns {Promise<UplcValue>}
         */
        force(): Promise<UplcValue>;
        /**
         * @internal
         * @returns {UplcUnit}
         */
        assertUnit(): UplcUnit;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @internal
         * @returns {string}
         */
        typeBits(): string;
        /**
         * Encodes value without type header
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlatValueInternal(bitWriter: BitWriter): void;
        /**
         * Encodes value with plutus flat encoding.
         * Member function not named 'toFlat' as not to confuse with 'toFlat' member of terms.
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlatValue(bitWriter: BitWriter): void;
        #private;
    }
    /**
     * Represents the typeBits of a UPLC primitive.
     */
    export class UplcType {
        /**
         * @returns {UplcType}
         */
        static newDataType(): UplcType;
        /**
         * @returns {UplcType}
         */
        static newDataPairType(): UplcType;
        /**
         * @param {number[]} lst
         * @returns {UplcType}
         */
        static fromNumbers(lst: number[]): UplcType;
        /**
         * @param {string} typeBits
         */
        constructor(typeBits: string);
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * @returns {string}
         */
        typeBits(): string;
        /**
         * @param {UplcValue} value
         * @returns {boolean}
         */
        isSameType(value: UplcValue): boolean;
        /**
         * @returns {boolean}
         */
        isData(): boolean;
        /**
         * @returns {boolean}
         */
        isDataPair(): boolean;
        #private;
    }
    /**
     * @typedef {[null | string, UplcValue][]} UplcRawStack
     */
    /**
     * @typedef {{
     *	 onPrint: (msg: string) => Promise<void>
     *   onStartCall: (site: Site, rawStack: UplcRawStack) => Promise<boolean>
     *   onEndCall: (site: Site, rawStack: UplcRawStack) => Promise<void>
     *   onIncrCost: (name: string, isTerm: boolean, cost: Cost) => void
     * }} UplcRTECallbacks
     */
    /**
     * @internal
     * @typedef {UplcRTECallbacks & {
     *   macros?: {[name: string]: (rte: UplcRte, args: UplcValue[]) => Promise<UplcValue>}
     * }} UplcRTECallbacksInternal
     */
    /**
     * Configures the Uplc evaluator to print messages to `console`.
     * @type {UplcRTECallbacks}
     */
    export const DEFAULT_UPLC_RTE_CALLBACKS: UplcRTECallbacks;
    /**
     * Plutus-core Runtime Environment is used for controlling the programming evaluation (eg. by a debugger)
     * @internal
     */
    export class UplcRte {
        /**
         * @param {UplcRTECallbacksInternal} callbacks
         * @param {null | NetworkParams} networkParams
         */
        constructor(callbacks?: UplcRTECallbacksInternal, networkParams?: null | NetworkParams);
        /**
         * @type {string[]}
         */
        get messages(): string[];
        /**
         * @returns {string}
         */
        popLastMessage(): string;
        /**
         * @returns {boolean}
         */
        hasError(): boolean;
        /**
         * @returns {string | RuntimeError}
         */
        getError(): string | RuntimeError;
        /**
         * @param {string | RuntimeError} err
         * @returns {UplcValue}
         */
        error(err: string | RuntimeError): UplcValue;
        throwError(): void;
        /**
         * @param {string} name - for breakdown
         * @param {boolean} isTerm
         * @param {Cost} cost
         */
        incrCost(name: string, isTerm: boolean, cost: Cost): void;
        incrStartupCost(): void;
        incrVariableCost(): void;
        incrLambdaCost(): void;
        incrDelayCost(): void;
        incrCallCost(): void;
        incrConstCost(): void;
        incrForceCost(): void;
        incrBuiltinCost(): void;
        /**
         * @param {UplcBuiltin} fn
         * @param {UplcValue[]} args
         */
        calcAndIncrCost(fn: UplcBuiltin, ...args: UplcValue[]): void;
        /**
         * @param {string} name
         * @param {UplcValue[]} args
         * @returns {Promise<UplcValue>}
         */
        callMacro(name: string, args: UplcValue[]): Promise<UplcValue>;
        /**
         * Gets variable using Debruijn index. Throws error here because UplcRTE is the stack root and doesn't contain any values.
         * @param {number} i
         * @returns {UplcValue}
         */
        get(i: number): UplcValue;
        /**
         * Creates a child stack.
         * @param {UplcValue} value
         * @param {?string} valueName
         * @returns {UplcStack}
         */
        push(value: UplcValue, valueName?: string | null): UplcStack;
        /**
         * Calls the print callback (or does nothing if print callback isn't defined)
         * @param {string | string[]} rawMsg
         * @returns {Promise<void>}
         */
        print(rawMsg: string | string[]): Promise<void>;
        /**
         * Calls the onStartCall callback.
         * @param {Site} site
         * @param {UplcRawStack} rawStack
         * @returns {Promise<void>}
         */
        startCall(site: Site, rawStack: UplcRawStack): Promise<void>;
        /**
         * Calls the onEndCall callback if '#notifyCalls == true'.
         * '#notifyCalls' is set to true if 'rawStack == #marker'.
         * @param {Site} site
         * @param {UplcRawStack} rawStack
         * @param {UplcValue} result
         * @returns {Promise<void>}
         */
        endCall(site: Site, rawStack: UplcRawStack, result: UplcValue): Promise<void>;
        /**
         * @returns {UplcRawStack}
         */
        toList(): UplcRawStack;
        #private;
    }
    /**
     * Allows doing a dummy eval of a UplcProgram in order to determine some non-changing properties (eg. the address fetched via the network in an EndpointProgram)
     * @internal
     */
    export class UplcAny extends UplcValue {
    }
    /**
     * @internal
     */
    export class UplcDelayedValue extends UplcValue {
        /**
         * @param {Site} site
         * @param {() => (UplcValue | Promise<UplcValue>)} evaluator
         */
        constructor(site: Site, evaluator: () => (UplcValue | Promise<UplcValue>));
        #private;
    }
    /**
     * Primitive equivalent of `IntData`.
     */
    export class UplcInt extends UplcValue {
        /**
         * Constructs a UplcInt without requiring a Site
         * @param {bigint | number} value
         * @returns {UplcInt}
         */
        static new(value: bigint | number): UplcInt;
        /**
         * Creates a UplcInt wrapped in a UplcConst, so it can be used a term
         * @param {Site} site
         * @param {bigint} value
         * @returns
         */
        static newSignedTerm(site: Site, value: bigint): UplcConst;
        /**
         * Parses a single byte in the Plutus-core byte-list representation of an int
         * @param {number} b
         * @returns {number}
         */
        static parseRawByte(b: number): number;
        /**
         * Returns true if 'b' is the last byte in the Plutus-core byte-list representation of an int.
         * @param {number} b
         * @returns {boolean}
         */
        static rawByteIsLast(b: number): boolean;
        /**
         * Combines a list of Plutus-core bytes into a bigint (leading bit of each byte is ignored).
         * Differs from bytesToBigInt in utils.js because only 7 bits are used from each byte.
         * @param {number[]} bytes
         * @returns {bigint}
         */
        static bytesToBigInt(bytes: number[]): bigint;
        /**
         * @param {Site} site
         * @param {bigint} value - supposed to be arbitrary precision
         * @param {boolean} signed - unsigned is only for internal use
         */
        constructor(site: Site, value: bigint, signed?: boolean);
        /**
         * @readonly
         * @type {bigint}
         */
        readonly value: bigint;
        /**
         * @readonly
         * @type {boolean}
         */
        readonly signed: boolean;
        /**
         * @param {Site} newSite
         * @returns {UplcInt}
         */
        copy(newSite: Site): UplcInt;
        /**
         * Applies zigzag encoding
         * @example
         * (new UplcInt(Site.dummy(), -1n, true)).toUnsigned().int == 1n
         * @example
         * (new UplcInt(Site.dummy(), -1n, true)).toUnsigned().toSigned().int == -1n
         * @example
         * (new UplcInt(Site.dummy(), -2n, true)).toUnsigned().toSigned().int == -2n
         * @example
         * (new UplcInt(Site.dummy(), -3n, true)).toUnsigned().toSigned().int == -3n
         * @example
         * (new UplcInt(Site.dummy(), -4n, true)).toUnsigned().toSigned().int == -4n
         * @returns {UplcInt}
         */
        toUnsigned(): UplcInt;
        /**
         * Unapplies zigzag encoding
         * @example
         * (new UplcInt(Site.dummy(), 1n, false)).toSigned().int == -1n
         * @returns {UplcInt}
        */
        toSigned(): UplcInt;
        /**
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlatInternal(bitWriter: BitWriter): void;
        /**
         * Encodes unsigned integer with plutus flat encoding.
         * Throws error if signed.
         * Used by encoding plutus core program version and debruijn indices.
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlatUnsigned(bitWriter: BitWriter): void;
    }
    /**
     * Primitive equivalent of `ByteArrayData`.
     */
    export class UplcByteArray extends UplcValue {
        /**
         * Construct a UplcByteArray without requiring a Site
         * @internal
         * @param {number[]} bytes
         * @returns {UplcByteArray}
         */
        static new(bytes: number[]): UplcByteArray;
        /**
         * Creates new UplcByteArray wrapped in UplcConst so it can be used as a term.
         * @internal
         * @param {Site} site
         * @param {number[]} bytes
         * @returns {UplcConst}
         */
        static newTerm(site: Site, bytes: number[]): UplcConst;
        /**
         * Write a list of bytes to the bitWriter using flat encoding.
         * Used by UplcString, UplcByteArray and UplcDataValue
         * Equivalent to E_B* function in Plutus-core docs
         * @internal
         * @param {BitWriter} bitWriter
         * @param {number[]} bytes
         * @param {boolean} pad
         */
        static writeBytes(bitWriter: BitWriter, bytes: number[], pad?: boolean): void;
        /**
         * @param {Site} site
         * @param {number[]} bytes
         */
        constructor(site: Site, bytes: number[]);
        /**
         * @internal
         * @param {Site} newSite
         * @returns {UplcByteArray}
         */
        copy(newSite: Site): UplcByteArray;
        #private;
    }
    /**
     * Primitive string value.
     */
    export class UplcString extends UplcValue {
        /**
         * Constructs a UplcStrin without requiring a Site
         * @param {string} value
         * @returns {UplcString}
         */
        static new(value: string): UplcString;
        /**
         * Creates a new UplcString wrapped with UplcConst so it can be used as a term.
         * @param {Site} site
         * @param {string} value
         * @returns {UplcConst}
         */
        static newTerm(site: Site, value: string): UplcConst;
        /**
         * @param {Site} site
         * @param {string} value
         */
        constructor(site: Site, value: string);
        /**
         * @param {Site} newSite
         * @returns {UplcString}
         */
        copy(newSite: Site): UplcString;
        #private;
    }
    /**
     * Primitive unit value.
     */
    export class UplcUnit extends UplcValue {
        /**
         * Constructs a UplcUnit without requiring a Site
         * @returns {UplcUnit}
         */
        static new(): UplcUnit;
        /**
         * Creates a new UplcUnit wrapped with UplcConst so it can be used as a term
         * @param {Site} site
         * @returns {UplcConst}
         */
        static newTerm(site: Site): UplcConst;
    }
    /**
     * JS/TS equivalent of the Helios language `Bool` type.
     */
    export class UplcBool extends UplcValue {
        /**
         * Constructs a UplcBool without requiring a Site
         * @param {boolean} value
         * @returns {UplcBool}
         */
        static new(value: boolean): UplcBool;
        /**
         * Creates a new UplcBool wrapped with UplcConst so it can be used as a term.
         * @param {Site} site
         * @param {boolean} value
         * @returns {UplcConst}
         */
        static newTerm(site: Site, value: boolean): UplcConst;
        /**
         * @param {Site} site
         * @param {boolean} value
         */
        constructor(site: Site, value: boolean);
        /**
         * @param {Site} newSite
         * @returns {UplcBool}
         */
        copy(newSite: Site): UplcBool;
        #private;
    }
    /**
     * Primitive pair value.
     */
    export class UplcPair extends UplcValue {
        /**
         * Constructs a UplcPair without requiring a Site
         * @param {UplcValue} first
         * @param {UplcValue} second
         * @returns {UplcPair}
         */
        static new(first: UplcValue, second: UplcValue): UplcPair;
        /**
         * Creates a new UplcBool wrapped with UplcConst so it can be used as a term.
         * @param {Site} site
         * @param {UplcValue} first
         * @param {UplcValue} second
         * @returns {UplcConst}
         */
        static newTerm(site: Site, first: UplcValue, second: UplcValue): UplcConst;
        /**
         * @param {Site} site
         * @param {UplcValue} first
         * @param {UplcValue} second
         */
        constructor(site: Site, first: UplcValue, second: UplcValue);
        /**
         * @param {Site} newSite
         * @returns {UplcPair}
         */
        copy(newSite: Site): UplcPair;
        /**
         * @type {UplcData}
         */
        get key(): UplcData;
        /**
         * @type {UplcData}
         */
        get value(): UplcData;
        #private;
    }
    /**
     * Plutus-core list value class.
     * Only used during evaluation.
    */
    export class UplcList extends UplcValue {
        /**
         * Constructs a UplcList without requiring a Site
         * @param {UplcType} type
         * @param {UplcValue[]} items
         */
        static new(type: UplcType, items: UplcValue[]): UplcList;
        /**
         * @param {Site} site
         * @param {UplcType} itemType
         * @param {UplcValue[]} items
         */
        constructor(site: Site, itemType: UplcType, items: UplcValue[]);
        /**
         * @param {Site} newSite
         * @returns {UplcList}
         */
        copy(newSite: Site): UplcList;
        /**
         * @returns {boolean}
         */
        isDataList(): boolean;
        /**
         * @returns {boolean}
         */
        isDataMap(): boolean;
        #private;
    }
    /**
     *  Child type of `UplcValue` that wraps a `UplcData` instance.
     */
    export class UplcDataValue extends UplcValue {
        /**
         * @param {UplcDataValue | UplcData} data
         * @returns {UplcData}
         */
        static unwrap(data: UplcDataValue | UplcData): UplcData;
        /**
         * @param {Site} site
         * @param {UplcData} data
         */
        constructor(site: Site, data: UplcData);
        /**
         * @param {Site} newSite
         * @returns {UplcDataValue}
         */
        copy(newSite: Site): UplcDataValue;
        #private;
    }
    /**
     * Base class of Plutus-core terms
     */
    export class UplcTerm {
        /**
         * @param {Site} site
         * @param {number} type
         */
        constructor(site: Site, type: number);
        /**
         * @type {number}
         */
        get type(): number;
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * Generic term toString method
         * @returns {string}
         */
        toString(): string;
        /**
         * Writes bits of flat encoded Plutus-core terms to bitWriter. Doesn't return anything.
         * @internal
         * @param {BitWriter} bitWriter
         * @param {null | Map<string, number>} codeMapFileIndices
         */
        toFlat(bitWriter: BitWriter, codeMapFileIndices?: null | Map<string, number>): void;
        #private;
    }
    /**
     * Plutus-core variable ref term (index is a Debruijn index)
     */
    export class UplcVariable extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcInt} index
         */
        constructor(site: Site, index: UplcInt);
        /**
         * @readonly
         * @type {UplcInt}
         */
        readonly index: UplcInt;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
    }
    /**
     * Plutus-core delay term.
     */
    export class UplcDelay extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcTerm} expr
         */
        constructor(site: Site, expr: UplcTerm);
        /**
         * @readonly
         * @type {UplcTerm}
         */
        readonly expr: UplcTerm;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
    }
    /**
     * Plutus-core lambda term
     */
    export class UplcLambda extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcTerm} expr
         * @param {null | string} argName
         */
        constructor(site: Site, expr: UplcTerm, argName?: null | string);
        /**
         * @readonly
         * @type {UplcTerm}
         */
        readonly expr: UplcTerm;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
        #private;
    }
    /**
     * Plutus-core function application term (i.e. function call)
     */
    export class UplcCall extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcTerm} fn
         * @param {UplcTerm} arg
         */
        constructor(site: Site, fn: UplcTerm, arg: UplcTerm);
        /**
         * @readonly
         * @type {UplcTerm}
         */
        readonly fn: UplcTerm;
        /**
         * @readonly
         * @type {UplcTerm}
         */
        readonly arg: UplcTerm;
        /**
         * @internal
         * @type {Site}
         */
        get callSite(): Site;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
    }
    /**
     * Plutus-core const term (i.e. a literal in conventional sense)
     */
    export class UplcConst extends UplcTerm {
        /**
         * @param {UplcValue} value
         */
        constructor(value: UplcValue);
        /**
         * @readonly
         * @type {UplcValue}
         */
        readonly value: UplcValue;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {PreCallFrame} frame
         * @returns {CekState}
         */
        reducePreCallFrame(rte: UplcRte, stack: UplcFrame[], frame: PreCallFrame): CekState;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ForceFrame} frame
         * @returns {CekState}
         */
        reduceForceFrame(rte: UplcRte, stack: UplcFrame[], frame: ForceFrame): CekState;
    }
    /**
     * Plutus-core force term
     */
    export class UplcForce extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcTerm} expr
         */
        constructor(site: Site, expr: UplcTerm);
        /**
         * @readonly
         */
        readonly expr: UplcTerm;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
    }
    /**
     * Plutus-core error term
     */
    export class UplcError extends UplcTerm {
        /**
         * @param {Site} site
         * @param {string} msg
         */
        constructor(site: Site, msg?: string);
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
        #private;
    }
    /**
     * Plutus-core builtin function ref term
     */
    export class UplcBuiltin extends UplcTerm {
        /**
         * Used by IREvaluator
         * @internal
         * @param {Word} name
         * @param {UplcValue[]} args
         * @returns {UplcValue}
         */
        static evalStatic(name: Word, args: UplcValue[]): UplcValue;
        /**
         * @param {Site} site
         * @param {string | number} name
         */
        constructor(site: Site, name: string | number);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {number}
         */
        get nArgs(): number;
        /**
         * @internal
         * @returns {boolean}
         */
        allowAny(): boolean;
        /**
         * @internal
         * @returns {boolean}
         */
        isMacro(): boolean;
        /**
         * @internal
         * @param {NetworkParams} params
         * @param  {...UplcValue} args
         * @returns {Cost}
         */
        calcCost(params: NetworkParams, ...args: UplcValue[]): Cost;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {Site} site
         * @param {UplcValue[]} args
         * @returns {Promise<UplcValue>}
         */
        evalMacro(rte: UplcRte, site: Site, args: UplcValue[]): Promise<UplcValue>;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {Site} site
         * @param {UplcValue[]} args
         * @param {boolean} syncTrace if true => don't call rte.print method (used by IREvaluator)
         * @returns {UplcValue | Promise<UplcValue>} // trace returns a Promise (async print), all the other builtins return a synchronous value
         */
        evalBuiltin(rte: UplcRte, site: Site, args: UplcValue[], syncTrace?: boolean): UplcValue | Promise<UplcValue>;
        /**
         * @internal
         * @type {number}
         */
        get forceCount(): number;
        #private;
    }
    /**
     * @internal
     */
    export class UplcFrame {
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ReducingState} state
         * @returns {Promise<CekState>}
         */
        reduceCek(rte: UplcRte, stack: UplcFrame[], state: ReducingState): Promise<CekState>;
        /**
         * @type {Site}
         */
        get site(): Site;
    }
    /**
     * @internal
     */
    export class ForceFrame extends UplcFrame {
        /**
         * @param {UplcForce} term
         * @param {CekEnv} env
         */
        constructor(term: UplcForce, env: CekEnv);
        /**
         * @readonly
         * @type {UplcForce}
         */
        readonly term: UplcForce;
        /**
         * @readonly
         * @type {CekEnv}
         */
        readonly env: CekEnv;
    }
    /**
     * @internal
     */
    export class PreCallFrame extends UplcFrame {
        /**
         * @param {UplcCall} term
         * @param {CekEnv} env
         */
        constructor(term: UplcCall, env: CekEnv);
        /**
         * @readonly
         * @type {UplcCall}
         */
        readonly term: UplcCall;
        /**
         * @readonly
         * @type {CekEnv}
         */
        readonly env: CekEnv;
    }
    /**
     * @internal
     */
    export class CallFrame extends UplcFrame {
        /**
         * @param {UplcCall} term
         * @param {UplcLambdaWithEnv | AppliedUplcBuiltin} fn
         * @param {CekEnv} env
         */
        constructor(term: UplcCall, fn: UplcLambdaWithEnv | AppliedUplcBuiltin, env: CekEnv);
        /**
         * @readonly
         * @type {UplcCall}
         */
        readonly term: UplcCall;
        /**
         * @readonly
         * @type {UplcLambdaWithEnv | AppliedUplcBuiltin}
         */
        readonly fn: UplcLambdaWithEnv | AppliedUplcBuiltin;
        /**
         * @readonly
         * @type {CekEnv}
         */
        readonly env: CekEnv;
    }
    /**
     * TODO: purpose as enum type
     * @typedef {{
     *   purpose: null | ScriptPurpose
     *   callsTxTimeRange: boolean
     *   name?: string
     * }} ProgramProperties
     */
    /**
     * The constructor returns 'any' because it is an instance of TransferableUplcProgram, and the instance methods don't need to be defined here
     * @template TInstance
     * @typedef {{
     *   transferUplcProgram: (expr: any, properties: ProgramProperties, version: any[]) => TInstance,
     *   transferUplcAst: TransferUplcAst
     * }} TransferableUplcProgram
     */
    /**
     * @typedef {{
    *   mem: bigint,
    *   cpu: bigint,
    *   size?: number,
    *   builtins?: {[name: string]: Cost},
    *   terms?: {[name: string]: Cost},
    *   result?: RuntimeError | UplcValue,
    *   messages?: string[]
    * }} Profile
    *
    *
    * mem:  in 8 byte words (i.e. 1 mem unit is 64 bits)
    * cpu:  in reference cpu microseconds
    * size: in bytes
    * builtins: breakdown per builtin
    * terms: breakdown per termtype
    * result: result of evaluation
    * messages: printed messages (can be helpful when debugging)
    */
    /**
     * Result of `program.compile()`. Contains the Untyped Plutus-Core AST, along with a code-mapping to the original source.
     */
    export class UplcProgram {
        /**
         * @internal
         * @param {number[] | string} bytes
         * @param {ProgramProperties} properties
         * @param {Source[]} files
         * @returns {UplcProgram}
         */
        static fromCborWithMapping(bytes: number[] | string, files: Source[], properties?: ProgramProperties): UplcProgram;
        /**
         * @param {number[] | string} bytes
         * @param {ProgramProperties} properties
         * @returns {UplcProgram}
         */
        static fromCbor(bytes: number[] | string, properties?: ProgramProperties): UplcProgram;
        /**
         * @param {number[]} bytes
         * @param {ProgramProperties} properties
         * @returns {UplcProgram}
         */
        static fromFlat(bytes: number[], properties?: ProgramProperties): UplcProgram;
        /**
         * @internal
         * @param {number[]} bytes
         * @param {ProgramProperties} properties
         * @param {Source[]} files
         * @returns {UplcProgram}
         */
        static fromFlatWithMapping(bytes: number[], files: Source[], properties?: ProgramProperties): UplcProgram;
        /**
         * Intended for transfer only
         * @param {any} expr
         * @param {ProgramProperties} properties
         * @param {any[]} version
         * @returns {UplcProgram}
         */
        static transferUplcProgram(expr: any, properties: ProgramProperties, version: any[]): UplcProgram;
        /**
         * @type {TransferUplcAst}
         */
        static get transferUplcAst(): TransferUplcAst;
        /**
         * @param {UplcTerm} expr
         * @param {ProgramProperties} properties
         * @param {UplcInt[]} version
         */
        constructor(expr: UplcTerm, properties?: ProgramProperties, version?: UplcInt[]);
        /**
         * @type {UplcTerm}
         */
        get expr(): UplcTerm;
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * Returns the IR source
         * @type {string}
         */
        get src(): string;
        /**
         * @type {ProgramProperties}
         */
        get properties(): ProgramProperties;
        /**
         * Transfers a `UplcProgram` from an old version of Helios to a new version of Helios, keeping the script hash the same.
         *
         * The main benefit for calling this method instead of serializing/deserializing is that the code mapping is maintained.
         * @template TInstance
         * @param {TransferableUplcProgram<TInstance>} other
         * @returns {TInstance}
         */
        transfer<TInstance>(other: TransferableUplcProgram<TInstance>): TInstance;
        /**
         * Returns version of Plutus-core (!== Plutus script version!)
         * @type {string}
         */
        get versionString(): string;
        /**
         * @returns {string}
         */
        plutusScriptVersion(): string;
        /**
         * Returns 1 for PlutusScriptV1, 2 for PlutusScriptV2
         * @returns {number}
         */
        versionTag(): number;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * Flat encodes the entire Plutus-core program.
         * Note that final padding isn't added now but is handled by bitWriter upon finalization.
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlat(bitWriter: BitWriter): void;
        /**
         * @internal
         * @param {BitWriter} bitWriter
         * @param {null | Map<string, number>} codeMapFileIndices
         */
        toFlatWithMapping(bitWriter: BitWriter, codeMapFileIndices: null | Map<string, number>): void;
        /**
         * Evaluates the term contained in UplcProgram (assuming it is a lambda term)
         * @internal
         * @param {null | UplcValue[]} args
         * @param {UplcRTECallbacksInternal} callbacks
         * @param {null | NetworkParams} networkParams
         * @returns {Promise<UplcValue>}
         */
        runInternal(args: null | UplcValue[], callbacks?: UplcRTECallbacksInternal, networkParams?: null | NetworkParams): Promise<UplcValue>;
        /**
         * Wrap the top-level term with consecutive UplcCall (not exported) terms.
         *
         * Returns a new UplcProgram instance, leaving the original untouched.
         *
         * Throws an error if you are trying to apply with an anon func.
         * @param {(UplcValue | HeliosData)[]} args
         * @returns {UplcProgram} - a new UplcProgram instance
         */
        apply(args: (UplcValue | HeliosData)[]): UplcProgram;
        /**
         * @param {null | UplcValue[]} args - if null the top-level term is returned as a value
         * @param {UplcRTECallbacks} callbacks
         * @param {null | NetworkParams} networkParams
         * @returns {Promise<UplcValue | RuntimeError>}
         */
        run(args: null | UplcValue[], callbacks?: UplcRTECallbacks, networkParams?: null | NetworkParams): Promise<UplcValue | RuntimeError>;
        /**
         * Run a `UplcProgram`. The printed messages are part of the return value.
         * @param {null | UplcValue[]} args
         * @returns {Promise<[(UplcValue | RuntimeError), string[]]>}
         */
        runWithPrint(args: null | UplcValue[]): Promise<[(UplcValue | RuntimeError), string[]]>;
        /**
         * Runs and profiles a `UplcProgram`. Needs the `NetworkParams` in order to calculate the execution budget.
         * @param {UplcValue[]} args
         * @param {NetworkParams} networkParams
         * @returns {Promise<Profile>} The returned profile contains a breakdown of the execution cost per Uplc term type and per Uplc builtin function type.
         */
        profile(args: UplcValue[], networkParams: NetworkParams): Promise<Profile>;
        /**
         * Returns flat bytes of serialized script
         * @returns {number[]}
         */
        serializeBytes(): number[];
        /**
         * Calculates the on chain size of the program (number of bytes).
         * @returns {number}
         */
        calcSize(): number;
        /**
         * Returns the Cbor encoding of a script (flat bytes wrapped twice in Cbor bytearray).
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @internal
         * @param {Map<string, number>} codeMapFileIndices
         */
        toCborWithMapping(codeMapFileIndices: Map<string, number>): number[];
        /**
         * Returns the JSON representation of the serialized program (needed by cardano-cli).
         * @returns {string}
         */
        serialize(): string;
        /**
         * @returns {number[]} - 28 byte hash
         */
        hash(): number[];
        /**
         * Returns the `ValidatorHash` of the script. Throws an error if this isn't a spending validator script.
         * @type {ValidatorHash}
         */
        get validatorHash(): ValidatorHash;
        /**
         * Returns the `MintingPolicyHash` of the script. Throws an error if this isn't a minting policy.
         * @type {MintingPolicyHash}
         */
        get mintingPolicyHash(): MintingPolicyHash;
        /**
         * Returns the `StakingValidatorHash` of the script. Throws an error if this isn't a staking validator script.
         * @type {StakingValidatorHash}
         */
        get stakingValidatorHash(): StakingValidatorHash;
        #private;
    }
    /**
     * @internal
     */
    export class Tokenizer {
        /**
         * @param {Site} site
         * @param {string[]} chars
         * @param {boolean} reverse
         * @returns {string[]}
         */
        static assertCorrectDecimalUnderscores(site: Site, chars: string[], reverse?: boolean): string[];
        /**
         * Separates tokens in fields (separted by commas)
         * @param {Token[]} ts
         * @returns {Group | null}
         */
        static buildGroup(ts: Token[]): Group | null;
        /**
         * @param {Source} src
         * @param {?CodeMap} codeMap
         * @param {boolean} irMode - if true '@' is treated as a regular character
         */
        constructor(src: Source, codeMap?: CodeMap | null, irMode?: boolean);
        incrPos(): void;
        decrPos(): void;
        get currentSite(): Site;
        /**
         * @param {Token} t
         */
        pushToken(t: Token): void;
        /**
         * Reads a single char from the source and advances #pos by one
         * @returns {string}
         */
        readChar(): string;
        /**
         * @returns {string}
         */
        peekChar(): string;
        /**
         * Decreases #pos by one
         */
        unreadChar(): void;
        /**
         * Start reading precisely one token
         * @param {Site} site
         * @param {string} c
         */
        readToken(site: Site, c: string): void;
        /**
         * Tokenize the complete source.
         * Nests groups before returning a list of tokens
         * @returns {Token[] | null}
         */
        tokenize(): Token[] | null;
        /**
         * Returns a generator
         * Use gen.next().value to access to the next Token
         * Doesn't perform any grouping
         * Used for quickly parsing the ScriptPurpose header of a script
         * @returns {Generator<Token>}
         */
        streamTokens(): Generator<Token>;
        /**
         * Reads one word token.
         * Immediately turns "true" or "false" into a BoolLiteral instead of keeping it as Word
         * @param {Site} site
         * @param {string} c0 - first character
         */
        readWord(site: Site, c0: string): void;
        /**
         * Reads and discards a comment if current '/' char is followed by '/' or '*'.
         * Otherwise pushes Symbol('/') onto #ts
         * @param {Site} site
         */
        readMaybeComment(site: Site): void;
        /**
         * Reads and discards a single line comment (from '//' to end-of-line)
         */
        readSingleLineComment(): void;
        /**
         * Reads and discards a multi-line comment (from '/' '*' to '*' '/')
         * @param {Site} site
         */
        readMultiLineComment(site: Site): void;
        /**
         * REads a literal integer
         * @param {Site} site
         */
        readSpecialInteger(site: Site): void;
        /**
         * @param {Site} site
         */
        readBinaryInteger(site: Site): void;
        /**
         * @param {Site} site
         */
        readOctalInteger(site: Site): void;
        /**
         * @param {Site} site
         */
        readHexInteger(site: Site): void;
        /**
         * @param {Site} site
         * @param {string} c0 - first character
         */
        readDecimal(site: Site, c0: string): void;
        /**
         * @param {Site} site
         * @param {string} prefix
         * @param {(c: string) => boolean} valid - checks if character is valid as part of the radix
         */
        readRadixInteger(site: Site, prefix: string, valid: (c: string) => boolean): void;
        /**
         * @param {Site} site
         * @param {string[]} leading
         */
        readFixedPoint(site: Site, leading: string[]): void;
        /**
         * Reads literal hexadecimal representation of ByteArray
         * @param {Site} site
         */
        readByteArray(site: Site): void;
        /**
         * Reads literal Utf8 string and immediately encodes it as a ByteArray
         * @param {Site} site
         */
        readMaybeUtf8ByteArray(site: Site): void;
        /**
         * Doesn't push a token, instead returning the string itself
         * @internal
         * @param {Site} site
         * @returns {string}
         */
        readStringInternal(site: Site): string;
        /**
         * Reads literal string delimited by double quotes.
         * Allows for three escape character: '\\', '\n' and '\t'
         * @param {Site} site
         */
        readString(site: Site): void;
        /**
         * Reads single or double character symbols
         * @param {Site} site
         * @param {string} c0 - first character
         */
        readSymbol(site: Site, c0: string): void;
        /**
         * Match group open with group close symbols in order to form groups.
         * This is recursively applied to nested groups.
         * @param {Token[]} ts
         * @returns {Token[] | null}
         */
        nestGroups(ts: Token[]): Token[] | null;
        #private;
    }
    /**
     * @internal
     */
    export class Common {
        /**
         * @param {Typed} i
         * @param {Type} t
         * @returns {boolean}
         */
        static instanceOf(i: Typed, t: Type): boolean;
        /**
         * @param {Type | Type[]} type
         * @returns {Typed | Multi}
         */
        static toTyped(type: Type | Type[]): Typed | Multi;
        /**
         * Compares two types. Throws an error if neither is a Type.
         * @example
         * Common.typesEq(IntType, IntType) == true
         * @param {Type} a
         * @param {Type} b
         * @returns {boolean}
         */
        static typesEq(a: Type, b: Type): boolean;
        /**
         * @param {Type} type
         */
        static isEnum(type: Type): boolean;
        /**
         * @param {Type} type
         */
        static countEnumMembers(type: Type): number;
        /**
         * @param {TypeClass} tc
         * @returns {string[]}
         */
        static typeClassMembers(tc: TypeClass): string[];
        /**
         * @param {Type} type
         * @param {TypeClass} tc
         * @returns {boolean}
         */
        static typeImplements(type: Type, tc: TypeClass): boolean;
        /**
         * @returns {boolean}
         */
        isParametric(): boolean;
        /**
         * @type {null | DataType}
         */
        get asDataType(): DataType | null;
        /**
         * @type {null | EnumMemberType}
         */
        get asEnumMemberType(): EnumMemberType | null;
        /**
         * @type {null | Func}
         */
        get asFunc(): Func | null;
        /**
         * @type {null | Instance}
         */
        get asInstance(): Instance | null;
        /**
         * @type {null | Multi}
         */
        get asMulti(): Multi | null;
        /**
         * @type {null | Named}
         */
        get asNamed(): Named | null;
        /**
         * @type {null | Namespace}
         */
        get asNamespace(): Namespace | null;
        /**
         * @type {null | Parametric}
         */
        get asParametric(): Parametric | null;
        /**
         * @type {null | Type}
         */
        get asType(): Type | null;
        /**
         * @type {null | Typed}
         */
        get asTyped(): Typed | null;
        /**
         * @type {null | TypeClass}
         */
        get asTypeClass(): TypeClass | null;
        /**
         * @type {boolean}
         */
        get ready(): boolean;
        /**
         * @param {any} obj
         * @param {JsToUplcHelpers} helpers
         * @returns {Promise<UplcData>}
         */
        jsToUplc(obj: any, helpers: JsToUplcHelpers): Promise<UplcData>;
        /**
         * @param {UplcData} data
         * @param {UplcToJsHelpers} helpers
         * @returns {Promise<any>}
         */
        uplcToJs(data: UplcData, helpers: UplcToJsHelpers): Promise<any>;
        /**
         * @returns {string}
         */
        toString(): string;
    }
    /**
     * Used to represent all possible types whenever a TypeExpr throws an error (so type evaluation can continue in order to collect all type errors at once)
     * @internal
     * @implements {DataType}
     */
    export class AllType extends Common implements DataType {
        /**
         * @type {DataType}
         */
        get asDataType(): DataType;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * @type {HeliosDataClass<HeliosData> | null}
         */
        get offChainType(): HeliosDataClass<HeliosData> | null;
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * @internal
     * @implements {DataType}
     */
    export class AnyType extends Common implements DataType {
        get fieldNames(): never[];
        get offChainType(): null;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {DataType}
         */
        get asDataType(): DataType;
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * Type of special case of no-return value where execution can't continue.
     * @internal
     * @implements {Type}
     */
    export class ErrorType extends Common implements Type {
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isBaseOf(type: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * @internal
     */
    export class ArgType {
        /**
         *
         * @param {null | Word} name
         * @param {Type} type
         * @param {boolean} optional
         */
        constructor(name: null | Word, type: Type, optional?: boolean);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * @internal
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {ArgType}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): ArgType;
        /**
         * @param {ArgType} other
         * @returns {boolean}
         */
        isBaseOf(other: ArgType): boolean;
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        /**
         * @returns {boolean}
         */
        isOptional(): boolean;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * Function type with arg types and a return type
     * @internal
     * @implements {Type}
     */
    export class FuncType extends Common implements Type {
        /**
         * @param {Type[] | ArgType[]} argTypes
         * @param {Type | Type[]} retTypes
         */
        constructor(argTypes: Type[] | ArgType[], retTypes: Type | Type[]);
        /**
         * @type {Type[]}
         */
        get argTypes(): Type[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {number}
         */
        get nArgs(): number;
        /**
         * @type {number}
         */
        get nNonOptArgs(): number;
        /**
         * @type {number}
         */
        get nOptArgs(): number;
        /**
         * @type {Type[]}
         */
        get retTypes(): Type[];
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * Checks if arg types are valid.
         * Throws errors if not valid. Returns the return type if valid.
         * @param {Site} site
         * @param {Typed[]} posArgs
         * @param {{[name: string]: Typed}} namedArgs
         * @returns {null | Type[]}
         */
        checkCall(site: Site, posArgs: Typed[], namedArgs?: {
            [name: string]: Typed;
        }): null | Type[];
        /**
         * @internal
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @internal
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {Type[]} argTypes
         * @returns {FuncType}
         */
        inferArgs(site: Site, map: InferenceMap, argTypes: Type[]): FuncType;
        /**
         * Checks if any of 'this' argTypes or retType is same as Type.
         * Only if this checks return true is the association allowed.
         * @param {Site} site
         * @param {Type} type
         * @returns {boolean}
         */
        isAssociated(site: Site, type: Type): boolean;
        /**
         * Checks if 'this' is a base type of another FuncType.
         * The number of args needs to be the same.
         * Each argType of the FuncType we are checking against needs to be the same or less specific (i.e. isBaseOf(this.#argTypes[i]))
         * The retType of 'this' needs to be the same or more specific
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * Checks if the type of the first arg is the same as 'type'
         * Also returns false if there are no args.
         * For a method to be a valid instance member its first argument must also be named 'self', but that is checked elsewhere
         * @param {Site} site
         * @param {Type} type
         * @returns {boolean}
         */
        isMaybeMethod(site: Site, type: Type): boolean;
        /**
         * Throws an error if name isn't found
         * @param {Site} site
         * @param {string} name
         * @returns {number}
         */
        getNamedIndex(site: Site, name: string): number;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
        #private;
    }
    /**
     * @internal
     * @template {HeliosData} T
     * @typedef {{
     *   name: string,
     *   path?: string,
     *   offChainType?: HeliosDataClass<T> | null,
     *   genOffChainType?: (() => HeliosDataClass<T>) | null
     *   fieldNames?: string[],
     *   genInstanceMembers: (self: Type) => InstanceMembers,
     *   genTypeMembers: (self: Type) => TypeMembers
     *   genTypeDetails?: (self: Type) => TypeDetails,
     *   jsToUplc?: JsToUplcConverter
     *   uplcToJs?: UplcToJsConverter
     * }} GenericTypeProps
     */
    /**
     * Created by statements
     * @internal
     * @template {HeliosData} T
     * @implements {DataType}
     */
    export class GenericType<T extends HeliosData> extends Common implements DataType {
        /**
         * @param {GenericTypeProps<T>} props
         */
        constructor({ name, path, offChainType, genOffChainType, fieldNames, genInstanceMembers, genTypeMembers, genTypeDetails, jsToUplc, uplcToJs }: GenericTypeProps<T>);
        /**
         * @type {DataType}
         */
        get asDataType(): DataType;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {null | HeliosDataClass<T>}
         */
        get offChainType(): HeliosDataClass<T> | null;
        /**
         * @type {TypeDetails}
         */
        get typeDetails(): TypeDetails;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         */
        applyInternal(site: Site, map: InferenceMap): {
            name: string;
            path: string;
            fieldNames: string[];
            genInstanceMembers: (self: any) => InstanceMembers;
            genTypeMembers: (self: any) => TypeMembers;
        };
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {string} name
         * @param {string} path
         * @returns {GenericType}
         */
        changeNameAndPath(name: string, path: string): GenericType<any>;
        /**
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
        #private;
    }
    /**
     * @internal
     * @template {HeliosData} T
     * @typedef {{
     *   name: string,
     *   path?: string,
     *   constrIndex: number,
     *   parentType: DataType,
     *   offChainType?: HeliosDataClass<T>,
     *   genOffChainType?: () => HeliosDataClass<T>,
     *   fieldNames?: string[],
     *   genInstanceMembers: (self: Type) => InstanceMembers,
     *   genTypeMembers?: (self: Type) => TypeMembers
     *   genTypeDetails?: (self: Type) => TypeDetails
     *   jsToUplc?: JsToUplcConverter
     *   uplcToJs?: UplcToJsConverter
     * }} GenericEnumMemberTypeProps
     */
    /**
     * Created by statements
     * @internal
     * @template {HeliosData} T
     * @implements {EnumMemberType}
     * @extends {GenericType<T>}
     */
    export class GenericEnumMemberType<T extends HeliosData> extends GenericType<T> implements EnumMemberType {
        /**
         * @param {GenericEnumMemberTypeProps<T>} props
         */
        constructor({ name, path, constrIndex, parentType, offChainType, genOffChainType, fieldNames, genInstanceMembers, genTypeMembers, genTypeDetails, jsToUplc, uplcToJs }: GenericEnumMemberTypeProps<T>);
        /**
         * @type {number}
         */
        get constrIndex(): number;
        /**
         * @type {DataType}
         */
        get parentType(): DataType;
        /**
         * @type {EnumMemberType}
         */
        get asEnumMemberType(): EnumMemberType;
        #private;
    }
    /**
     * Type of return-value of functions that don't return anything (eg. assert, print, error)
     * @internal
     * @implements {Type}
     */
    export class VoidType extends Common implements Type {
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         *
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isBaseOf(type: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * A regular non-Func Instance. DataValues can always be compared, serialized, used in containers.
     * @internal
     * @implements {Instance}
     */
    export class DataEntity extends Common implements Instance {
        /**
         * @param {DataType} type
         */
        constructor(type: DataType);
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * @type {Instance}
         */
        get asInstance(): Instance;
        /**
         * @type {Typed}
         */
        get asTyped(): Typed;
        #private;
    }
    /**
     * Returned by an error()
     * Special case of no-return-value that indicates that execution can't proceed.
     * @internal
     */
    export class ErrorEntity extends Common {
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * @type {Instance}
         */
        get asInstance(): Instance;
        /**
         * @type {Typed}
         */
        get asTyped(): Typed;
    }
    /**
     * @internal
     * @implements {Named}
     */
    export class NamedEntity implements Named {
        /**
         * @param {string} name
         * @param {string} path
         * @param {EvalEntity} entity
         */
        constructor(name: string, path: string, entity: EvalEntity);
        /**
         * @type {null | DataType}
         */
        get asDataType(): DataType | null;
        /**
         * @type {null | EnumMemberType}
         */
        get asEnumMemberType(): EnumMemberType | null;
        /**
         * @type {null | Func}
         */
        get asFunc(): Func | null;
        /**
         * @type {null | Instance}
         */
        get asInstance(): Instance | null;
        /**
         * @type {null | Multi}
         */
        get asMulti(): Multi | null;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {null | Namespace}
         */
        get asNamespace(): Namespace | null;
        /**
         * @type {null | Parametric}
         */
        get asParametric(): Parametric | null;
        /**
         * @type {null | Type}
         */
        get asType(): Type | null;
        /**
         * @type {null | Typed}
         */
        get asTyped(): Typed | null;
        /**
         * @type {null | TypeClass}
         */
        get asTypeClass(): TypeClass | null;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * A callable Instance.
     * @internal
     * @implements {Func}
     */
    export class FuncEntity extends Common implements Func {
        /**
         * @param {FuncType} type
         */
        constructor(type: FuncType);
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * Returns the underlying FuncType directly.
         * @type {FuncType}
         */
        get funcType(): FuncType;
        /**
         * @type {Func}
         */
        get asFunc(): Func;
        /**
         * @type {Typed}
         */
        get asTyped(): Typed;
        /**
         * @param {Site} site
         * @param {Typed[]} args
         * @param {{[name: string]: Typed}} namedArgs
         * @returns {null | Typed | Multi}
         */
        call(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }): null | Typed | Multi;
        #private;
    }
    /**
     * Wraps multiple return values
     * @internal
     * @implements {Multi}
     */
    export class MultiEntity extends Common implements Multi {
        /**
         * @param {(Typed | Multi)[]} vals
         * @returns {Typed[]}
         */
        static flatten(vals: (Typed | Multi)[]): Typed[];
        /**
         * @param {Typed[]} values
         */
        constructor(values: Typed[]);
        /**
         * @type {Typed[]}
         */
        get values(): Typed[];
        /**
         * @type {Multi}
         */
        get asMulti(): Multi;
        #private;
    }
    /**
     * @internal
     * @implements {Typed}
     */
    export class TypedEntity extends Common implements Typed {
        /**
         * @param {Type} type
         */
        constructor(type: Type);
        /**
         * @returns {Typed}
         */
        get asTyped(): Typed;
        /**
         * @type {Type}
         */
        get type(): Type;
        #private;
    }
    /**
     * Returned by functions that don't return anything (eg. assert, error, print)
     * @internal
     * @implements {Instance}
     */
    export class VoidEntity extends Common implements Instance {
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * @type {Instance}
         */
        get asInstance(): Instance;
        /**
         * @type {Typed}
         */
        get asTyped(): Typed;
    }
    /**
     * @internal
     * @implements {Namespace}
     */
    export class ModuleNamespace extends Common implements Namespace {
        /**
         * @param {NamespaceMembers} members
         */
        constructor(members: NamespaceMembers);
        /**
         * @type {NamespaceMembers}
         */
        get namespaceMembers(): NamespaceMembers;
        /**
         * @type {Namespace}
         */
        get asNamespace(): Namespace;
        #private;
    }
    /**
     * Builtin bool type
     * @internal
     * @type {DataType}
     */
    export const BoolType: DataType;
    /**
     * Builtin bytearray type
     * @internal
     * @type {DataType}
     */
    export const ByteArrayType: DataType;
    /**
     * @internal
     * @type {DataType}
     */
    export const IntType: DataType;
    /**
     * Type of external data that must be cast/type-checked before using
     * Not named 'Data' in Js because it's too generic
     * @internal
     * @type {DataType}
     */
    export const RawDataType: DataType;
    /**
     * Builtin Real fixed point number type
     * @internal
     * @type {DataType}
     */
    export const RealType: DataType;
    /**
     * Builtin string type
     * @internal
     * @type {DataType}
     */
    export const StringType: DataType;
    /**
     * Created by statements
     * @internal
     * @template {HeliosData} T
     * @implements {DataType}
     */
    export class GenericParametricType<T extends HeliosData> extends GenericType<any> implements DataType {
    }
    /**
     * Created by statements
     * @internal
     * @template {HeliosData} T
     * @implements {EnumMemberType}
     * @extends {GenericEnumMemberType<T>}
     */
    export class GenericParametricEnumMemberType<T extends HeliosData> extends GenericEnumMemberType<T> implements EnumMemberType {
    }
    /**
     * @internal
     * @implements {Type}
     */
    export class TypeClassImpl extends Common implements Type {
        /**
         * @param {TypeClass} typeClass
         * @param {string} name
         * @param {null | ParameterI} parameter - reference to original parameter, which is more unique than name
         */
        constructor(typeClass: TypeClass, name: string, parameter: null | ParameterI);
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * @internal
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * Returns 'true' if 'this' is a base-type of 'type'. Throws an error if 'this' isn't a Type.
         * @param {Type} type
         * @returns {boolean}
         */
        isBaseOf(type: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
        #private;
    }
    /**
     * @internal
     * @implements {DataType}
     */
    export class DataTypeClassImpl extends TypeClassImpl implements DataType {
        /**
         * @param {TypeClass} typeClass
         * @param {string} name
         * @param {string} path
         * @param {null | ParameterI} parameter
         */
        constructor(typeClass: TypeClass, name: string, path: string, parameter: null | ParameterI);
        /**
         * @type {DataType}
         */
        get asDataType(): DataType;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {null | HeliosDataClass<HeliosData>}
         */
        get offChainType(): HeliosDataClass<HeliosData> | null;
        /**
         * @type {string}
         */
        get path(): string;
        #private;
    }
    /**
     * @internal
     * @implements {TypeClass}
     */
    export class AnyTypeClass extends Common implements TypeClass {
        /**
         * @type {TypeClass}
         */
        get asTypeClass(): TypeClass;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genInstanceMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genTypeMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isImplementedBy(type: Type): boolean;
        /**
         * @param {string} name
         * @param {string} path
         * @param {null | ParameterI} parameter
         * @returns {Type}
         */
        toType(name: string, path: string, parameter?: null | ParameterI): Type;
    }
    /**
     * @internal
     * @implements {TypeClass}
     */
    export class DefaultTypeClass extends Common implements TypeClass {
        /**
         * @type {TypeClass}
         */
        get asTypeClass(): TypeClass;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genTypeMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genInstanceMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isImplementedBy(type: Type): boolean;
        /**
         * @param {string} name
         * @param {string} path
         * @param {null | ParameterI} parameter
         * @returns {DataType}
         */
        toType(name: string, path: string, parameter?: null | ParameterI): DataType;
    }
    /**
     * @internal
     * @implements {TypeClass}
     */
    export class SummableTypeClass extends Common implements TypeClass {
        /**
         * @type {TypeClass}
         */
        get asTypeClass(): TypeClass;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genTypeMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genInstanceMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isImplementedBy(type: Type): boolean;
        /**
         * @param {string} name
         * @param {string} path
         * @param {null | ParameterI} parameter
         * @returns {DataType}
         */
        toType(name: string, path: string, parameter?: null | ParameterI): DataType;
    }
    /**
     * @internal
     * @implements {ParameterI}
     */
    export class Parameter implements ParameterI {
        /**
         * @param {string} name - typically "a" or "b"
         * @param {string} path - typicall "__T0" or "__F0"
         * @param {TypeClass} typeClass
         */
        constructor(name: string, path: string, typeClass: TypeClass);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {Type}
         */
        get ref(): Type;
        /**
         * A null TypeClass matches any type
         * @type {TypeClass}
         */
        get typeClass(): TypeClass;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * Only func instances can be parametrics instances,
     *  there are no other kinds of parametric instances
     * @internal
     * @implements {Parametric}
     */
    export class ParametricFunc extends Common implements Parametric {
        /**
         * @param {Parameter[]} params
         * @param {FuncType} fnType
         */
        constructor(params: Parameter[], fnType: FuncType);
        /**
         * @type {null | ((...any) => HeliosDataClass<HeliosData>)}
         */
        get offChainType(): ((...any: any[]) => HeliosDataClass<HeliosData>) | null;
        get params(): Parameter[];
        get fnType(): FuncType;
        /**
         * null TypeClasses aren't included
         * @type {TypeClass[]}
         */
        get typeClasses(): TypeClass[];
        /**
         * @param {Type[]} types
         * @param {Site} site
         * @returns {EvalEntity}
         */
        apply(types: Type[], site?: Site): EvalEntity;
        /**
         * @type {Parametric}
         */
        get asParametric(): Parametric;
        /**
         * Must infer before calling
         * @param {Site} site
         * @param {Typed[]} args
         * @param {{[name: string]: Typed}} namedArgs
         * @param {Type[]} paramTypes - so that paramTypes can be accessed by caller
         * @returns {Func}
         */
        inferCall(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }, paramTypes?: Type[]): Func;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @returns {Parametric}
         */
        infer(site: Site, map: InferenceMap): Parametric;
        #private;
    }
    /**
     * @internal
     * @implements {Parametric}
     */
    export class ParametricType extends Common implements Parametric {
        /**
         * @param {{
         * 	 name: string,
         *   offChainType?: ((...any) => HeliosDataClass<HeliosData>)
         *   parameters: Parameter[]
         *   apply: (types: Type[]) => DataType
         * }} props
         */
        constructor({ name, offChainType, parameters, apply }: {
            name: string;
            offChainType?: ((...any: any[]) => HeliosDataClass<HeliosData>) | undefined;
            parameters: Parameter[];
            apply: (types: Type[]) => DataType;
        });
        /**
         * @type {Parametric}
         */
        get asParametric(): Parametric;
        /**
         * @type {null | ((...any) => HeliosDataClass<HeliosData>)}
         */
        get offChainType(): ((...any: any[]) => HeliosDataClass<HeliosData>) | null;
        /**
         * @type {TypeClass[]}
         */
        get typeClasses(): TypeClass[];
        /**
         * @param {Type[]} types
         * @param {Site} site
         * @returns {EvalEntity}
         */
        apply(types: Type[], site?: Site): EvalEntity;
        /**
        * Must infer before calling
        * @param {Site} site
        * @param {Typed[]} args
        * @param {{[name: string]: Typed}} namedArgs
        * @param {Type[]} paramTypes - so that paramTypes can be accessed by caller
        * @returns {Func}
        */
        inferCall(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }, paramTypes?: Type[]): Func;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @returns {Parametric}
         */
        infer(site: Site, map: InferenceMap): Parametric;
        #private;
    }
    /**
     * Used by print, error, and assert
     * @internal
     * @implements {Func}
     * @implements {Named}
     */
    export class BuiltinFunc extends Common implements Func, Named {
        /**
         *
         * @param {{
         *   name: string,
         *   type: FuncType
         * }} props
         */
        constructor({ name, type }: {
            name: string;
            type: FuncType;
        });
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * @type {FuncType}
         */
        get funcType(): FuncType;
        /**
         * @type {Func}
         */
        get asFunc(): Func;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {Typed}
         */
        get asTyped(): Typed;
        /**
         * @param {Site} site
         * @param {Typed[]} args
         * @param {{[name: string]: Typed}} namedArgs
         * @returns {null | Typed | Multi}
         */
        call(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }): null | Typed | Multi;
        #private;
    }
    /**
     * Special builtin function that throws an error if condition is false and returns Void
     * @internal
     */
    export const AssertFunc: BuiltinFunc;
    /**
     * Special builtin function that throws an error and returns ErrorInstance (special case of Void)
     * @internal
     */
    export const ErrorFunc: BuiltinFunc;
    /**
     * Special builtin function that prints a message and returns void
     * @internal
     */
    export const PrintFunc: BuiltinFunc;
    /**
     * Builtin list type
     * @internal
     * @type {Parametric}
     */
    export const ListType: Parametric;
    /**
     * Builtin map type (in reality list of key-value pairs)
     * @internal
     * @type {Parametric}
     */
    export const MapType: Parametric;
    /**
     * Builtin option type
     * @internal
     * @type {Parametric}
     */
    export const OptionType: Parametric;
    /**
     * Builtin Duration type
     * @internal
     * @type {DataType}
     */
    export const DurationType: DataType;
    /**
     * Builtin Time type. Opaque alias of Int representing milliseconds since 1970
     * @internal
     * @type {DataType}
     */
    export const TimeType: DataType;
    /**
     * Builtin TimeRange type
     * @internal
     * @type {DataType}
     */
    export const TimeRangeType: DataType;
    /**
     * @internal
     * @implements {DataType}
     */
    export class ScriptHashType extends GenericType<any> implements DataType {
        /**
         *
         * @param {null | string } name
         * @param {null | HeliosDataClass<HeliosData>} offChainType
         */
        constructor(name?: null | string, offChainType?: null | HeliosDataClass<HeliosData>);
    }
    /**
     * @internal
     * @type {DataType}
     */
    export const scriptHashType: DataType;
    /**
     * @internal
     * @type {DataType}
     */
    export const DatumHashType: DataType;
    /**
     * @internal
     * @type {ScriptHashType}
     */
    export const MintingPolicyHashType: ScriptHashType;
    /**
     * Builtin PubKey type
     * @internal
     * @type {DataType}
     */
    export const PubKeyType: DataType;
    /**
     * Builtin PubKeyHash type
     * @internal
     * @type {DataType}
     */
    export const PubKeyHashType: DataType;
    /**
     * Builtin StakingHash type
     * @internal
     * @type {DataType}
     */
    export const StakingHashType: DataType;
    /**
     * @internal
     * @type {EnumMemberType}
     */
    export const StakingHashStakeKeyType: EnumMemberType;
    /**
     * @internal
     * @type {EnumMemberType}
     */
    export const StakingHashValidatorType: EnumMemberType;
    /**
     * @internal
     * @type {ScriptHashType}
     */
    export const StakingValidatorHashType: ScriptHashType;
    /**
     * @internal
     * @type {ScriptHashType}
     */
    export const ValidatorHashType: ScriptHashType;
    /**
     * Builtin AssetClass type
     * @internal
     * @type {DataType}
     */
    export const AssetClassType: DataType;
    /**
     * Builtin money Value type
     * @internal
     * @type {DataType}
     */
    export const ValueType: DataType;
    /**
     * @internal
     * @implements {TypeClass}
     */
    export class ValuableTypeClass extends DefaultTypeClass implements TypeClass {
    }
    /**
     * Buitin Address type
     * @internal
     * @type {DataType}
     */
    export const AddressType: DataType;
    /**
     * @internal
     * @type {DataType}
     */
    export const DCertType: DataType;
    /**
     * Builtin Credential type
     * @internal
     * @type {DataType}
     */
    export const CredentialType: DataType;
    /**
     * @internal
     * @type {DataType}
     */
    export const OutputDatumType: DataType;
    /**
     * Base class for ScriptContext, ContractContext, Scripts and other "macro"-types
     * @internal
     */
    export class MacroType extends Common {
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {null | HeliosDataClass<HeliosData>}
         */
        get offChainType(): HeliosDataClass<HeliosData> | null;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @type {DataType}
         */
        get asDataType(): DataType;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * @internal
     * @typedef {{[name: string]: ScriptHashType}} ScriptTypes
     */
    /**
     * @internal
     * @implements {DataType}
     */
    export class ScriptsType extends MacroType implements DataType {
        /**
         * @param {ScriptTypes} scripts
         */
        constructor(scripts: ScriptTypes);
        /**
         * @returns {boolean}
         */
        isEmpty(): boolean;
        #private;
    }
    /**
     * Builtin ScriptContext type
     * @internal
     * @implements {DataType}
     */
    export class ScriptContextType extends MacroType implements DataType {
    }
    /**
     * Builtin ScriptContext type
     * @internal
     * @implements {DataType}
     */
    export class ContractContextType extends MacroType implements DataType {
    }
    /**
     * @internal
     */
    export const WalletType: GenericType<HeliosData>;
    /**
     * Does this really need to be a class? (i.e. will it be instantiated with some properties)
     * @internal
     */
    export const NetworkType: GenericType<HeliosData>;
    /**
     * Builtin ScriptPurpose type (Minting| Spending| Rewarding | Certifying)
     * @internal
     * @type {DataType}
     */
    export const ScriptPurposeType: DataType;
    /**
     * Builtin StakingCredential type
     * @internal
     * @type {DataType}
     */
    export const StakingCredentialType: DataType;
    /**
     * Builtin StakingPurpose type (Rewarding or Certifying)
     * @internal
     * @type {DataType}
     */
    export const StakingPurposeType: DataType;
    /**
     * @internal
     */
    export const TxBuilderType: GenericType<HeliosData>;
    /**
     * Builtin Tx type
     * @internal
     * @type {DataType}
     */
    export const TxType: DataType;
    /**
     * Builtin TxId type
     * @internal
     * @type {DataType}
     */
    export const TxIdType: DataType;
    /**
     * Builtin TxInput type
     * @internal
     * @type {DataType}
     */
    export const TxInputType: DataType;
    /**
     * Builtin TxOutput type
     * @internal
     * @type {DataType}
     */
    export const TxOutputType: DataType;
    /**
     * Builtin TxOutputId type
     * @internal
     * @type {DataType}
     */
    export const TxOutputIdType: DataType;
    /**
     * @internal
     * @type {{[name: string]: DataType}}
     */
    export const builtinTypes: {
        [name: string]: DataType;
    };
    /**
     * GlobalScope sits above the top-level scope and contains references to all the builtin Values and Types
     * @internal
     */
    export class GlobalScope {
        /**
         * Initialize the GlobalScope with all the builtins
         * @param {ScriptTypes} scriptTypes - types of all the scripts in a contract/ensemble
         * @returns {GlobalScope}
         */
        static new(scriptTypes?: ScriptTypes): GlobalScope;
        /**
         * Checks if scope contains a name
         * @param {Word} name
         * @returns {boolean}
         */
        has(name: Word): boolean;
        /**
         * Sets a global name, doesn't check for uniqueness
         * Called when initializing GlobalScope
         * @param {string | Word} name
         * @param {EvalEntity} value
         */
        set(name: string | Word, value: EvalEntity): void;
        /**
         * Gets a named value from the scope.
         * Throws an error if not found.
         * @param {Word} name
         * @returns {null | EvalEntity}
         */
        get(name: Word): null | EvalEntity;
        /**
         * @returns {boolean}
         */
        isStrict(): boolean;
        /**
         * @param {(name: string, type: Type) => void} callback
         */
        loopTypes(callback: (name: string, type: Type) => void): void;
        #private;
    }
    /**
     * User scope
     * @internal
     * @implements {EvalEntity}
     */
    export class Scope extends Common implements EvalEntity {
        /**
         * @param {GlobalScope | Scope} parent
         * @param {boolean} allowShadowing
         */
        constructor(parent: GlobalScope | Scope, allowShadowing?: boolean);
        /**
         * @type {boolean}
         */
        get allowShadowing(): boolean;
        /**
         * Used by top-scope to loop over all the statements
         */
        get values(): [Word, EvalEntity | Scope, boolean][];
        /**
         * Checks if scope contains a name
         * @param {Word} name
         * @returns {boolean}
         */
        has(name: Word): boolean;
        /**
         * Sets a named value. Throws an error if not unique
         * @param {Word} name
         * @param {EvalEntity | Scope} value
         */
        setInternal(name: Word, value: EvalEntity | Scope, allowShadowing?: boolean): void;
        /**
         * Sets a named value. Throws an error if not unique
         * @param {Word} name
         * @param {EvalEntity | Scope} value
         */
        set(name: Word, value: EvalEntity | Scope): void;
        /**
         * @param {Word} name
         */
        remove(name: Word): void;
        /**
         * @param {Word} name
         * @returns {null | Scope}
         */
        getScope(name: Word): null | Scope;
        /**
         * Gets a named value from the scope. Throws an error if not found
         * @param {Word} name
         * @param {boolean} dryRun - if false -> don't set used flag
         * @returns {null | EvalEntity | Scope}
         */
        get(name: Word, dryRun?: boolean): null | EvalEntity | Scope;
        /**
         * @returns {boolean}
         */
        isStrict(): boolean;
        /**
         * Asserts that all named values are user.
         * Throws an error if some are unused.
         * Check is only run if we are in strict mode
         * @param {boolean} onlyIfStrict
         */
        assertAllUsed(onlyIfStrict?: boolean): void;
        /**
         * @param {Word} name
         * @returns {boolean}
         */
        isUsed(name: Word): boolean;
        dump(): void;
        /**
         * @param {(name: string, type: Type) => void} callback
         */
        loopTypes(callback: (name: string, type: Type) => void): void;
        #private;
    }
    /**
     * TopScope is a special scope that can contain UserTypes
     * @internal
     */
    export class TopScope extends Scope {
        /**
         * @param {GlobalScope} parent
         * @param {boolean} strict
         */
        constructor(parent: GlobalScope, strict?: boolean);
        /**
         * Prepends "__scope__" to name before actually setting scope
         * @param {Word} name
         * @param {Scope} value
         */
        setScope(name: Word, value: Scope): void;
        /**
         * @param {boolean} s
         */
        setStrict(s: boolean): void;
        /**
         * @param {Word} name
         * @returns {ModuleScope}
         */
        getModuleScope(name: Word): ModuleScope;
        #private;
    }
    /**
     * @internal
     */
    export class ModuleScope extends Scope {
    }
    /**
     * @internal
     */
    export class ToIRContext {
        /**
         * @param {boolean} simplify
         * @param {string} indent
         * @param {Map<string, RawFunc>} db
         */
        constructor(simplify: boolean, indent?: string, db?: Map<string, RawFunc>);
        /**
         * @readonly
         * @type {boolean}
         */
        readonly simplify: boolean;
        /**
         * @readonly
         * @type {string}
         */
        readonly indent: string;
        /**
         * @returns {ToIRContext}
         */
        tab(): ToIRContext;
        /**
         * @type {Map<string, RawFunc>}
         */
        get db(): Map<string, RawFunc>;
        #private;
    }
    /**
     * Base class of every Type and Instance expression.
     * @internal
     */
    export class Expr extends Token {
        /**
         * Used in switch cases where initial typeExpr is used as memberName instead
         * @param {null | EvalEntity} c
         */
        set cache(arg: EvalEntity | null);
        /**
         * @type {null | EvalEntity}
         */
        get cache(): EvalEntity | null;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: Scope): null | EvalEntity;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        eval(scope: Scope): null | EvalEntity;
        /**
         * @param {Scope} scope
         * @returns {null | DataType}
         */
        evalAsDataType(scope: Scope): null | DataType;
        /**
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalAsType(scope: Scope): null | Type;
        /**
         * @param {Scope} scope
         * @returns {null | Typed}
         */
        evalAsTyped(scope: Scope): null | Typed;
        /**
         * @param {Scope} scope
         * @returns {null | Typed | Multi}
         */
        evalAsTypedOrMulti(scope: Scope): null | Typed | Multi;
        /**
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIR(ctx: ToIRContext): IR;
        #private;
    }
    /**
     * Simple reference class (i.e. using a Word)
     * @internal
     */
    export class RefExpr extends Expr {
        /**
         * @param {Word} name
         */
        constructor(name: Word);
        #private;
    }
    /**
     * Name::Member expression
     * @internal
     */
    export class PathExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} baseExpr
         * @param {Word} memberName
         */
        constructor(site: Site, baseExpr: Expr, memberName: Word);
        /**
         * @type {Expr}
         */
        get baseExpr(): Expr;
        #private;
    }
    /**
     * Name::Member expression which can instantiate zero field structs and enum members
     * @internal
     */
    export class ValuePathExpr extends PathExpr {
    }
    /**
     * []ItemType
     * @internal
     */
    export class ListTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} itemTypeExpr
         */
        constructor(site: Site, itemTypeExpr: Expr);
        /**
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalInternal(scope: Scope): null | Type;
        #private;
    }
    /**
     * Map[KeyType]ValueType expression
     * @internal
     */
    export class MapTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} keyTypeExpr
         * @param {Expr} valueTypeExpr
         */
        constructor(site: Site, keyTypeExpr: Expr, valueTypeExpr: Expr);
        #private;
    }
    /**
     * Iterator[Type1, ...] expr
     * @internal
     */
    export class IteratorTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr[]} itemTypeExprs
         */
        constructor(site: Site, itemTypeExprs: Expr[]);
        #private;
    }
    /**
     * Option[SomeType] expression
     * @internal
     */
    export class OptionTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} someTypeExpr
         */
        constructor(site: Site, someTypeExpr: Expr);
        /**
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalInternal(scope: Scope): null | Type;
        #private;
    }
    /**
     * '()' which can only be used as return type of func
     * @internal
     */
    export class VoidTypeExpr extends Expr {
        /**
         * @param {Scope} scope
         * @returns {EvalEntity}
         */
        evalInternal(scope: Scope): EvalEntity;
    }
    /**
     * @internal
     */
    export class FuncArgTypeExpr extends Token {
        /**
         * @param {Site} site
         * @param {null | Word} name
         * @param {Expr} typeExpr
         * @param {boolean} optional
         */
        constructor(site: Site, name: null | Word, typeExpr: Expr, optional: boolean);
        optional: boolean;
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        /**
         * @returns {boolean}
         */
        isOptional(): boolean;
        /**
         * @param {Scope} scope
         * @returns {null | ArgType}
         */
        eval(scope: Scope): null | ArgType;
        #private;
    }
    /**
     * (ArgType1, ...) -> RetType expression
     * @internal
     */
    export class FuncTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {FuncArgTypeExpr[]} argTypeExprs
         * @param {Expr[]} retTypeExprs
         */
        constructor(site: Site, argTypeExprs: FuncArgTypeExpr[], retTypeExprs: Expr[]);
        /**
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalInternal(scope: Scope): null | Type;
        #private;
    }
    /**
     * expr(...); ...
     * @internal
     */
    export class ChainExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} upstreamExpr
         * @param {Expr} downstreamExpr
         */
        constructor(site: Site, upstreamExpr: Expr, downstreamExpr: Expr);
        /**
         * @readonly
         * @type {Expr}
         */
        readonly upstreamExpr: Expr;
        /**
         * @readonly
         * @type {Expr}
         */
        readonly downstreamExpr: Expr;
    }
    /**
     * '... = ... ; ...' expression
     * @internal
     */
    export class AssignExpr extends ChainExpr {
        /**
         * @param {Site} site
         * @param {DestructExpr[]} nameTypes
         * @param {Expr} upstreamExpr
         * @param {Expr} downstreamExpr
         */
        constructor(site: Site, nameTypes: DestructExpr[], upstreamExpr: Expr, downstreamExpr: Expr);
        #private;
    }
    /**
     * Helios equivalent of unit
     * @internal
     */
    export class VoidExpr extends Expr {
        /**
         * @param {Scope} scope
         * @returns {Instance}
         */
        evalInternal(scope: Scope): Instance;
    }
    /**
     * Literal expression class (wraps literal tokens)
     * @internal
     */
    export class PrimitiveLiteralExpr extends Expr {
        /**
         * @param {PrimitiveLiteral} primitive
         */
        constructor(primitive: PrimitiveLiteral);
        /**
         * @type {DataType}
         */
        get type(): DataType;
        /**
         * @param {Scope} scope
         * @returns {EvalEntity}
         */
        evalInternal(scope: Scope): EvalEntity;
        #private;
    }
    /**
     * Literal UplcData which is the result of parameter substitutions.
     * @internal
     */
    export class LiteralDataExpr extends Expr {
        /**
         * @param {Site} site
         * @param {DataType} type
         * @param {UplcData} data
         */
        constructor(site: Site, type: DataType, data: UplcData);
        /**
         * @internal
         * @type {DataType}
         */
        get type(): DataType;
        /**
         * @param {Scope} scope
         * @returns {EvalEntity}
         */
        evalInternal(scope: Scope): EvalEntity;
        /**
         * @type {EvalEntity}
         */
        get cache(): EvalEntity;
        #private;
    }
    /**
     * Struct field (part of a literal struct constructor)
     * @internal
     */
    export class StructLiteralField {
        /**
         * @param {null | Word} name
         * @param {Expr} value
         */
        constructor(name: null | Word, value: Expr);
        /**
         * @type {Word}
         */
        get name(): Word;
        get site(): Site;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        eval(scope: Scope): null | EvalEntity;
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        /**
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIR(ctx: ToIRContext): IR;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * Struct literal constructor
     * @internal
     */
    export class StructLiteralExpr extends Expr {
        /**
         * @param {ToIRContext} ctx
         * @param {Site} site
         * @param {string} path
         * @param {IR[]} fields
         */
        static toIRInternal(ctx: ToIRContext, site: Site, path: string, fields: IR[]): IR;
        /**
         * @param {Expr} typeExpr
         * @param {StructLiteralField[]} fields
         */
        constructor(typeExpr: Expr, fields: StructLiteralField[]);
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        #private;
    }
    /**
     * []{...} expression
     * @internal
     */
    export class ListLiteralExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} itemTypeExpr
         * @param {Expr[]} itemExprs
         */
        constructor(site: Site, itemTypeExpr: Expr, itemExprs: Expr[]);
        /**
         * @type {DataType}
         */
        get itemType(): DataType;
        #private;
    }
    /**
     * Map[...]...{... : ...} expression
     * @internal
     */
    export class MapLiteralExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} keyTypeExpr
         * @param {Expr} valueTypeExpr
         * @param {[Expr, Expr][]} pairExprs
         */
        constructor(site: Site, keyTypeExpr: Expr, valueTypeExpr: Expr, pairExprs: [Expr, Expr][]);
        /**
         * @type {DataType}
         */
        get keyType(): DataType;
        /**
         * @type {DataType}
         */
        get valueType(): DataType;
        #private;
    }
    /**
     * NameTypePair is base class of FuncArg and DataField (differs from StructLiteralField)
     * @internal
     */
    export class NameTypePair {
        /**
         * @param {Word} name
         * @param {null | Expr} typeExpr
         */
        constructor(name: Word, typeExpr: null | Expr);
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * Throws an error if called before evalType()
         * @type {Type}
         */
        get type(): Type;
        /**
         * @type {null | Expr}
         */
        get typeExpr(): Expr | null;
        /**
         * @type {string}
         */
        get typeName(): string;
        /**
         * @returns {boolean}
         */
        isIgnored(): boolean;
        /**
         * @returns {boolean}
         */
        hasType(): boolean;
        /**
         * Evaluates the type, used by FuncLiteralExpr and DataDefinition
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalType(scope: Scope): null | Type;
        /**
         * @returns {IR}
         */
        toIR(): IR;
        /**
         *
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * Function argument class
     * @internal
     */
    export class FuncArg extends NameTypePair {
        /**
         * @param {IR} bodyIR
         * @param {string} name
         * @param {IR} defaultIR
         * @returns {IR}
         */
        static wrapWithDefaultInternal(bodyIR: IR, name: string, defaultIR: IR): IR;
        /**
         * @param {Word} name
         * @param {null | Expr} typeExpr
         * @param {null | Expr} defaultValueExpr
         */
        constructor(name: Word, typeExpr: null | Expr, defaultValueExpr?: null | Expr);
        /**
         * @param {Scope} scope
         */
        evalDefault(scope: Scope): void;
        /**
         * @param {Scope} scope
         * @returns {null | ArgType}
         */
        evalArgType(scope: Scope): null | ArgType;
        /**
         * (argName) -> {
         *   <bodyIR>
         * }(
         *   ifThenElse(
         * 		__useoptarg__argName,
         *  	() -> {
         *        argName
         *      },
         *      () -> {
         *        <defaultValueExpr>
         *      }
         *   )()
         * )
         * TODO: indentation
         * @param {ToIRContext} ctx
         * @param {IR} bodyIR
         * @returns {IR}
         */
        wrapWithDefault(ctx: ToIRContext, bodyIR: IR): IR;
        #private;
    }
    /**
     * (..) -> RetTypeExpr {...} expression
     * @internal
     */
    export class FuncLiteralExpr extends Expr {
        /**
         * @param {Site} site
         * @param {FuncArg[]} args
         * @param {(null | Expr)[]} retTypeExprs
         * @param {Expr} bodyExpr
         */
        constructor(site: Site, args: FuncArg[], retTypeExprs: (null | Expr)[], bodyExpr: Expr);
        /**
         * @type {number}
         */
        get nArgs(): number;
        /**
         * @type {string[]}
         */
        get argNames(): string[];
        /**
         * @type {Type[]}
         */
        get argTypes(): Type[];
        /**
         * @type {string[]}
         */
        get argTypeNames(): string[];
        /**
         * @type {Expr}
         */
        get retExpr(): Expr;
        /**
         * @type {Type[]}
         */
        get retTypes(): Type[];
        /**
         * @param {Scope} scope
         * @returns {null | FuncType}
         */
        evalType(scope: Scope): null | FuncType;
        isMethod(): boolean;
        /**
         * @returns {IR}
         */
        argsToIR(): IR;
        /**
         * In reverse order, because later opt args might depend on earlier args
         * @param {ToIRContext} ctx
         * @param {IR} innerIR
         * @returns {IR}
         */
        wrapWithDefaultArgs(ctx: ToIRContext, innerIR: IR): IR;
        /**
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIRInternal(ctx: ToIRContext): IR;
        #private;
    }
    /**
     * value[...] expression
     * @internal
     */
    export class ParametricExpr extends Expr {
        /**
         * Reused by CallExpr
         * @param {Type[]} paramTypes
         * @returns {string}
         */
        static toApplicationIR(paramTypes: Type[]): string;
        /**
         * @param {Site} site - site of brackets
         * @param {Expr} baseExpr
         * @param {Expr[]} parameters
         */
        constructor(site: Site, baseExpr: Expr, parameters: Expr[]);
        /**
         * @type {Type[]}
         */
        get paramTypes(): Type[];
        #private;
    }
    /**
     * Unary operator expression
     * Note: there are no post-unary operators, only pre
     * @internal
     */
    export class UnaryExpr extends Expr {
        /**
         * @param {SymbolToken} op
         * @param {Expr} a
         */
        constructor(op: SymbolToken, a: Expr);
        /**
         * Turns an op symbol into an internal name
         * @returns {Word}
         */
        translateOp(): Word;
        #private;
    }
    /**
     * @internal
     * @type {{[name: string]: string}}
     */
    export const BINARY_SYMBOLS_MAP: {
        [name: string]: string;
    };
    /**
     * Binary operator expression
     * @internal
     */
    export class BinaryExpr extends Expr {
        /**
         * @param {SymbolToken} op
         * @param {Expr} a
         * @param {Expr} b
         */
        constructor(op: SymbolToken, a: Expr, b: Expr);
        /**
         * @type {Expr}
         */
        get first(): Expr;
        /**
         * @type {Expr}
         */
        get second(): Expr;
        /**
         * Turns op symbol into internal name
         * @param {number} alt
         * @returns {Word}
         */
        translateOp(alt?: number): Word;
        /**
         * @returns {boolean}
         */
        isCommutative(): boolean;
        #private;
    }
    /**
     * Parentheses expression
     * @internal
     */
    export class ParensExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr[]} exprs
         */
        constructor(site: Site, exprs: Expr[]);
        #private;
    }
    /**
     * @internal
     */
    export class CallArgExpr extends Token {
        /**
         * @param {Site} site
         * @param {null | Word} name
         * @param {Expr} valueExpr
         */
        constructor(site: Site, name: null | Word, valueExpr: Expr);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {Expr}
         */
        get valueExpr(): Expr;
        /**
         * @type {EvalEntity}
         */
        get value(): EvalEntity;
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        eval(scope: Scope): null | EvalEntity;
        #private;
    }
    /**
     * ...(...) expression
     * @internal
     */
    export class CallExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} fnExpr
         * @param {CallArgExpr[]} argExprs
         */
        constructor(site: Site, fnExpr: Expr, argExprs: CallArgExpr[]);
        get fnExpr(): Expr;
        /**
         * Don't call this inside eval() because param types won't yet be complete.
         * @type {FuncType}
         */
        get fn(): FuncType;
        /**
         * @param {ToIRContext} ctx
         * @returns {[Expr[], IR[]]} - first list are positional args, second list named args and remaining opt args
         */
        expandArgs(ctx: ToIRContext): [Expr[], IR[]];
        /**
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toFnExprIR(ctx: ToIRContext): IR;
        #private;
    }
    /**
     *  ... . ... expression
     * @internal
     */
    export class MemberExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} objExpr
         * @param {Word} memberName
         */
        constructor(site: Site, objExpr: Expr, memberName: Word);
        /**
         * @param {ToIRContext} ctx
         * @param {string} params - applied type parameters must be inserted Before the call to self
         * @returns {IR}
         */
        toIR(ctx: ToIRContext, params?: string): IR;
        #private;
    }
    /**
     * if-then-else expression
     * @internal
     */
    export class IfElseExpr extends Expr {
        /**
         * @param {Site} site
         * @param {null | Type} prevType
         * @param {Type} newType
         * @returns {null | Type}
         */
        static reduceBranchType(site: Site, prevType: null | Type, newType: Type): null | Type;
        /**
         * @param {Site} site
         * @param {null | Type[]} prevTypes
         * @param {Typed | Multi} newValue
         * @returns {null | Type[]}
         */
        static reduceBranchMultiType(site: Site, prevTypes: null | Type[], newValue: Typed | Multi): null | Type[];
        /**
         * @param {Site} site
         * @param {Expr[]} conditions
         * @param {Expr[]} branches
         */
        constructor(site: Site, conditions: Expr[], branches: Expr[]);
        #private;
    }
    /**
     * DestructExpr is for the lhs-side of assignments and for switch cases
     * @internal
     */
    export class DestructExpr {
        /**
         * @param {Word} name - use an underscore as a sink
         * @param {null | Expr} typeExpr
         * @param {DestructExpr[]} destructExprs
         */
        constructor(name: Word, typeExpr: null | Expr, destructExprs?: DestructExpr[]);
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @returns {boolean}
         */
        hasDestructExprs(): boolean;
        isIgnored(): boolean;
        /**
         * @returns {boolean}
         */
        hasType(): boolean;
        /**
         * Throws an error if called before evalType()
         * @type {null | Type}
         */
        get type(): Type | null;
        /**
         * @type {Word}
         */
        get typeName(): Word;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * Evaluates the type, used by FuncLiteralExpr and DataDefinition
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalType(scope: Scope): null | Type;
        /**
         * @param {Scope} scope
         * @param {Type} upstreamType
         */
        evalDestructExprs(scope: Scope, upstreamType: Type): void;
        /**
         * @param {Scope} scope
         * @param {Type} upstreamType
         * @param {number} i
         */
        evalInternal(scope: Scope, upstreamType: Type, i: number): null | undefined;
        /**
         * @param {Scope} scope
         * @param {DataType} caseType
         */
        evalInSwitchCase(scope: Scope, caseType: DataType): void;
        /**
         * @param {Scope} scope
         * @param {null | Type} upstreamType
         * @param {number} i
         */
        evalInAssignExpr(scope: Scope, upstreamType: null | Type, i: number): null | undefined;
        /**
         * @param {number} argIndex
         * @returns {IR}
         */
        toNameIR(argIndex: number): IR;
        /**
         * @param {number} fieldIndex
         * @returns {string}
         */
        getFieldFn(fieldIndex: number): string;
        /**
         * @param {ToIRContext} ctx
         * @param {IR} inner
         * @param {string} objName
         * @param {number} fieldIndex
         * @param {string} fieldFn
         * @returns {IR}
         */
        wrapDestructIRInternal(ctx: ToIRContext, inner: IR, objName: string, fieldIndex: number, fieldFn: string): IR;
        /**
         * @param {ToIRContext} ctx
         * @param {IR} inner
         * @param {number} argIndex
         * @returns {IR}
         */
        wrapDestructIR(ctx: ToIRContext, inner: IR, argIndex: number): IR;
        /**
         * @returns {IR}
         */
        toIR(): IR;
        #private;
    }
    /**
     * Switch case for a switch expression
     * @internal
     */
    export class SwitchCase extends Token {
        /**
         * @param {Site} site
         * @param {DestructExpr} lhs
         * @param {Expr} bodyExpr
         */
        constructor(site: Site, lhs: DestructExpr, bodyExpr: Expr);
        /**
         * @type {Expr}
         */
        get body(): Expr;
        /**
         * Used by parser to check if typeExpr reference the same base enum
         * @type {Word} - word representation of type
         */
        get memberName(): Word;
        isDataMember(): boolean;
        /**
         * @type {number}
         */
        get constrIndex(): number;
        /**
         * Evaluates the switch type and body value of a case.
         * @param {Scope} scope
         * @param {DataType} enumType
         * @returns {null | Multi | Typed}
         */
        evalEnumMember(scope: Scope, enumType: DataType): null | Multi | Typed;
        /**
         * Evaluates the switch type and body value of a case.
         * @param {Scope} scope
         * @returns {null | Typed | Multi}
         */
        evalDataMember(scope: Scope): null | Typed | Multi;
        /**
         * Accept an arg because will be called with the result of the controlexpr
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIR(ctx: ToIRContext): IR;
        #private;
    }
    /**
     * @internal
     */
    export class UnconstrDataSwitchCase extends SwitchCase {
        /**
         * @param {Site} site
         * @param {?Word} intVarName
         * @param {?Word} lstVarName
         * @param {Expr} bodyExpr
         */
        constructor(site: Site, intVarName: Word | null, lstVarName: Word | null, bodyExpr: Expr);
        /**
         * @param {Scope} scope
         * @param {Type} enumType
         * @returns {Instance}
         */
        evalEnumMember(scope: Scope, enumType: Type): Instance;
        #private;
    }
    /**
     * Default switch case
     * @internal
     */
    export class SwitchDefault extends Token {
        /**
         * @param {Site} site
         * @param {Expr} bodyExpr
         */
        constructor(site: Site, bodyExpr: Expr);
        /**
         * @param {Scope} scope
         * @returns {null | Typed | Multi}
         */
        eval(scope: Scope): null | Typed | Multi;
        /**
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIR(ctx: ToIRContext): IR;
        #private;
    }
    /**
     * Switch expression for Enum, with SwitchCases and SwitchDefault as children
     * @internal
     */
    export class EnumSwitchExpr extends SwitchExpr {
    }
    /**
     * Switch expression for Data
     * @internal
     */
    export class DataSwitchExpr extends SwitchExpr {
    }
    /**
     * Base class for all statements
     * Doesn't return a value upon calling eval(scope)
     * @internal
     */
    export class Statement extends Token {
        /**
         * @param {Site} site
         * @param {Word} name
         */
        constructor(site: Site, name: Word);
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @param {ModuleScope} scope
         */
        eval(scope: ModuleScope): void;
        /**
         * @param {string} namespace
         * @param {(name: string, cs: ConstStatement) => void} callback
         */
        loopConstStatements(namespace: string, callback: (name: string, cs: ConstStatement) => void): void;
        /**
         * @param {string} basePath
         */
        setBasePath(basePath: string): void;
        /**
         * Returns IR of statement.
         * No need to specify indent here, because all statements are top-level
         * @param {ToIRContext} ctx
         * @param {IRDefinitions} map
         */
        toIR(ctx: ToIRContext, map: IRDefinitions): void;
        #private;
    }
    /**
     * Each field in `import {...} from <ModuleName>` is given a separate ImportFromStatement
     * @internal
     */
    export class ImportFromStatement extends Statement {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {Word} origName
         * @param {Word} moduleName
         */
        constructor(site: Site, name: Word, origName: Word, moduleName: Word);
        /**
         * @type {Word}
         */
        get moduleName(): Word;
        /**
         * @param {ModuleScope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: ModuleScope): null | EvalEntity;
        #private;
    }
    /**
     * `import <ModuleName>`
     * @internal
     */
    export class ImportModuleStatement extends Statement {
        /**
         * @type {Word}
         */
        get moduleName(): Word;
        /**
         * @param {ModuleScope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: ModuleScope): null | EvalEntity;
        #private;
    }
    /**
     * Const value statement
     * @internal
     */
    export class ConstStatement extends Statement {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {Expr} typeExpr - can be null in case of type inference
         * @param {null | Expr} valueExpr
         */
        constructor(site: Site, name: Word, typeExpr: Expr, valueExpr: null | Expr);
        /**
         * @type {DataType}
         */
        get type(): DataType;
        /**
         * @returns {boolean}
         */
        isSet(): boolean;
        /**
         * Use this to change a value of something that is already typechecked.
         * @param {UplcData} data
         */
        changeValueSafe(data: UplcData): void;
        /**
         * @param {Scope} scope
         * @returns {null | DataType}
         */
        evalType(scope: Scope): null | DataType;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: Scope): null | EvalEntity;
        /**
         * Evaluates rhs and adds to scope
         * @param {TopScope} scope
         */
        eval(scope: TopScope): void;
        /**
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIRInternal(ctx: ToIRContext): IR;
        #private;
    }
    /**
     * @internal
     */
    export class TypeParameter {
        /**
         * @param {Word} name
         * @param {null | Expr} typeClassExpr
         */
        constructor(name: Word, typeClassExpr: null | Expr);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {TypeClass}
         */
        get typeClass(): TypeClass;
        /**
         * @param {Scope} scope
         * @param {string} path
         * @returns {null | Parameter}
         */
        eval(scope: Scope, path: string): null | Parameter;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * @internal
     */
    export class TypeParameters {
        /**
         * @param {TypeParameter[]} parameterExprs
         * @param {boolean} isForFunc
         */
        constructor(parameterExprs: TypeParameter[], isForFunc: boolean);
        /**
         * @returns {boolean}
         */
        hasParameters(): boolean;
        /**
         * @type {string[]}
         */
        get parameterNames(): string[];
        /**
         * @returns {Parameter[]}
         */
        getParameters(): Parameter[];
        /**
         * Always include the braces, even if there aren't any type parameters, so that the mutual recursion injection function has an easier time figuring out what can depend on what
         * @param {string} base
         * @returns {string}
         */
        genTypePath(base: string): string;
        /**
         * Always include the braces, even if there aren't any type parameters, so that the mutual recursion injection function has an easier time figuring out what can depend on what
         * @param {string} base
         * @returns {string}
         */
        genFuncPath(base: string): string;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @param {Scope} scope
         * @returns {Scope}
         */
        evalParams(scope: Scope): Scope;
        /**
         * @param {Scope} scope
         * @param {(scope: Scope) => (null | FuncType)} evalConcrete
         * @returns {null | ParametricFunc | FuncType}
         */
        evalParametricFuncType(scope: Scope, evalConcrete: (scope: Scope) => (null | FuncType), impl?: null): null | ParametricFunc | FuncType;
        /**
         * @param {Scope} scope
         * @param {(scope: Scope) => (null | FuncType)} evalConcrete
         * @returns {null | EvalEntity}
         */
        evalParametricFunc(scope: Scope, evalConcrete: (scope: Scope) => (null | FuncType)): null | EvalEntity;
        /**
         * @param {Scope} scope
         * @param {Site} site
         * @param {(scope: Scope) => DataType} evalConcrete
         * @returns {[DataType | ParametricType, Scope]}
         */
        createParametricType(scope: Scope, site: Site, evalConcrete: (scope: Scope) => DataType): [DataType | ParametricType, Scope];
        #private;
    }
    /**
     * Single field in struct or enum member
     * @internal
     */
    export class DataField extends NameTypePair {
        /**
         * @param {Word} name
         * @param {Expr} typeExpr
         * @param {null | StringLiteral} tag
         */
        constructor(name: Word, typeExpr: Expr, tag?: null | StringLiteral);
        /**
         * Throws an error if called before evalType()
         * @type {DataType}
         */
        get type(): DataType;
        /**
         * @returns {boolean}
         */
        hasTag(): boolean;
        /**
         * @type {string}
         */
        get tag(): string;
        /**
         * Evaluates the type, used by FuncLiteralExpr and DataDefinition
         * @param {Scope} scope
         * @returns {null | DataType}
         */
        eval(scope: Scope): null | DataType;
        #private;
    }
    /**
     * Base class for struct and enum member
     * @internal
     */
    export class DataDefinition {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {DataField[]} fields
         */
        constructor(site: Site, name: Word, fields: DataField[]);
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @type {DataField[]}
         */
        get fields(): DataField[];
        hasTags(): boolean;
        /**
         * Returns index of a field.
         * Returns -1 if not found.
         * @param {Word} name
         * @returns {number}
         */
        findField(name: Word): number;
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @param {Word} name
         * @returns {boolean}
         */
        hasField(name: Word): boolean;
        /**
         * @param {Word} name
         * @returns {boolean}
         */
        hasMember(name: Word): boolean;
        /**
         * @returns {string}
         */
        toStringFields(): string;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @param {Scope} scope
         * @returns {InstanceMembers}
         */
        evalFieldTypes(scope: Scope): InstanceMembers;
        /**
         * @param {Type} self
         * @returns {Type}
         */
        genCopyType(self: Type): Type;
        /**
         * @type {number}
         */
        get nFields(): number;
        /**
         * @param {number} i
         * @returns {DataType}
         */
        getFieldType(i: number): DataType;
        /**
         * @param {string} name
         * @returns {number}
         */
        getFieldIndex(name: string): number;
        /**
         * @param {number} i
         * @returns {string}
         */
        getFieldName(i: number): string;
        /**
         * Gets insance member value.
         * @param {Type} self
         * @returns {InstanceMembers}
         */
        genInstanceMembers(self: Type): InstanceMembers;
        /**
         * @param {Type} self
         * @returns {TypeMembers}
         */
        genTypeMembers(self: Type): TypeMembers;
        /**
         * @returns {[string, string, NamedTypeSchema[]]}
         */
        genTypeDetails(): [string, string, NamedTypeSchema[]];
        /**
         * @param {any} obj
         * @param {JsToUplcHelpers} helpers
         * @return {Promise<UplcData[]>}
         */
        jsFieldsToUplc(obj: any, helpers: JsToUplcHelpers): Promise<UplcData[]>;
        /**
         * Uses field names as keys, not tags
         * @param {any} obj
         * @param {JsToUplcHelpers} helpers
         * @return {Promise<[UplcData, UplcData][]>}
         */
        jsMapToUplc(obj: any, helpers: JsToUplcHelpers): Promise<[UplcData, UplcData][]>;
        /**
         * @param {UplcData[]} fields
         * @param {UplcToJsHelpers} helpers
         * @returns {Promise<any>}
         */
        uplcFieldsToJs(fields: UplcData[], helpers: UplcToJsHelpers): Promise<any>;
        /**
         * For Cip68-tagged structs
         * @param {[UplcData, UplcData][]} fields
         * @param {UplcToJsHelpers} helpers
         * @returns {Promise<any>}
         */
        uplcMapToJs(fields: [UplcData, UplcData][], helpers: UplcToJsHelpers): Promise<any>;
        /**
         * @param {ToIRContext} ctx
         * @param {string} path
         * @param {IRDefinitions} map
         * @param {number} constrIndex
         */
        newToIR(ctx: ToIRContext, path: string, map: IRDefinitions, constrIndex: number): void;
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @param {string} path
         * @param {IRDefinitions} map
         * @param {string[]} getterNames
         * @param {number} constrIndex
         */
        copyToIR(ctx: ToIRContext, path: string, map: IRDefinitions, getterNames: string[], constrIndex?: number): void;
        /**
         * @internal
         * @returns {IR}
         */
        testDataToIR(): IR;
        /**
         * @internal
         * @param {string} path
         * @returns {IR}
         */
        fromDataFieldsCheckToIR(path: string): IR;
        /**
         * Doesn't return anything, but sets its IRdef in the map
         * @param {ToIRContext} ctx
         * @param {string} path
         * @param {IRDefinitions} map
         * @param {number} constrIndex
         */
        toIR(ctx: ToIRContext, path: string, map: IRDefinitions, constrIndex: number): void;
        #private;
    }
    /**
     * Struct statement
     * @internal
     */
    export class StructStatement extends Statement {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {TypeParameters} parameters
         * @param {DataField[]} fields
         * @param {ImplDefinition} impl
         */
        constructor(site: Site, name: Word, parameters: TypeParameters, fields: DataField[], impl: ImplDefinition);
        /**
         * @returns {HeliosDataClass<HeliosData>}
         */
        genOffChainType(): HeliosDataClass<HeliosData>;
        /**
         * Evaluates own type and adds to scope
         * @param {TopScope} scope
         */
        eval(scope: TopScope): void;
        #private;
    }
    /**
     * Function statement
     * (basically just a named FuncLiteralExpr)
     * @internal
     */
    export class FuncStatement extends Statement {
        /**
         * @param {Statement} s
         * @returns {boolean}
         */
        static isMethod(s: Statement): boolean;
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {TypeParameters} parameters
         * @param {FuncLiteralExpr} funcExpr
         */
        constructor(site: Site, name: Word, parameters: TypeParameters, funcExpr: FuncLiteralExpr);
        /**
         * @type {number}
         */
        get nArgs(): number;
        /**
         * @type {string[]}
         */
        get argNames(): string[];
        /**
         * @type {Type[]}
         */
        get argTypes(): Type[];
        /**
         * @type {string[]}
         */
        get argTypeNames(): string[];
        /**
         * @type {Type[]}
         */
        get retTypes(): Type[];
        /**
         * @type {Site}
         */
        get retSite(): Site;
        /**
         * Evaluates a function and returns a func value
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: Scope): null | EvalEntity;
        /**
         * Evaluates type of a funtion.
         * Separate from evalInternal so we can use this function recursively inside evalInternal
         * @param {Scope} scope
         * @returns {null | ParametricFunc | FuncType}
         */
        evalType(scope: Scope): null | ParametricFunc | FuncType;
        /**
         * Returns IR of function
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIRInternal(ctx: ToIRContext): IR;
        #private;
    }
    /**
     * EnumMember defintion is similar to a struct definition
     * @internal
     */
    export class EnumMember {
        /**
         * @param {Word} name
         * @param {DataField[]} fields
         */
        constructor(name: Word, fields: DataField[]);
        /**
         * @returns {number}
         */
        get constrIndex(): number;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @param {EnumStatement} parent
         * @param {number} i
        */
        registerParent(parent: EnumStatement, i: number): void;
        /**
         * @type {EnumStatement}
         */
        get parent(): EnumStatement;
        /**
         * @returns {HeliosDataClass<HeliosData>}
         */
        genOffChainType(): HeliosDataClass<HeliosData>;
        /**
         * @type {DataDefinition}
         */
        get dataDefinition(): DataDefinition;
        /**
         * @param {Scope} scope
         */
        evalDataFields(scope: Scope): void;
        /**
         * @param {Scope} scope
         * @returns {(parent: DataType) => EnumMemberType}
         */
        evalType(scope: Scope): (parent: DataType) => EnumMemberType;
        get path(): string;
        /**
         * @param {ToIRContext} ctx
         * @param {IRDefinitions} map
         */
        toIR(ctx: ToIRContext, map: IRDefinitions): void;
        #private;
    }
    /**
     * Enum statement, containing at least one member
     * @internal
     */
    export class EnumStatement extends Statement {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {TypeParameters} parameters
         * @param {EnumMember[]} members
         * @param {ImplDefinition} impl
         */
        constructor(site: Site, name: Word, parameters: TypeParameters, members: EnumMember[], impl: ImplDefinition);
        /**
         * @returns {boolean}
         */
        hasParameters(): boolean;
        /**
         * @internal
         * @returns {HeliosDataClass<HeliosData>}
         */
        genOffChainType(): HeliosDataClass<HeliosData>;
        /**
         * Returns index of enum member.
         * Returns -1 if not found
         * @param {Word} name
         * @returns {number}
         */
        findEnumMember(name: Word): number;
        /**
         * @param {number} i
         * @returns {EnumMember}
         */
        getEnumMember(i: number): EnumMember;
        /**
         * @param {Word} name
         * @returns {boolean}
         */
        hasEnumMember(name: Word): boolean;
        /**
         * @returns {number}
         */
        get nEnumMembers(): number;
        /**
         * @returns {IR}
         */
        testDataToIR(): IR;
        #private;
    }
    /**
     * Impl statements, which add functions and constants to registry of user types (Struct, Enum Member and Enums)
     * @internal
     */
    export class ImplDefinition {
        /**
         * @param {Expr} selfTypeExpr;
         * @param {(FuncStatement | ConstStatement)[]} statements
         */
        constructor(selfTypeExpr: Expr, statements: (FuncStatement | ConstStatement)[]);
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @param {string} basePath
         */
        setBasePath(basePath: string): void;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @param {Scope} scope
         * @returns {TypeMembers}
         */
        genTypeMembers(scope: Scope): TypeMembers;
        /**
         * Doesn't add the common types
         * @param {Scope} scope
         * @returns {InstanceMembers}
         */
        genInstanceMembers(scope: Scope): InstanceMembers;
        /**
         * @param {Scope} scope
         */
        eval(scope: Scope): void;
        /**
         * @param {string} namespace
         * @param {(name: string, cs: ConstStatement) => void} callback
         */
        loopConstStatements(namespace: string, callback: (name: string, cs: ConstStatement) => void): void;
        /**
         * Returns IR of all impl members
         * @param {ToIRContext} ctx
         * @param {IRDefinitions} map
         */
        toIR(ctx: ToIRContext, map: IRDefinitions): void;
        #private;
    }
    /**
     * Scope for IR names.
     * Works like a stack of named values from which a Debruijn index can be derived
     * @internal
     */
    export class IRScope {
        /**
         * Checks if a named builtin exists
         * @param {string} name
         * @param {boolean} strict - if true then throws an error if builtin doesn't exist
         * @returns {boolean}
         */
        static isBuiltin(name: string, strict?: boolean): boolean;
        /**
         * Returns index of a named builtin
         * Throws an error if builtin doesn't exist
         * @param {string} name
         * @returns {number}
         */
        static findBuiltin(name: string): number;
        /**
         * @param {null | IRScope} parent
         * @param {null | IRVariable} variable
         */
        constructor(parent: null | IRScope, variable: null | IRVariable);
        /**
         * Calculates the Debruijn index of a named value. Internal method
         * @param {Word | IRVariable} name
         * @param {number} index
         * @returns {[number, IRVariable]}
         */
        getInternal(name: Word | IRVariable, index: number): [number, IRVariable];
        /**
         * Calculates the Debruijn index.
         * @param {Word | IRVariable} name
         * @returns {[number, IRVariable]}
         */
        get(name: Word | IRVariable): [number, IRVariable];
        #private;
    }
    /**
     * IR class that represents function arguments
     * @internal
     */
    export class IRVariable extends Token {
        /**
         * @param {Word} name
         */
        constructor(name: Word);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @param {Map<IRVariable, IRVariable>} newVars
         * @returns {IRVariable}
         */
        copy(newVars: Map<IRVariable, IRVariable>): IRVariable;
        /**
         * @returns {boolean}
         */
        isAlwaysInlineable(): boolean;
        #private;
    }
    /**
     * Intermediate Representation variable reference expression
     * @internal
     * @implements {IRExpr}
     */
    export class IRNameExpr implements IRExpr {
        /**
         * @param {Word} name
         * @param {null | IRVariable} variable
         */
        constructor(name: Word, variable?: null | IRVariable);
        /**
         * @readonly
         * @type {Site}
         */
        readonly site: Site;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * isVariable() should be used to check if a IRNameExpr.variable is equal to a IRVariable (includes special handling of "__core*")
         * @type {IRVariable}
         */
        get variable(): IRVariable;
        /**
         * Used when inlining
         * @returns {IRNameExpr}
         */
        copy(): IRNameExpr;
        /**
         * @internal
         * @returns {boolean}
         */
        isCore(): boolean;
        /**
         * @internal
         * @returns {boolean}
         */
        isParam(): boolean;
        /**
         * @param {IRVariable} ref
         * @returns {boolean}
         */
        isVariable(ref: IRVariable): boolean;
        /**
         * @param {string} indent
         * @returns {string}
         */
        toString(indent?: string): string;
        /**
         * @param {IRScope} scope
         */
        resolveNames(scope: IRScope): void;
        /**
         * @returns {UplcTerm}
         */
        toUplc(): UplcTerm;
        #private;
    }
    /**
     * IR wrapper for UplcValues, representing literals
     * @internal
     * @implements {IRExpr}
     */
    export class IRLiteralExpr implements IRExpr {
        /**
         * @param {UplcValue} value
         */
        constructor(value: UplcValue);
        /**
         * @readonly
         * @type {Site}
         */
        readonly site: Site;
        /**
         * @type {UplcValue}
         */
        get value(): UplcValue;
        /**
         * @param {string} indent
         * @returns {string}
         */
        toString(indent?: string): string;
        /**
         * @returns {IRExpr}
         */
        copy(): IRExpr;
        /**
         * Linking doesn't do anything for literals
         * @param {IRScope} scope
         */
        resolveNames(scope: IRScope): void;
        /**
         * @returns {UplcConst}
         */
        toUplc(): UplcConst;
        #private;
    }
    /**
     * IR function expression with some args, that act as the header, and a body expression
     * @internal
     * @implements {IRExpr}
     */
    export class IRFuncExpr implements IRExpr {
        /**
         * @param {Site} site
         * @param {IRVariable[]} args
         * @param {IRExpr} body
         * @param {number} tag
         */
        constructor(site: Site, args: IRVariable[], body: IRExpr, tag: number);
        /**
         * @readonly
         * @type {Site}
         */
        readonly site: Site;
        /**
         * Mutation is more convenient and much faster when applying some optimizations.
         * @readwrite
         * @type {IRVariable[]}
         */
        args: IRVariable[];
        /**
         * Mutation is more convenient and much faster when applying some optimizations.
         * @readwrite
         * @type {IRExpr}
         */
        body: IRExpr;
        /**
         * A unique tag, that distinguishes each IRFuncExpr from each other IRFuncExpr (used for hashing)
         * @readonly
         * @type {number}
         */
        readonly tag: number;
        /**
         * @returns {boolean}
         */
        hasOptArgs(): boolean;
        /**
         * @param {string} indent
         * @returns {string}
         */
        toString(indent?: string): string;
        /**
         * @param {IRScope} scope
         */
        resolveNames(scope: IRScope): void;
        /**
         * @returns {IRExpr}
         */
        copy(): IRExpr;
        /**
         * @returns {UplcTerm}
         */
        toUplc(): UplcTerm;
    }
    /**
     * Base class of IRUserCallExpr and IRCoreCallExpr
     * @internal
     * @implements {IRExpr}
     */
    export class IRCallExpr implements IRExpr {
        /**
         * @param {Site} site
         * @param {string} name - full name of builtin, including prefix
         * @returns {UplcTerm}
         */
        static newUplcBuiltin(site: Site, name: string): UplcTerm;
        /**
         * @param {Site} site
         * @param {IRExpr} func
         * @param {IRExpr[]} args
         */
        constructor(site: Site, func: IRExpr, args: IRExpr[]);
        /**
         * @readonly
         * @type {Site}
         */
        readonly site: Site;
        /**
         * Mutation is more convenient and much faster when applying some optimizations.
         * @readwrite
         * @type {IRExpr}
         */
        func: IRExpr;
        /**
         * Mutation is more convenient and much faster when applying some optimizations.
         * @readwrite
         * @type {IRExpr[]}
         */
        args: IRExpr[];
        /**
         * @returns {boolean}
         */
        isSafeBuiltin(): boolean;
        /**
         * Returns an empty string this isn't a builtin
         * @type {string}
         */
        get builtinName(): string;
        /**
         * @param {string} indent
         * @returns {string}
         */
        argsToString(indent?: string): string;
        /**
         * @param {string} indent
         * @returns {string}
         */
        toString(indent?: string): string;
        /**
         * @param {IRScope} scope
         */
        resolveNamesInArgs(scope: IRScope): void;
        /**
         * @param {IRScope} scope
         */
        resolveNames(scope: IRScope): void;
        /**
         * @returns {IRExpr}
         */
        copy(): IRExpr;
        /**
         * @param {UplcTerm} term
         * @returns {UplcTerm}
         */
        toUplcCall(term: UplcTerm): UplcTerm;
        /**
         * @returns {UplcTerm}
         */
        toUplc(): UplcTerm;
    }
    /**
     * Intermediate Representation error call (with optional literal error message)
     * @internal
     * @implements {IRExpr}
     */
    export class IRErrorExpr implements IRExpr {
        /**
         * @param {Site} site
         * @param {string} msg
         */
        constructor(site: Site, msg?: string);
        /**
         * @readonly
         * @type {Site}
         */
        readonly site: Site;
        /**
         * @param {string} indent
         * @returns {string}
         */
        toString(indent?: string): string;
        /**
         * @param {IRScope} scope
         */
        resolveNames(scope: IRScope): void;
        /**
         * @returns {IRExpr}
         */
        copy(): IRExpr;
        /**
         * @returns {UplcTerm}
         */
        toUplc(): UplcTerm;
        #private;
    }
    /**
     * @internal
     * @implements {IRValue}
     */
    export class IRLiteralValue implements IRValue {
        /**
         * @param {UplcValue} value
         */
        constructor(value: UplcValue);
        /**
         * @readonly
         */
        readonly value: UplcValue;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @returns {boolean}
         */
        isLiteral(): boolean;
        /**
         * @param {boolean} maybe
         * @returns {boolean}
         */
        hasError(maybe?: boolean): boolean;
        /**
         * @returns {IRValue}
         */
        withoutLiterals(): IRValue;
        /**
         * @returns {IRValue}
         */
        withoutErrors(): IRValue;
        dump(depth?: number): {
            type: string;
            value: string;
            hash: number;
        };
        /**
         * @param {number} depth
         * @returns {number[]}
         */
        hash(depth?: number): number[];
        /**
         * TODO: code that takes Literal value into account (eg. `get codeWithLiterals()`)
         * @type {number}
         */
        get code(): number;
    }
    /**
     * @internal
     * @implements {IRValue}
     */
    export class IRDataValue implements IRValue {
        /**
         * @returns {boolean}
         */
        isLiteral(): boolean;
        /**
         * @returns {IRValue}
         */
        withoutLiterals(): IRValue;
        /**
         * @param {boolean} maybe
         * @returns {boolean}
         */
        hasError(maybe?: boolean): boolean;
        /**
         * @returns {IRValue}
         */
        withoutErrors(): IRValue;
        /**
         * @type {number}
         */
        get code(): number;
        /**
         *
         * @param {number} depth
         * @returns {number[]}
         */
        hash(depth?: number): number[];
        /**
         * @returns {string}
         */
        toString(): string;
        dump(depth?: number): {
            type: string;
            hash: number;
        };
    }
    /**
     * @internal
     * @implements {IRValue}
     */
    export class IRBuiltinValue implements IRValue {
        /**
         * @param {IRNameExpr} builtin
         */
        constructor(builtin: IRNameExpr);
        /**
         * @readonly
         * @type {IRNameExpr}
         */
        readonly builtin: IRNameExpr;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @returns {boolean}
         */
        isLiteral(): boolean;
        /**
         * @returns {IRValue}
         */
        withoutLiterals(): IRValue;
        /**
         * @param {boolean} maybe
         * @returns {boolean}
         */
        hasError(maybe?: boolean): boolean;
        /**
         * @returns {IRValue}
         */
        withoutErrors(): IRValue;
        /**
         * @type {number}
         */
        get code(): number;
        /**
         * @param {number} depth
         * @returns {number[]}
         */
        hash(depth?: number): number[];
        dump(depth?: number): {
            type: string;
            name: string;
            hash: number;
        };
    }
    /**
     * @internal
     * @implements {IRValue}
     */
    export class IRFuncValue implements IRValue {
        /**
         * @param {IRFuncExpr} definition
         * @param {IRStack} stack
         * @returns {IRFuncValue}
         */
        static new(definition: IRFuncExpr, stack: IRStack): IRFuncValue;
        /**
         * @param {IRFuncExpr} definition
         * @param {IRStack} stack
         */
        constructor(definition: IRFuncExpr, stack: IRStack);
        /**
         * @readonly
         * @type {IRStack}
         */
        readonly stack: IRStack;
        /**
         * @readonly
         * @type {IRFuncExpr}
         */
        readonly definition: IRFuncExpr;
        /**
         * @private
         * @type {number}
         */
        private get internalCode();
        /**
         * @type {number}
         */
        get code(): number;
        /**
         * @param {number} depth
         * @returns {number[]}
         */
        hash(depth?: number): number[];
        /**
         * @returns {boolean}
         */
        isLiteral(): boolean;
        /**
         * @returns {IRValue}
         */
        withoutLiterals(): IRValue;
        /**
         * @param {boolean} maybe
         * @returns {boolean}
         */
        hasError(maybe?: boolean): boolean;
        /**
         * @returns {IRValue}
         */
        withoutErrors(): IRValue;
        dump(depth?: number): {
            type: string;
            definition: string;
            hash: number;
            hashes: number[];
            stack: {
                values?: any[] | undefined;
                hash: number;
                hashes: number[];
                isLiteral: boolean;
            };
        };
        /**
         * @returns {string}
         */
        toString(): string;
    }
    /**
     * @internal
     * @implements {IRValue}
     */
    export class IRErrorValue implements IRValue {
        /**
         * @returns {boolean}
         */
        isLiteral(): boolean;
        /**
         * @returns {IRValue}
         */
        withoutLiterals(): IRValue;
        /**
         * @param {boolean} maybe
         * @returns {boolean}
         */
        hasError(maybe?: boolean): boolean;
        /**
         * @returns {IRValue}
         */
        withoutErrors(): IRValue;
        /**
         * @returns {string}
         */
        toString(): string;
        dump(depth?: number): {
            type: string;
            hash: number;
        };
        /**
         * @type {number}
         */
        get code(): number;
        /**
         * @param {number} depth
         * @returns {number[]}
         */
        hash(depth?: number): number[];
    }
    /**
     * Can be Data of any function
     * Simply eliminated when encountered in an IRMultiValue
     * @internal
     * @implements {IRValue}
     */
    export class IRAnyValue implements IRValue {
        /**
         * @returns {boolean}
         */
        isLiteral(): boolean;
        /**
         * @returns {IRValue}
         */
        withoutLiterals(): IRValue;
        /**
         * Maybe this IRAnyValue instance represents an Error, we can't know for sure.
         * @param {boolean} maybe
         * @returns {boolean}
         */
        hasError(maybe?: boolean): boolean;
        /**
         * @returns {IRValue}
         */
        withoutErrors(): IRValue;
        /**
         * @returns {string}
         */
        toString(): string;
        dump(depth?: number): {
            type: string;
            hash: number;
        };
        /**
         * @param {number} depth
         * @returns {number[]}
         */
        hash(depth?: number): number[];
        /**
         * @type {number}
         */
        get code(): number;
    }
    /**
     * @internal
     * @implements {IRValue}
     */
    export class IRMultiValue implements IRValue {
        /**
         * @param {IRValue[]} values
         * @returns {IRValue}
         */
        static flatten(values: IRValue[]): IRValue;
        /**
         * @param {IRValue[]} values
         * @returns {IRValue[][]}
         */
        static allPermutations(values: IRValue[]): IRValue[][];
        /**
         * @param {IRValue[]} values
         */
        constructor(values: IRValue[]);
        /**
         * @readonly
         */
        readonly values: IRValue[];
        /**
         * @param {boolean} maybe
         * @returns {boolean}
         */
        hasError(maybe?: boolean): boolean;
        /**
         * @returns {boolean}
         */
        isLiteral(): boolean;
        /**
         * @returns {IRValue}
         */
        withoutLiterals(): IRValue;
        /**
         * @returns {boolean}
         */
        hasData(): boolean;
        /**
         * @returns {boolean}
         */
        hasLiteral(): boolean;
        dump(depth?: number): {
            type: string;
            hash: number;
            values: any[];
        };
        toString(): string;
        /**
         * @type {number}
         */
        get code(): number;
        /**
         * @param {number} depth
         * @returns {number[]}
         */
        hash(depth?: number): number[];
        /**
         * @returns {IRValue}
         */
        withoutErrors(): IRValue;
    }
    /**
     * @internal
     */
    export class IREvaluator {
        /**
         * @param {boolean} evalLiterals
         */
        constructor(evalLiterals?: boolean);
        /**
         * @type {IRFuncExpr[]}
         */
        get funcExprs(): IRFuncExpr[];
        /**
         * @param {IRExpr} expr
         * @returns {undefined | IRValue}
         */
        getExprValue(expr: IRExpr): undefined | IRValue;
        /**
         * @param {IRVariable} v
         * @returns {undefined | IRValue}
         */
        getVariableValue(v: IRVariable): undefined | IRValue;
        /**
         * @param {IRVariable} v
         * @returns {number}
         */
        countVariableReferences(v: IRVariable): number;
        /**
         * @param {IRVariable} v
         * @returns {IRNameExpr[]}
         */
        getVariableReferences(v: IRVariable): IRNameExpr[];
        /**
         * @param {IRFuncExpr} fn
         * @returns {number}
         */
        countFuncCalls(fn: IRFuncExpr): number;
        /**
         * @param {IRExpr} expr
         * @returns {boolean}
         */
        expectsError(expr: IRExpr): boolean;
        /**
         * @param {IRFuncExpr} fn
         * @returns {number[]} indices
         */
        getUnusedFuncVariables(fn: IRFuncExpr): number[];
        /**
         * @param {IRFuncExpr} fn
         * @returns {IRCallExpr[]}
         */
        getFuncCallExprs(fn: IRFuncExpr): IRCallExpr[];
        /**
         * @param {IRFuncExpr} fn
         * @returns {boolean}
         */
        onlyDedicatedCallExprs(fn: IRFuncExpr): boolean;
        /**
         * @param {IRFuncExpr} fn
         * @param {number[]} unused
         * @returns {boolean}
         */
        noUnusedArgErrors(fn: IRFuncExpr, unused: number[]): boolean;
        /**
         * @param {IRFuncExpr} first
         * @param {IRFuncExpr} second
         */
        onlyNestedCalls(first: IRFuncExpr, second: IRFuncExpr): boolean;
        /**
         * Push onto the computeStack, unwrapping IRCallExprs
         * @private
         * @param {IRStack} stack
         * @param {IRExpr} expr
         */
        private pushExpr;
        /**
         * @param {IRExpr} expr
         * @param {IRValue} value
         */
        setExprValue(expr: IRExpr, value: IRValue): void;
        /**
         * @param {null | IRExpr} owner
         * @param {IRValue} value
         */
        pushReductionValue(owner: null | IRExpr, value: IRValue): void;
        /**
         * @private
         * @param {IRStack} stack
         * @param {IRNameExpr} nameExpr
         * @returns {IRValue}
         */
        private getValue;
        /**
         * @private
         * @param {IRExpr} owner
         * @param {IRNameExpr} nameExpr
         * @param {IRValue[]} args
         */
        private callBuiltin;
        /**
         * @param {IRFuncExpr} fn
         */
        incrCallCount(fn: IRFuncExpr): void;
        /**
         * @param {IRVariable[]} variables
         * @param {IRValue[]} values
         * @returns {[IRVariable, IRValue][]}
         */
        mapVarsToValues(variables: IRVariable[], values: IRValue[]): [IRVariable, IRValue][];
        /**
         * @private
         * @param {IRStack} stack
         * @param {null | IRExpr} owner
         * @param {IRFuncExpr} fn
         * @param {IRValue[]} args
         */
        private pushFuncCall;
        /**
         * @private
         * @param {IRExpr} owner for entry point ths is the entry point IRFuncExpr, for all other calls this is the IRCallExpr
         * @param {IRFuncValue} v
         * @param {IRValue[]} args
         */
        private callFunc;
        /**
         * Call an unknown function (eg. returned at the deepest point of recursion)
         * Make sure any arguments that are functions are also called so that all possible execution paths are touched (TODO: should we also called function values returned by those calls etc.?)
         * Absorb the return values of these functions
         * @private
         * @param {IRExpr} owner
         * @param {IRAnyValue} fn
         * @param {IRValue[]} args
         */
        private callAnyFunc;
        /**
         * @private
         * @param {IRCallExpr} expr
         * @param {number} code
         * @param {IRValue} value
         */
        private cacheValue;
        /**
         * @private
         */
        private evalInternal;
        /**
         * @param {IRExpr} expr entry point
         * @returns {IRValue}
         */
        evalFirstPass(expr: IRExpr): IRValue;
        /**
         * @param {IRFuncValue} main
         * @returns {IRValue}
         */
        evalSecondPass(main: IRFuncValue): IRValue;
        /**
         * @param {IRExpr} expr entry point
         * @returns {IRValue}
         */
        eval(expr: IRExpr): IRValue;
        /**
         * @param {IRExpr} expr
         * @returns {UplcData}
         */
        evalConst(expr: IRExpr): UplcData;
        #private;
    }
    /**
     * Recursive algorithm that performs the following optimizations.
     *
     * Optimizations performed in both `aggressive == false` and `aggressive == true` cases:
     *   * replace `IRNameExpr` by `IRLiteralExpr` if the expected value is IRLiteralValue
     *   * replace `IRCallExpr` by `IRLiteralExpr` if the expected value is IRLiteralValue
     *
     * Optimizations only performed in the `aggressive == true` case:
     *   * replace `IRNameExpr` by `IRErrorExpr` if the expected value is IRErrorValue
     *   * replace `IRCallExpr` by `IRErrorExpr` if the expected value is IRErrorValue
     *   * replace `__core__addInteger(<expr>, 0)` or `__core__addInteger(0, <expr>)` by `<expr>`
     *   * replace `__core__subtractInteger(<expr>, 0)` by `<expr>`
     *   * replace `__core__multiplyInteger(<expr>, 1)` or `__core__multiplyInteger(1, <expr>)` by `<expr>`
     *   * replace `__core__divideInteger(<expr>, 1)` by `<expr>`
     *   * replace `__core__quotientInteger(<expr>, 1)` by `<expr>`
     *   * replace `__core__appendByteString(<expr>, #)` or `__core__appendByteString(#, <expr>)` by `<expr>`
     *   * replace `__core__appendString(<expr>, "")` or `__core__appendString("", <expr>)` by `<expr>`
     *   * replace `__core__decodeUtf8(__core__encodeUtf8(<expr>))` by `<expr>`
     *   * replace `__core__ifThenElse(true, <expr-a>, <expr-b>)` by `<expr-a>` if `<expr-b>` doesn't expect IRErrorValue
     *   * replace `__core__ifThenElse(false, <expr-a>, <expr-b>)` by `<expr-b>` if `<expr-a>` doesn't expect IRErrorValue
     *   * replace `__core__ifThenElse(__core__nullList(<lst-expr>), <expr-a>, <expr-b>)` by `__core__chooseList(<lst-expr>, <expr-a>, <expr-b>)`
     *   * replace `__core__ifThenElse(<cond-expr>, <expr-a>, <expr_a>)` by `<expr-a>` if `<cond-expr>` doesn't expect IRErrorValue
     *   * replace `__core__chooseUnit(<expr>, ())` by `<expr>`
     *   * replace `__core__trace(<msg-expr>, <ret-expr>)` by `<ret_expr>` if `<msg-expr>` doesn't expect IRErrorValue
     *   * replace `__core__chooseList([], <expr-a>, <expr-b>)` by `<expr-a>` if `<expr-b>` doesn't expect IRErrorValue
     *   * replace `__core__chooseList([...], <expr-a>, <expr-b>)` by `<expr-b>` if `<expr-a>` doesn't expect IRErrorValue
     *   * replace `__core__chooseData(ConstrData, <C-expr>, <M-expr>, <L-expr>, <I-expr>, <B-expr>)` by `<C-expr>` if none of the other expressions expect IRErrorValue
     *   * replace `__core__chooseData(__core__constrData(<index-expr>, <fields-expr>), <C-expr>, <M-expr>, <L-expr>, <I-expr>, <B-expr>)` by `<C-expr>` if none of the other expressions expect IRErrorValue
     *   * replace `__core__chooseData(MapData, <C-expr>, <M-expr>, <L-expr>, <I-expr>, <B-expr>)` by `<M-expr>` if none of the other expression expect IRErrorValue
     *   * replace `__core__chooseData(__core__mapData(<data-expr>), <C-expr>, <M-expr>, <L-expr>, <I-expr>, <B-expr>)` by `<M-expr>` if none of the other expression expect IRErrorValue
     *   * replace `__core__chooseData(ListData, <C-expr>, <M-expr>, <L-expr>, <I-expr>, <B-expr>)` by `<L-expr>` if none of the other expression expect IRErrorValue
     *   * replace `__core__chooseData(__core__listData(<data-expr>), <C-expr>, <M-expr>, <L-expr>, <I-expr>, <B-expr>)` by `<L-expr>` if none of the other expression expect IRErrorValue
     *   * replace `__core__chooseData(IntData, <C-expr>, <M-expr>, <L-expr>, <I-expr>, <B-expr>)` by `<I-expr>` if none of the other expression expect IRErrorValue
     *   * replace `__core__chooseData(__core__iData(<data-expr>), <C-expr>, <M-expr>, <L-expr>, <I-expr>, <B-expr>)` by `<I-expr>` if none of the other expression expect IRErrorValue
     *   * replace `__core__chooseData(ByteArrayData, <C-expr>, <M-expr>, <L-expr>, <I-expr>, <B-expr>)` by `<B-expr>` if none of the other expression expect IRErrorValue
     *   * replace `__core__chooseData(__core__bData(<data-expr>), <C-expr>, <M-expr>, <L-expr>, <I-expr>, <B-expr>)` by `<B-expr>` if none of the other expression expect IRErrorValue
     *   * replace `__core__unMapData(__core__mapData(<expr>))` by `<expr>`
     *   * replace `__core__unListData(__core__listData(<expr>))` by `<expr>`
     *   * replace `__core__unIData(__core__iData(<expr>))` by `<expr>`
     *   * replace `__core__unBData(__core__bData(<expr>))` by `<expr>`
     *   * replace `__core__equalsData(__core__iData(<expr-a>), __core__iData(<expr-b>))` by `__core__equalsInteger(<expr-a>, <expr-b>)`
     *   * replace `__core__equalsData(__core__bData(<expr-a>), __core__bData(<expr-b>))` by `__core__equalsByteString(<expr-a>, <expr-b>)`
     *   * remove unused IRFuncExpr arg variables if none if the corresponding IRCallExpr args expect errors and if all the the IRCallExprs expect only this IRFuncExpr
     *   * replace IRCallExpr args that are uncalled IRFuncExprs with `()`
     *   * flatten nested IRFuncExprs if the correspondng IRCallExprs always call them in succession
     *   * replace `(<vars>) -> {<name-expr>(<vars>)}` by `<name-expr>` if each var is only referenced once (i.e. only referenced in the call)
     *   * replace `(<var>) -> {<var>}(<arg-expr>)` by `<arg-expr>`
     *   * replace `(<vars>) -> {<func-expr>(<vars>)}` by `<func-expr>` if each var is only referenced once (i.e. only referenced in the call)
     *   * inline (copies) of `<name-expr>` in `(<vars>) -> {...}(<name-expr>, ...)`
     *   * inline `<fn-expr>` in `(<vars>) -> {...}(<fn-expr>, ...)` if the corresponding var is only referenced once
     *   * inline `<call-expr>` in `(<vars>) -> {...}(<call-expr>, ...)` if the corresponding var is only referenced once and if all the nested IRFuncExprs are only evaluated once and if the IRCallExpr doesn't expect an error
     *   * replace `() -> {<expr>}()` by `<expr>`
     *
     * Optimizations that we have considered, but are NOT performed:
     *   * replace `__core__subtractInteger(0, <expr>)` by `__core__multiplyInteger(<expr>, -1)`
     *       reason: it is unclear if either method is cheaper for the majority of cases
     *   * replace `__core__multiplyInteger(<expr>, -1)` by `__core__subtractInteger(0, <expr>)`
     *       reason: it is unclear if either method is cheaper for the majority of cases
     *
     * @internal
     * @param {IREvaluator} evaluation
     * @param {IRExpr} expr
     * @param {boolean} aggressive
     * @returns {IRExpr}
     */
    export class IROptimizer {
        /**
         * @param {IRExpr} expr
         */
        static assertNoDuplicateExprs(expr: IRExpr): void;
        /**
         * @param {IRExpr} root
         * @param {boolean} aggressive
         */
        constructor(root: IRExpr, aggressive?: boolean);
        /**
         * @param {IRExpr} expr
         * @returns {boolean}
         */
        expectsError(expr: IRExpr): boolean;
        /**
         * @private
         * @param {IRFuncExpr} fn
         */
        private countFuncCalls;
        /**
         * Makes sure the callCount is copied from IREvaluator
         * @private
         * @param {IRFuncExpr} old
         * @param {IRVariable[]} args
         * @param {IRExpr} body
         * @returns {IRFuncExpr}
         */
        private newFuncExpr;
        /**
         * Apply optimizations that require access to the root:
         *   * flatten nested IRFuncExpr where possible
         *   * remove unused IRFuncExpr variables
         * @private
         */
        private init;
        /**
         * Mutates
         * @private
         */
        private removeUnusedArgs;
        /**
         * TODO: improve IREvaluator to make sure all possible IRFuncExpr calls are evaluated
         * @private
         */
        private replaceUncalledArgsWithUnit;
        /**
         * In scope order, call func before call args
         * @private
         */
        private collectFuncExprs;
        /**
         * @private
         */
        private flattenNestedFuncExprs;
        /**
         * @param {IRFuncExpr} start
         * @param {IRNameExpr} nameExpr
         * @returns {boolean}
         */
        isEvaluatedMoreThanOnce(start: IRFuncExpr, nameExpr: IRNameExpr): boolean;
        /**
         * @param {IRVariable} v
         * @param {IRExpr} expr
         */
        inline(v: IRVariable, expr: IRExpr): void;
        /**
         * @private
         * @param {IRNameExpr} expr
         * @returns {IRExpr}
         */
        private optimizeNameExpr;
        /**
         * The optimizations are only performed in aggressive mode
         * @private
         * @param {IRCallExpr} expr
         * @returns {IRExpr}
         */
        private optimizeBuiltinCallExpr;
        /**
         * @private
         * @param {IRCallExpr} expr
         * @returns {IRExpr}
         */
        private optimizeCallExpr;
        /**
         * @private
         * @param {IRFuncExpr} expr
         * @returns {IRExpr}
         */
        private optimizeFuncExpr;
        /**
         * @private
         * @param {IRExpr} expr
         */
        private optimizeInternal;
        /**
         * @returns {IRExpr}
         */
        optimize(): IRExpr;
        #private;
    }
    /**
     * Wrapper for IRFuncExpr, IRCallExpr or IRLiteralExpr
     * @internal
     */
    export class IRProgram {
        /**
         * @param {IRExpr} expr
         * @returns {IRFuncExpr | IRCallExpr | IRLiteralExpr}
         */
        static assertValidRoot(expr: IRExpr): IRFuncExpr | IRCallExpr | IRLiteralExpr;
        /**
         * @internal
         * @param {IR} ir
         * @param {null | ScriptPurpose} purpose
         * @param {boolean} simplify
         * @param {IRScope} scope
         * @returns {IRProgram}
         */
        static new(ir: IR, purpose: null | ScriptPurpose, simplify?: boolean, scope?: IRScope): IRProgram;
        /**
         * @param {IRExpr} expr
         * @returns {IRExpr}
         */
        static simplify(expr: IRExpr): IRExpr;
        /**
         * @param {IRFuncExpr | IRCallExpr | IRLiteralExpr} expr
         * @param {ProgramProperties} properties
         */
        constructor(expr: IRFuncExpr | IRCallExpr | IRLiteralExpr, properties: ProgramProperties);
        /**
         * @returns {string}
         */
        annotate(): string;
        /**
         * @internal
         * @type {IRFuncExpr | IRCallExpr | IRLiteralExpr}
         */
        get expr(): IRCallExpr | IRLiteralExpr | IRFuncExpr;
        /**
         * @internal
         * @type {ProgramProperties}
         */
        get properties(): ProgramProperties;
        /**
         * @internal
         * @type {Site}
         */
        get site(): Site;
        /**
         * @type {UplcData}
         */
        get data(): UplcData;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @returns {UplcProgram}
         */
        toUplc(): UplcProgram;
        /**
         * @returns {number}
         */
        calcSize(): number;
        #private;
    }
    /**
     * @internal
     */
    export class IRParametricProgram {
        /**
         * @internal
         * @param {IR} ir
         * @param {null | ScriptPurpose} purpose
         * @param {number} nParams
         * @param {boolean} simplify
         * @returns {IRParametricProgram}
         */
        static new(ir: IR, purpose: null | ScriptPurpose, nParams: number, simplify?: boolean): IRParametricProgram;
        /**
         * @param {IRProgram} irProgram
         * @param {number} nParams
         */
        constructor(irProgram: IRProgram, nParams: number);
        /**
         * @type {IRProgram}
         */
        get program(): IRProgram;
        /**
         * @returns {UplcProgram}
         */
        toUplc(): UplcProgram;
        #private;
    }
    /**
     * Helios root object
     */
    export class Program {
        /**
         * @internal
         * @param {string} rawSrc
         * @returns {[purpose, Module[]]}
         */
        static parseMainInternal(rawSrc: string): [ScriptPurpose | null, Module[]];
        /**
         * @internal
         * @param {string} mainName
         * @param {string[]} moduleSrcs
         * @returns {Module[]}
         */
        static parseImports(mainName: string, moduleSrcs?: string[]): Module[];
        /**
         * @internal
         * @param {string} mainSrc
         * @param {string[]} moduleSrcs
         * @returns {[null | ScriptPurpose, Module[]]}
         */
        static parseMain(mainSrc: string, moduleSrcs: string[]): [null | ScriptPurpose, Module[]];
        /**
         * Creates  a new program.
         * @param {string} mainSrc
         * @param {string[]} moduleSrcs - optional sources of modules, which can be used for imports
         * @param {ProgramConfig} config
         * @returns {Program}
         */
        static new(mainSrc: string, moduleSrcs?: string[], validatorTypes?: {}, config?: ProgramConfig): Program;
        /**
         * Creates  a new program.
         * @internal
         * @param {string} mainSrc
         * @param {string[]} moduleSrcs - optional sources of modules, which can be used for imports
         * @param {{[name: string]: Type}} validatorTypes
         * @param {ProgramConfig} config
         * @returns {Program}
         */
        static newInternal(mainSrc: string, moduleSrcs?: string[], validatorTypes?: {
            [name: string]: Type;
        }, config?: ProgramConfig): Program;
        /**
         * For top-level statements
         * @internal
         * @param {IR} mainIR
         * @param {IRDefinitions} map
         * @returns {IR}
         */
        static injectMutualRecursions(mainIR: IR, map: IRDefinitions): IR;
        /**
         * Also merges builtins and map
         * @internal
         * @param {ToIRContext} ctx
         * @param {IR} mainIR
         * @param {IRDefinitions} map
         * @returns {IRDefinitions}
         */
        static applyTypeParameters(ctx: ToIRContext, mainIR: IR, map: IRDefinitions): IRDefinitions;
        /**
         * @internal
         * @param {ScriptPurpose} purpose
         * @param {Module[]} modules
         * @param {ProgramConfig} config
         */
        constructor(purpose: ScriptPurpose, modules: Module[], config: ProgramConfig);
        /**
         * @internal
         */
        throwErrors(): void;
        /**
         * @type {ProgramConfig}
         */
        get config(): ProgramConfig;
        /**
         * @internal
         * @type {number}
         */
        get nPosParams(): number;
        /**
         * @internal
         * @type {Type[]}
         */
        get posParams(): Type[];
        /**
         * @internal
         * @type {Module[]}
         */
        get mainImportedModules(): Module[];
        /**
         * @internal
         * @type {MainModule}
         */
        get mainModule(): MainModule;
        /**
         * @internal
         * @type {null | Module}
         */
        get postModule(): Module | null;
        /**
         * @type {ScriptPurpose}
         */
        get purpose(): ScriptPurpose;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @internal
         * @type {FuncStatement}
         */
        get mainFunc(): FuncStatement;
        /**
         * @internal
         * @type {Site}
         */
        get mainRetExprSite(): Site;
        /**
         * @internal
         * @type {string[]}
         */
        get mainArgNames(): string[];
        /**
         * @internal
         * @type {DataType[]}
         */
        get mainArgTypes(): DataType[];
        /**
         * @internal
         * @type {string}
         */
        get mainPath(): string;
        /**
         * @internal
         * @type {Statement[]}
         */
        get mainStatements(): Statement[];
        /**
         * Needed to list the paramTypes, and to call changeParam
         * @internal
         * @type {Statement[]}
         */
        get mainAndPostStatements(): Statement[];
        /**
         * @internal
         * @type {[Statement, boolean][]} - boolean value marks if statement is import or not
         */
        get allStatements(): [Statement, boolean][];
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @internal
         * @param {GlobalScope} globalScope
         * @returns {TopScope}
         */
        evalTypesInternal(globalScope: GlobalScope): TopScope;
        /**
         * @internal
         * @param {{[name: string]: Type}} validatorTypes
         * @returns {TopScope}
         */
        evalTypes(validatorTypes?: {
            [name: string]: Type;
        }): TopScope;
        /**
         * @type {UserTypes}
         */
        get types(): UserTypes;
        /**
         * Fill #types with convenient javascript equivalents of Int, ByteArray etc.
         * @internal
         * @param {TopScope} topScope
         */
        fillTypes(topScope: TopScope): void;
        /**
         * @internal
         * @param {(name: string, cs: ConstStatement) => void} callback
         */
        loopConstStatements(callback: (name: string, cs: ConstStatement) => void): void;
        /**
         * @internal
         * @type {{[name: string]: DataType}}
         */
        get paramTypes(): {
            [name: string]: DataType;
        };
        /**
         * Change the literal value of a const statements
         * @internal
         * @param {string} name
         * @param {UplcData} data
         */
        changeParamSafe(name: string, data: UplcData): void;
        /**
         * @internal
         * @param {string} name
         * @returns {ConstStatement | null}
         */
        findConstStatement(name: string): ConstStatement | null;
        /**
         * @internal
         * @param {ConstStatement} constStatement
         * @returns {UplcValue}
         */
        evalConst(constStatement: ConstStatement): UplcValue;
        /**
         * Doesn't use wrapEntryPoint
         * @param {string} name - can be namespace: "Type::ConstName" or "Module::ConstName" or "Module::Type::ConstName"
         * @returns {UplcValue}
         */
        evalParam(name: string): UplcValue;
        /**
         * Use proxy for setting
         * @param {{[name: string]: HeliosData | any}} values
         */
        set parameters(arg: {
            [name: string]: any;
        });
        /**
         * Alternative way to get the parameters as HeliosData instances
         * @returns {{[name: string]: HeliosData | any}}
         */
        get parameters(): {
            [name: string]: any;
        };
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @param {(s: Statement, isImport: boolean) => boolean} endCond
         * @returns {IRDefinitions}
         */
        statementsToIR(ctx: ToIRContext, endCond: (s: Statement, isImport: boolean) => boolean): IRDefinitions;
        /**
         * @internal
         * @param {IR} ir
         * @param {IRDefinitions} definitions
         * @returns {Set<string>}
         */
        collectAllUsed(ir: IR, definitions: IRDefinitions): Set<string>;
        /**
         * @internal
         * @param {IR} ir
         * @param {IRDefinitions} definitions
         * @returns {IRDefinitions}
         */
        eliminateUnused(ir: IR, definitions: IRDefinitions): IRDefinitions;
        /**
         * Loops over all statements, until endCond == true (includes the matches statement)
         * Then applies type parameters
         * @internal
         * @param {ToIRContext} ctx
         * @param {IR} ir
         * @param {(s: Statement) => boolean} endCond
         * @returns {IRDefinitions}
         */
        fetchDefinitions(ctx: ToIRContext, ir: IR, endCond: (s: Statement) => boolean): IRDefinitions;
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @param {IR} ir
         * @param {IRDefinitions} definitions
         * @returns {IR}
         */
        wrapInner(ctx: ToIRContext, ir: IR, definitions: IRDefinitions): IR;
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @param {IR} ir
         * @param {null | IRDefinitions} extra
         * @returns {IR}
         */
        wrapEntryPoint(ctx: ToIRContext, ir: IR, extra?: null | IRDefinitions): IR;
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIRInternal(ctx: ToIRContext): IR;
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @param {null | IRDefinitions} extra
         * @returns {IR}
         */
        toIR(ctx: ToIRContext, extra?: null | IRDefinitions): IR;
        /**
         * Non-positional named parameters
         * @internal
         * @type {[string, Type][]}
         */
        get requiredParameters(): [string, Type][];
        /**
         * @returns {string}
         */
        prettyIR(simplify?: boolean): string;
        /**
         * @param {boolean} simplify
         * @returns {string}
         */
        annotateIR(simplify?: boolean): string;
        /**
         * @param {boolean} simplify
         * @returns {UplcProgram}
         */
        compile(simplify?: boolean): UplcProgram;
        #private;
    }
    /**
     * Used by CLI
     * @internal
     */
    export class DatumRedeemerProgram extends Program {
        /**
         * @type {DataType}
         */
        get datumType(): DataType;
        /**
         * @type {string}
         */
        get datumTypeName(): string;
        /**
         * @internal
         * @param {ScriptTypes} scriptTypes
         * @returns {TopScope}
         */
        evalTypes(scriptTypes: ScriptTypes): TopScope;
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        datumCheckToIR(ctx: ToIRContext): IR;
        /**
         * Used by cli
         * @internal
         * @returns {UplcProgram}
         */
        compileDatumCheck(): UplcProgram;
    }
    /**
     * @internal
     */
    export class NativeContext {
        /**
         *
         * @param {bigint | null} firstValidSlot
         * @param {bigint | null} lastValidSlot
         * @param {PubKeyHash[]} keys
         */
        constructor(firstValidSlot: bigint | null, lastValidSlot: bigint | null, keys: PubKeyHash[]);
        /**
         * Used by NativeAfter
         * @param {bigint} slot
         * @returns {boolean}
         */
        isAfter(slot: bigint): boolean;
        /**
         *
         * @param {bigint} slot
         * @returns {boolean}
         */
        isBefore(slot: bigint): boolean;
        /**
         *
         * @param {PubKeyHash} key
         * @returns {boolean}
         */
        isSignedBy(key: PubKeyHash): boolean;
        #private;
    }
    /**
     * Helios supports Cardano [native scripts](https://cips.cardano.org/cips/cip29/).
     * See `Tx.attachScript()` for how `NativeScript` can be used when building a transaction.
     *
     * NativeScript allows creating basic multi-signature and time-based validators.
     * This is a legacy technology, but can be cheaper than using Plutus.
     */
    export class NativeScript extends CborData {
        /**
         * @param {string | number[]} raw
         * @returns {NativeScript}
         */
        static fromCbor(raw: string | number[]): NativeScript;
        /**
         * @param {string | Object} json
         * @returns {NativeScript}
         */
        static fromJson(json: string | any): NativeScript;
        /**
         * @param {number} type
         */
        constructor(type: number);
        /**
         * @returns {number[]}
         */
        typeToCbor(): number[];
        /**
         * @returns {Object}
         */
        toJson(): any;
        /**
         * @internal
         * @param {NativeContext} context
         * @returns {boolean}
         */
        eval(context: NativeContext): boolean;
        /**
         * Calculates the blake2b-224 (28 bytes) hash of the NativeScript.
         *
         * **Note**: a 0 byte is prepended before to the serialized CBOR representation, before calculating the hash.
         * @returns {number[]}
         */
        hash(): number[];
        /**
         * A `NativeScript` can be used both as a Validator and as a MintingPolicy
         * @type {ValidatorHash}
         */
        get validatorHash(): ValidatorHash;
        /**
         * A `NativeScript` can be used both as a Validator and as a MintingPolicy
         * @type {MintingPolicyHash}
         */
        get mintingPolicyHash(): MintingPolicyHash;
        #private;
    }
    /**
     * Represents a Cardano transaction. Can also be used as a transaction builder.
     */
    export class Tx extends CborData {
        /**
         * Create a new Tx builder.
         * @returns {Tx}
         */
        static new(): Tx;
        /**
         * Deserialize a CBOR encoded Cardano transaction (input is either an array of bytes, or a hex string).
         * @param {number[] | string} raw
         * @returns {Tx}
         */
        static fromCbor(raw: number[] | string): Tx;
        /**
         * Used by bundler for macro finalization
         * @param {UplcData} data
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @param {TxInput[]} spareUtxos
         * @param {{[name: string]: (UplcProgram | (() => UplcProgram))}} scripts UplcPrograms can be lazy
         * @returns {Promise<Tx>}
         */
        static finalizeUplcData(data: UplcData, networkParams: NetworkParams, changeAddress: Address, spareUtxos: TxInput[], scripts: {
            [name: string]: UplcProgram | (() => UplcProgram);
        }): Promise<Tx>;
        /**
         * Use `Tx.new()` instead of this constructor for creating a new Tx builder.
         * @param {TxBody} body
         * @param {TxWitnesses} witnesses
         * @param {boolean} valid
         * @param {null | TxMetadata} metadata
         * @param {null | bigint | Date} validTo
         * @param {null | bigint | Date} validFrom
         */
        constructor(body?: TxBody, witnesses?: TxWitnesses, valid?: boolean, metadata?: null | TxMetadata, validTo?: null | bigint | Date, validFrom?: null | bigint | Date);
        /**
         * @type {TxBody}
         */
        get body(): TxBody;
        /**
         * @type {number[]}
         */
        get bodyHash(): number[];
        /**
         * @type {TxWitnesses}
         */
        get witnesses(): TxWitnesses;
        /**
         * Used by emulator to check if tx is valid.
         * @param {bigint} slot
         * @returns {boolean}
         */
        isValid(slot: bigint): boolean;
        /**
         * Creates a new Tx without the metadata for client-side signing where the client can't know the metadata before tx-submission.
         * @returns {Tx}
         */
        withoutMetadata(): Tx;
        /**
         * @param {NetworkParams} networkParams
         * @returns {UplcData}
         */
        toTxData(networkParams: NetworkParams): UplcData;
        /**
         * A serialized tx throws away input information
         * This must be refetched from the network if the tx needs to be analyzed
         * @param {(id: TxOutputId) => Promise<TxOutput>} fn
         */
        completeInputData(fn: (id: TxOutputId) => Promise<TxOutput>): Promise<void>;
        /**
         * @param {null | NetworkParams} params If specified: dump all the runtime details of each redeemer (datum, redeemer, scriptContext)
         * @returns {Object}
         */
        dump(params?: null | NetworkParams): any;
        /**
         * Set the start of the valid time range by specifying either a Date or a slot.
         *
         * Mutates the transaction.
         * Only available during building the transaction.
         * Returns the transaction instance so build methods can be chained.
         *
         * > **Note**: since Helios v0.13.29 this is set automatically if any of the Helios validator scripts call `tx.time_range`.
         * @param {bigint | Date } slotOrTime
         * @returns {Tx}
         */
        validFrom(slotOrTime: bigint | Date): Tx;
        /**
         * Set the end of the valid time range by specifying either a Date or a slot.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         *
         * > **Note**: since Helios v0.13.29 this is set automatically if any of the Helios validator scripts call `tx.time_range`.
         * @param {bigint | Date } slotOrTime
         * @returns {Tx}
         */
        validTo(slotOrTime: bigint | Date): Tx;
        /**
         * Mint a list of tokens associated with a given `MintingPolicyHash`.
         * Throws an error if the given `MintingPolicyHash` was already used in a previous call to `mintTokens()`.
         * The token names can either by a list of bytes or a hexadecimal string.
         *
         * Mutates the transaction.
         * Only available during transaction building the transaction.
         * Returns the transaction instance so build methods can be chained.
         *
         * Also throws an error if the redeemer is `null`, and the minting policy isn't a known `NativeScript`.
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {[ByteArray | ByteArrayProps, HInt | HIntProps][]} tokens - list of pairs of [tokenName, quantity], tokenName can be list of bytes or hex-string
         * @param {UplcDataValue | UplcData | null} redeemer
         * @returns {Tx}
         */
        mintTokens(mph: MintingPolicyHash | MintingPolicyHashProps, tokens: [ByteArray | ByteArrayProps, HInt | HIntProps][], redeemer: UplcDataValue | UplcData | null): Tx;
        /**
         * Add a UTxO instance as an input to the transaction being built.
         * Throws an error if the UTxO is locked at a script address but a redeemer isn't specified (unless the script is a known `NativeScript`).
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {TxInput} input
         * @param {null | UplcDataValue | UplcData | HeliosData} rawRedeemer
         * @returns {Tx}
         */
        addInput(input: TxInput, rawRedeemer?: null | UplcDataValue | UplcData | HeliosData): Tx;
        /**
         * Add multiple UTxO instances as inputs to the transaction being built.
         * Throws an error if the UTxOs are locked at a script address but a redeemer isn't specified (unless the script is a known `NativeScript`).
         *
         * Mutates the transaction.
         * Only available during transaction building. Returns the transaction instance so build methods can be chained.
         * @param {TxInput[]} inputs
         * @param {?(UplcDataValue | UplcData | HeliosData)} redeemer
         * @returns {Tx}
         */
        addInputs(inputs: TxInput[], redeemer?: (UplcDataValue | UplcData | HeliosData) | null): Tx;
        /**
         * Add a `TxInput` instance as a reference input to the transaction being built.
         * Any associated reference script, as a `UplcProgram` instance, must also be included in the transaction at this point (so the that the execution budget can be calculated correctly).
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {TxInput} input
         * @param {null | UplcProgram} refScript
         * @returns {Tx}
         */
        addRefInput(input: TxInput, refScript?: null | UplcProgram): Tx;
        /**
         * Add multiple `TxInput` instances as reference inputs to the transaction being built.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {TxInput[]} inputs
         * @returns {Tx}
         */
        addRefInputs(inputs: TxInput[]): Tx;
        /**
         * Add a `TxOutput` instance to the transaction being built.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {TxOutput} output
         * @returns {Tx}
         */
        addOutput(output: TxOutput): Tx;
        /**
         * Add multiple `TxOutput` instances at once.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {TxOutput[]} outputs
         * @returns {Tx}
         */
        addOutputs(outputs: TxOutput[]): Tx;
        /**
         * Add a signatory `PubKeyHash` to the transaction being built.
         * The added entry becomes available in the `tx.signatories` field in the Helios script.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {PubKeyHash} hash
         * @returns {Tx}
         */
        addSigner(hash: PubKeyHash): Tx;
        /**
         * Add a `DCert` to the transactions being built. `DCert` contains information about a staking-related action.
         *
         * TODO: implement all DCert (de)serialization methods.
         *
         * Returns the transaction instance so build methods can be chained.
         * @param {DCert} dcert
         * @returns {Tx}
         */
        addDCert(dcert: DCert): Tx;
        /**
         * Attaches a script witness to the transaction being built.
         * The script witness can be either a `UplcProgram` or a legacy `NativeScript`.
         * A `UplcProgram` instance can be created by compiling a Helios `Program`.
         * A legacy `NativeScript` instance can be created by deserializing its original CBOR representation.
         *
         * Throws an error if script has already been added.
         * Throws an error if the script isn't used upon finalization.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         *
         * > **Note**: a `NativeScript` must be attached before associated inputs are added or tokens are minted.
         * @param {UplcProgram | NativeScript} program
         * @returns {Tx}
         */
        attachScript(program: UplcProgram | NativeScript): Tx;
        /**
         * Add a UTxO instance as collateral to the transaction being built.
         * Usually adding only one collateral input is enough.
         * The number of collateral inputs must be greater than 0 if script witnesses are used in the transaction,
         * and must be less than the limit defined in the `NetworkParams`.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {TxInput} input
         * @returns {Tx}
         */
        addCollateral(input: TxInput): Tx;
        /**
         * Calculates tx fee (including script execution)
         * Shouldn't be used directly
         * @internal
         * @param {NetworkParams} networkParams
         * @returns {bigint}
         */
        estimateFee(networkParams: NetworkParams): bigint;
        /**
         * Iterates until fee is exact
         * Shouldn't be used directly
         * @internal
         * @param {NetworkParams} networkParams
         * @param {bigint} fee
         * @returns {bigint}
         */
        setFee(networkParams: NetworkParams, fee: bigint): bigint;
        /**
         * Checks that all necessary scripts are included, and that all included scripts are used
         * Shouldn't be used directly
         * @internal
         */
        checkScripts(): void;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @returns {Promise<void>}
         */
        executeRedeemers(networkParams: NetworkParams, changeAddress: Address): Promise<void>;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @returns {Promise<void>}
         */
        checkExecutionBudgets(networkParams: NetworkParams): Promise<void>;
        /**
         * @internal
         * @param {Address} changeAddress
         */
        balanceAssets(changeAddress: Address): void;
        /**
         * Calculate the base fee which will be multiplied by the required min collateral percentage
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @param {TxInput[]} spareUtxos
         */
        estimateCollateralBaseFee(networkParams: NetworkParams, changeAddress: Address, spareUtxos: TxInput[]): bigint;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @param {TxInput[]} spareUtxos
         */
        balanceCollateral(networkParams: NetworkParams, changeAddress: Address, spareUtxos: TxInput[]): void;
        /**
         * Calculates fee and balances transaction by sending an output back to changeAddress
         * First assumes that change output isn't needed, and if that assumption doesn't result in a balanced transaction the change output is created.
         * Iteratively increments the fee because the fee increase the tx size which in turn increases the fee (always converges within two steps though).
         * Throws error if transaction can't be balanced.
         * Shouldn't be used directly
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @param {TxInput[]} spareUtxos - used when there are yet enough inputs to cover everything (eg. due to min output lovelace requirements, or fees)
         * @returns {TxOutput} - changeOutput so the fee can be mutated furthers
         */
        balanceLovelace(networkParams: NetworkParams, changeAddress: Address, spareUtxos: TxInput[]): TxOutput;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxOutput} changeOutput
         */
        correctChangeOutput(networkParams: NetworkParams, changeOutput: TxOutput): void;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         */
        checkBalanced(networkParams: NetworkParams): void;
        /**
         * Shouldn't be used directly
         * @internal
         * @param {NetworkParams} networkParams
         */
        syncScriptDataHash(networkParams: NetworkParams): void;
        /**
         * @internal
         * @returns {boolean}
         */
        isSmart(): boolean;
        /**
         * Throws an error if there isn't enough collateral
         * Also throws an error if the script doesn't require collateral, but collateral was actually included
         * Shouldn't be used directly
         * @internal
         * @param {NetworkParams} networkParams
         */
        checkCollateral(networkParams: NetworkParams): void;
        /**
         * Throws error if tx is too big
         * Shouldn't be used directly
         * @internal
         * @param {NetworkParams} networkParams
         */
        checkSize(networkParams: NetworkParams): void;
        /**
         * Final check that fee is big enough
         * @internal
         * @param {NetworkParams} networkParams
         */
        checkFee(networkParams: NetworkParams): void;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         */
        finalizeValidityTimeRange(networkParams: NetworkParams): void;
        /**
         * Executes all the attached scripts with appropriate redeemers and calculates execution budgets.
         * Balances the transaction, and optionally uses some spare UTxOs if the current inputs don't contain enough lovelace to cover the fees and min output deposits.
         *
         * Inputs, minted assets, and withdrawals are sorted.
         *
         * Sets the validatity range automatically if a call to `tx.time_range` is detected in any of the attached Helios scripts.
         * @param {NetworkParams} networkParams
         * @param {Address}       changeAddress
         * @param {TxInput[]}        spareUtxos - might be used during balancing if there currently aren't enough inputs
         * @returns {Promise<Tx>}
         */
        finalize(networkParams: NetworkParams, changeAddress: Address, spareUtxos?: TxInput[]): Promise<Tx>;
        /**
         * @type {string}
         */
        get profileReport(): string;
        /**
         * Adds a signature created by a wallet. Only available after the transaction has been finalized.
         * Optionally verifies that the signature is correct.
         * @param {Signature} signature
         * @param {boolean} verify Defaults to `true`
         * @returns {Tx}
         */
        addSignature(signature: Signature, verify?: boolean): Tx;
        /**
         * Adds multiple signatures at once. Only available after the transaction has been finalized.
         * Optionally verifies each signature is correct.
         * @param {Signature[]} signatures
         * @param {boolean} verify
         * @returns {Tx}
         */
        addSignatures(signatures: Signature[], verify?: boolean): Tx;
        /**
         * Add metadata to a transaction.
         * Metadata can be used to store data on-chain,
         * but can't be consumed by validator scripts.
         * Metadata can for example be used for [CIP 25](https://cips.cardano.org/cips/cip25/).
         * @param {number} tag
         * @param {Metadata} data
         * @returns {Tx}
         */
        addMetadata(tag: number, data: Metadata): Tx;
        /**
         * @returns {TxId}
         */
        id(): TxId;
        #private;
    }
    /**
     * inputs, minted assets, and withdrawals need to be sorted in order to form a valid transaction
     */
    export class TxBody extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {TxBody}
         */
        static fromCbor(bytes: number[]): TxBody;
        /**
         * @type {TxInput[]}
         */
        get inputs(): TxInput[];
        /**
         * @type {TxInput[]}
         */
        get refInputs(): TxInput[];
        /**
         * @type {TxOutput[]}
         */
        get outputs(): TxOutput[];
        /**
         * @type {bigint}
         */
        get fee(): bigint;
        /**
         * @internal
         * @param {bigint} fee
         */
        setFee(fee: bigint): void;
        /**
         * @type {Assets}
         */
        get minted(): Assets;
        /**
         * @type {TxInput[]}
         */
        get collateral(): TxInput[];
        /**
         * @type {bigint | null}
         */
        get firstValidSlot(): bigint | null;
        /**
         * @type {bigint | null}
         */
        get lastValidSlot(): bigint | null;
        /**
         * @type {PubKeyHash[]}
         */
        get signers(): PubKeyHash[];
        /**
         * @type {DCert[]}
         */
        get dcerts(): DCert[];
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * For now simply returns minus infinity to plus infinity (WiP)
         * @internal
         * @param {NetworkParams} networkParams
         * @returns {ConstrData}
         */
        toValidTimeRangeData(networkParams: NetworkParams): ConstrData;
        /**
         * A serialized tx throws away input information
         * This must be refetched from the network if the tx needs to be analyzed
         * @internal
         * @param {(id: TxOutputId) => Promise<TxOutput>} fn
         * @param {TxWitnesses} witnesses
         */
        completeInputData(fn: (id: TxOutputId) => Promise<TxOutput>, witnesses: TxWitnesses): Promise<void>;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Redeemer[]} redeemers
         * @param {ListData} datums
         * @param {TxId} txId
         * @returns {ConstrData}
         */
        toTxData(networkParams: NetworkParams, redeemers: Redeemer[], datums: ListData, txId: TxId): ConstrData;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Redeemer[]} redeemers
         * @param {ListData} datums
         * @param {number} redeemerIdx
         * @param {TxId} txId
         * @returns {UplcData}
         */
        toScriptContextData(networkParams: NetworkParams, redeemers: Redeemer[], datums: ListData, redeemerIdx: number, txId?: TxId): UplcData;
        /**
         * @returns {Value}
         */
        sumInputValue(): Value;
        /**
         * Throws error if any part of the sum is negative (i.e. more is burned than input)
         * @returns {Value}
         */
        sumInputAndMintedValue(): Value;
        /**
         * @returns {Assets}
         */
        sumInputAndMintedAssets(): Assets;
        /**
         * @returns {Value}
         */
        sumOutputValue(): Value;
        /**
         * @returns {Assets}
         */
        sumOutputAssets(): Assets;
        /**
         * @internal
         * @param {bigint} slot
         */
        validFrom(slot: bigint): void;
        /**
         * @internal
         * @param {bigint} slot
         */
        validTo(slot: bigint): void;
        /**
         * Throws error if this.#minted already contains mph
         * @internal
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph - minting policy hash
         * @param {[ByteArray | ByteArrayProps, HInt | HIntProps][]} tokens
         */
        addMint(mph: MintingPolicyHash | MintingPolicyHashProps, tokens: [ByteArray | ByteArrayProps, HInt | HIntProps][]): void;
        /**
         * @internal
         * @param {TxInput} input
         * @param {boolean} checkUniqueness
         */
        addInput(input: TxInput, checkUniqueness?: boolean): void;
        /**
         * Used to remove dummy inputs
         * Dummy inputs are needed to be able to correctly estimate fees
         * Throws an error if input doesn't exist in list of inputs
         * @internal
         * @param {TxInput} input
         */
        removeInput(input: TxInput): void;
        /**
         * @internal
         * @param {TxInput} input
         * @param {boolean} checkUniqueness
         */
        addRefInput(input: TxInput, checkUniqueness?: boolean): void;
        /**
         * @internal
         * @param {TxOutput} output
         */
        addOutput(output: TxOutput): void;
        /**
         * Used to remove dummy outputs
         * Dummy outputs are needed to be able to correctly estimate fees
         * Throws an error if the output doesn't exist in list of outputs
         * @internal
         * @param {TxOutput} output
         */
        removeOutput(output: TxOutput): void;
        /**
         * @internal
         * @param {PubKeyHash} hash
         * @param {boolean} checkUniqueness
         */
        addSigner(hash: PubKeyHash, checkUniqueness?: boolean): void;
        /**
         * @internal
         * @param {DCert} dcert
         */
        addDCert(dcert: DCert): void;
        /**
         * @internal
         * @param {TxInput} input
         */
        addCollateral(input: TxInput): void;
        /**
         * @internal
         * @param {Hash | null} scriptDataHash
         */
        setScriptDataHash(scriptDataHash: Hash | null): void;
        /**
         * @internal
         * @param {Hash} metadataHash
         */
        setMetadataHash(metadataHash: Hash): void;
        /**
         * @internal
         * @param {TxOutput | null} output
         */
        setCollateralReturn(output: TxOutput | null): void;
        /**
         * Calculates the number of dummy signatures needed to get precisely the right tx size.
         * @internal
         * @returns {number}
         */
        countUniqueSigners(): number;
        /**
         * Script hashes are found in addresses of TxInputs and hashes of the minted MultiAsset.
         * @internal
         * @param {Map<string, number>} set - hashes in hex format
         */
        collectScriptHashes(set: Map<string, number>): void;
        /**
         * Makes sure each output contains the necessary min lovelace.
         * @internal
         * @param {NetworkParams} networkParams
         */
        correctOutputs(networkParams: NetworkParams): void;
        /**
         * Checks that each output contains enough lovelace
         * @internal
         * @param {NetworkParams} networkParams
         */
        checkOutputs(networkParams: NetworkParams): void;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {null | bigint} minCollateral
         */
        checkCollateral(networkParams: NetworkParams, minCollateral: null | bigint): void;
        /**
         * Makes sore inputs, withdrawals, and minted assets are in correct order, this is needed for the redeemer indices
         * Mutates
         * @internal
         */
        sortInputs(): void;
        /**
         * Not done in the same routine as sortInputs(), because balancing of assets happens after redeemer indices are set
         * @internal
         */
        sortOutputs(): void;
        /**
         * Used by (indirectly) by emulator to check if slot range is valid.
         * Note: firstValidSlot == lastValidSlot is allowed
         * @internal
         * @param {bigint} slot
         */
        isValid(slot: bigint): boolean;
        /**
         * @internal
         * @returns {number[]}
         */
        hash(): number[];
        #private;
    }
    /**
     * Represents the pubkey signatures, and datums/redeemers/scripts that are witnessing a transaction.
     */
    export class TxWitnesses extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {TxWitnesses}
         */
        static fromCbor(bytes: number[]): TxWitnesses;
        /**
         * Gets the list of `Signature` instances contained in this witness set.
         * @type {Signature[]}
         */
        get signatures(): Signature[];
        /**
         * Returns all the scripts, including the reference scripts
         * @type {(UplcProgram | NativeScript)[]}
         */
        get scripts(): (UplcProgram | NativeScript)[];
        /**
         * @type {Redeemer[]}
         */
        get redeemers(): Redeemer[];
        /**
         * @type {ListData}
         */
        get datums(): ListData;
        /**
         * @param {ValidatorHash | MintingPolicyHash} h
         * @returns {boolean}
         */
        isNativeScript(h: ValidatorHash | MintingPolicyHash): boolean;
        /**
         * @internal
         * @returns {boolean}
         */
        anyScriptCallsTxTimeRange(): boolean;
        /**
         * Throws error if signatures are incorrect
         * @internal
         * @param {number[]} bodyBytes
         */
        verifySignatures(bodyBytes: number[]): void;
        /**
         * @param {null | NetworkParams} params
         * @param {null | TxBody} body
         * @returns {Object}
         */
        dump(params?: null | NetworkParams, body?: null | TxBody): any;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @returns {bigint}
         */
        estimateFee(networkParams: NetworkParams): bigint;
        /**
         * @internal
         * @param {Signature} signature
         */
        addSignature(signature: Signature): void;
        /**
         * @internal
         * @param {number} n
         */
        addDummySignatures(n: number): void;
        /**
         * @internal
         */
        removeDummySignatures(): void;
        /**
         * Index is calculated later
         * @internal
         * @param {TxInput} input
         * @param {UplcData} redeemerData
         */
        addSpendingRedeemer(input: TxInput, redeemerData: UplcData): void;
        /**
         * @internal
         * @param {MintingPolicyHash} mph
         * @param {UplcData} redeemerData
         */
        addMintingRedeemer(mph: MintingPolicyHash, redeemerData: UplcData): void;
        /**
         * @internal
         * @param {UplcData} data
         */
        addDatumData(data: UplcData): void;
        /**
         * @internal
         * @param {NativeScript} script
         */
        attachNativeScript(script: NativeScript): void;
        /**
         * @internal
         * @param {UplcProgram} script
         */
        attachRefScript(script: UplcProgram): void;
        /**
         * Throws error if script was already added before.
         * @internal
         * @param {UplcProgram} program
         * @param {boolean} isRef
         */
        attachPlutusScript(program: UplcProgram, isRef?: boolean): void;
        /**
         * Retrieves either a regular script or a reference script.
         * @internal
         * @param {Hash} scriptHash - can be ValidatorHash or MintingPolicyHash
         * @returns {UplcProgram}
         */
        getUplcProgram(scriptHash: Hash): UplcProgram;
        /**
         * @internal
         * @param {TxBody} body
         */
        updateRedeemerIndices(body: TxBody): void;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @returns {Hash | null} - returns null if there are no redeemers
         */
        calcScriptDataHash(networkParams: NetworkParams): Hash | null;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxBody} body
         * @param {Redeemer} redeemer
         * @param {UplcData} scriptContext
         * @returns {Promise<Profile>}
         */
        executeRedeemer(networkParams: NetworkParams, body: TxBody, redeemer: Redeemer, scriptContext: UplcData): Promise<Profile>;
        /**
         * Executes the redeemers in order to calculate the necessary ex units
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxBody} body - needed in order to create correct ScriptContexts
         * @param {Address} changeAddress - needed for dummy input and dummy output
         * @returns {Promise<void>}
         */
        executeScripts(networkParams: NetworkParams, body: TxBody, changeAddress: Address): Promise<void>;
        /**
         * @internal
         * @param {TxBody} body
         */
        executeNativeScripts(body: TxBody): void;
        /**
         * Executes the redeemers in order to calculate the necessary ex units
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxBody} body - needed in order to create correct ScriptContexts
         * @param {Address} changeAddress - needed for dummy input and dummy output
         * @returns {Promise<void>}
         */
        executeRedeemers(networkParams: NetworkParams, body: TxBody, changeAddress: Address): Promise<void>;
        /**
         * Reruns all the redeemers to make sure the ex budgets are still correct (can change due to outputs added during rebalancing)
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxBody} body
         */
        checkExecutionBudgets(networkParams: NetworkParams, body: TxBody): Promise<void>;
        /**
         * Throws error if execution budget is exceeded
         * @internal
         * @param {NetworkParams} networkParams
         */
        checkExecutionBudgetLimits(networkParams: NetworkParams): void;
        /**
         * Compiles a report of each redeemer execution.
         * Only works after the tx has been finalized.
         * @type {string}
         */
        get profileReport(): string;
        #private;
    }
    /**
     * TxInput base-type
     */
    export class TxInput extends CborData {
        /**
         * @internal
         * @param {UplcData} data
         * @returns {TxInput}
         */
        static fromUplcData(data: UplcData): TxInput;
        /**
         * Deserializes TxOutput format used by wallet connector
         * @param {string | number[]} rawBytes
         * @returns {TxInput}
         */
        static fromFullCbor(rawBytes: string | number[]): TxInput;
        /**
         * @param {string | number[]} rawBytes
         * @returns {TxInput}
         */
        static fromCbor(rawBytes: string | number[]): TxInput;
        /**
         * Tx inputs must be ordered.
         * The following function can be used directly by a js array sort
         * @internal
         * @param {TxInput} a
         * @param {TxInput} b
         * @returns {number}
         */
        static comp(a: TxInput, b: TxInput): number;
        /**
         * @param {TxInput[]} inputs
         * @returns {Value}
         */
        static sumValue(inputs: TxInput[]): Value;
        /**
         * @param {TxOutputId} outputId
         * @param {null | TxOutput} output - used during building, not part of serialization
         */
        constructor(outputId: TxOutputId, output?: null | TxOutput);
        /**
         * @readonly
         * @type {TxOutputId}
         */
        readonly outputId: TxOutputId;
        /**
         * @deprecated
         * @type {TxId}
         */
        get txId(): TxId;
        /**
         * @deprecated
         * @type {number}
         */
        get utxoIdx(): number;
        /**
         *
         * @param {TxInput} other
         * @returns {boolean}
         */
        eq(other: TxInput): boolean;
        /**
         * @internal
         * @returns {boolean}
         */
        hasOrigOutput(): boolean;
        /**
         * @internal
         * @param {TxOutput} output
         */
        setOrigOutput(output: TxOutput): void;
        /**
         *
         * @type {TxOutput}
         */
        get output(): TxOutput;
        /**
         * Backward compatible alias for `TxInput.output`
         * @type {TxOutput}
         */
        get origOutput(): TxOutput;
        /**
         * Shortcut
         * @type {Value}
         */
        get value(): Value;
        /**
         * Shortcut
         * @type {Address}
         */
        get address(): Address;
        /**
         * @internal
         * @returns {ConstrData}
         */
        toOutputIdData(): ConstrData;
        /**
         * @internal
         * @returns {ConstrData}
         */
        toData(): ConstrData;
        /**
         * @returns {number[]}
         */
        toFullCbor(): number[];
        /**
         * @returns {Object}
         */
        dump(): any;
        #private;
    }
    /**
     * Use TxInput instead
     * @deprecated
     */
    export class UTxO extends TxInput {
    }
    /**
     * Use TxInput instead
     * @deprecated
     */
    export class TxRefInput extends TxInput {
    }
    /**
     * Represents a transaction output that is used when building a transaction.
     */
    export class TxOutput extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {TxOutput}
         */
        static fromCbor(bytes: number[]): TxOutput;
        /**
         * @param {UplcData} data
         * @returns {TxOutput}
         */
        static fromUplcData(data: UplcData): TxOutput;
        /**
         * Constructs a `TxOutput` instance using an `Address`, a `Value`, an optional `Datum`, and optional `UplcProgram` reference script.
         * @param {Address} address
         * @param {Value} value
         * @param {null | Datum} datum
         * @param {null | UplcProgram} refScript
         */
        constructor(address: Address, value: Value, datum?: null | Datum, refScript?: null | UplcProgram);
        /**
         * Get the `Address` to which the `TxOutput` will be sent.
         * @type {Address}
         */
        get address(): Address;
        /**
         * Mutation is handy when correctin the quantity of lovelace in a utxo
         * @param {Address} addr
         */
        setAddress(addr: Address): void;
        /**
         * Get the `Value` contained in the `TxOutput`.
         * @type {Value}
         */
        get value(): Value;
        /**
         * Mutation is handy when correcting the quantity of lovelace in a utxo
         * @param {Value} val
         */
        setValue(val: Value): void;
        /**
         * Get the optional `Datum` associated with the `TxOutput`.
         * @type {null | Datum}
         */
        get datum(): Datum | null;
        /**
         * Mutation is handy when correctin the quantity of lovelace in a utxo
         * @param {Datum} datum
         */
        setDatum(datum: Datum): void;
        /**
         * @returns {UplcData}
         */
        getDatumData(): UplcData;
        /**
         * @type {null | UplcProgram}
         */
        get refScript(): UplcProgram | null;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @returns {ConstrData}
         */
        toData(): ConstrData;
        /**
         * Each UTxO must contain some minimum quantity of lovelace to avoid that the blockchain is used for data storage.
         * @param {NetworkParams} networkParams
         * @returns {bigint}
         */
        calcMinLovelace(networkParams: NetworkParams): bigint;
        /**
         * Makes sure the `TxOutput` contains the minimum quantity of lovelace.
         * The network requires this to avoid the creation of unusable dust UTxOs.
         *
         * Optionally an update function can be specified that allows mutating the datum of the `TxOutput` to account for an increase of the lovelace quantity contained in the value.
         * @param {NetworkParams} networkParams
         * @param {null | ((output: TxOutput) => void)} updater
         */
        correctLovelace(networkParams: NetworkParams, updater?: ((output: TxOutput) => void) | null): void;
        #private;
    }
    /**
     * A `DCert` represents a staking action (eg. withdrawing rewards, delegating to another pool).
     */
    export class DCert extends CborData {
        /**
         * @param {string | number[]} raw
         * @returns {DCert}
         */
        static fromCbor(raw: string | number[]): DCert;
        /**
         * `DCertProps.type` can be:
         *     `0` for stake registration
         *     `1` for stake de-registration
         *     `2` for stake delegation
         *     `3` for stake pool registration (not yet implemented)
         *     `4` for stake pool retirement (not yet implemented)
         *     `5` for genesis key delegation (not yet implemented)
         *     `6` for moving instantaneous rewards (not yet implemented)
         *
         * `DCertProps.credential.type` can be:
         *     `0` for staking address key hash
         *     `1` for staking validator key hash (script hash)
         *
         * `DCertProps.poolHash` is needed only for stake delegation.
         * @typedef {{
         *   type: 0 | 1 | 2,
         *   credential: {
         *     type: 0 | 1,
         *     hash: string
         *   },
         *   poolHash?: string
         * }} DCertProps
         */
        /**
         * Create a DCert from a given json parameter.
         * @param {string | DCertProps} json
         * @returns {DCert}
         */
        static fromJson(json: string | {
            type: 0 | 1 | 2;
            credential: {
                type: 0 | 1;
                hash: string;
            };
            poolHash?: string | undefined;
        }): DCert;
        /**
         * @param {UplcData} data
         * @returns {DCert}
         */
        static fromUplcData(data: UplcData): DCert;
        /**
         * @param {number} certType
         */
        constructor(certType: number);
        /**
         * Get certificate type.
         * @type {number}
         */
        get certType(): number;
        /**
         * Get stake hash.
         * @type {PubKeyHash | StakingValidatorHash}
         */
        get stakeHash(): PubKeyHash | StakingValidatorHash;
        /**
         * Get stake credential type.
         * @type {number}
         */
        get credentialType(): number;
        /**
         * @returns {number[]}
         */
        typeToCbor(): number[];
        /**
         * @returns {ConstrData}
         */
        toData(): ConstrData;
        /**
         * @returns {Object}
         */
        dump(): any;
        #private;
    }
    /**
     * @internal
     */
    export class DCertRegister extends DCert {
        /**
         * @param {PubKeyHash | StakingValidatorHash} stakeHash
         */
        constructor(stakeHash: PubKeyHash | StakingValidatorHash);
        #private;
    }
    /**
     * @internal
     */
    export class DCertDeregister extends DCert {
        /**
         * @param {PubKeyHash | StakingValidatorHash} stakeHash
         */
        constructor(stakeHash: PubKeyHash | StakingValidatorHash);
        #private;
    }
    /**
     * @internal
     */
    export class DCertDelegate extends DCert {
        /**
         * @param {PubKeyHash | StakingValidatorHash} stakeHash
         * @param {PubKeyHash} poolHash
         */
        constructor(stakeHash: PubKeyHash | StakingValidatorHash, poolHash: PubKeyHash);
        /**
         * Get stake pool hash.
         * @type {PubKeyHash}
         */
        get poolHash(): PubKeyHash;
        #private;
    }
    /**
     * @internal
     */
    export class DCertRegisterPool extends DCert {
    }
    /**
     * @internal
     */
    export class DCertRetirePool extends DCert {
    }
    /**
     * Wrapper for Cardano stake address bytes. An StakeAddress consists of two parts internally:
     *   - Header (1 byte, see CIP 8)
     *   - Staking witness hash (28 bytes that represent the `PubKeyHash` or `StakingValidatorHash`)
     *
     * Stake addresses are used to query the assets held by given staking credentials.
     */
    export class StakeAddress {
        /**
         * Returns `true` if the given `StakeAddress` is a testnet address.
         * @param {StakeAddress} sa
         * @returns {boolean}
         */
        static isForTestnet(sa: StakeAddress): boolean;
        /**
         * Convert a regular `Address` into a `StakeAddress`.
         * Throws an error if the Address doesn't have a staking credential.
         * @param {Address} addr
         * @returns {StakeAddress}
         */
        static fromAddress(addr: Address): StakeAddress;
        /**
         * @param {number[]} bytes
         * @returns {StakeAddress}
         */
        static fromCbor(bytes: number[]): StakeAddress;
        /**
         * @param {string} str
         * @returns {StakeAddress}
         */
        static fromBech32(str: string): StakeAddress;
        /**
         * Doesn't check validity
         * @param {string} hex
         * @returns {StakeAddress}
         */
        static fromHex(hex: string): StakeAddress;
        /**
         * Address with only staking part (regular PubKeyHash)
         * @internal
         * @param {boolean} isTestnet
         * @param {PubKeyHash} hash
         * @returns {StakeAddress}
         */
        static fromPubKeyHash(isTestnet: boolean, hash: PubKeyHash): StakeAddress;
        /**
         * Address with only staking part (script StakingValidatorHash)
         * @internal
         * @param {boolean} isTestnet
         * @param {StakingValidatorHash} hash
         * @returns {StakeAddress}
         */
        static fromStakingValidatorHash(isTestnet: boolean, hash: StakingValidatorHash): StakeAddress;
        /**
         * Converts a `PubKeyHash` or `StakingValidatorHash` into `StakeAddress`.
         * @param {boolean} isTestnet
         * @param {PubKeyHash | StakingValidatorHash} hash
         * @returns {StakeAddress}
         */
        static fromHash(isTestnet: boolean, hash: PubKeyHash | StakingValidatorHash): StakeAddress;
        /**
         * @param {number[]} bytes
         */
        constructor(bytes: number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * Converts a `StakeAddress` into its CBOR representation.
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * Converts a `StakeAddress` into its Bech32 representation.
         * @returns {string}
         */
        toBech32(): string;
        /**
         * Converts a `StakeAddress` into its hexadecimal representation.
         * @returns {string}
         */
        toHex(): string;
        /**
         * Converts a `StakeAddress` into its hexadecimal representation.
         * @type {string}
         */
        get hex(): string;
        /**
         * Returns the underlying `PubKeyHash` or `StakingValidatorHash`.
         * @returns {PubKeyHash | StakingValidatorHash}
         */
        get stakingHash(): PubKeyHash | StakingValidatorHash;
        #private;
    }
    /**
     * Represents a Ed25519 signature.
     *
     * Also contains a reference to the PubKey that did the signing.
     */
    export class Signature extends CborData {
        /**
         * @returns {Signature}
         */
        static dummy(): Signature;
        /**
         * @param {number[]} bytes
         * @returns {Signature}
         */
        static fromCbor(bytes: number[]): Signature;
        /**
         * @param {number[] | PubKey} pubKey
         * @param {number[]} signature
         */
        constructor(pubKey: number[] | PubKey, signature: number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {PubKey}
         */
        get pubKey(): PubKey;
        /**
         * @type {PubKeyHash}
         */
        get pubKeyHash(): PubKeyHash;
        /**
         * @returns {boolean}
         */
        isDummy(): boolean;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * Throws error if incorrect
         * @param {number[]} msg
         */
        verify(msg: number[]): void;
        #private;
    }
    /**
     * @interface
     * @typedef {object} PrivateKey
     * @property {() => PubKey} derivePubKey Generates the corresponding public key.
     * @property {(msg: number[]) => Signature} sign Signs a byte-array payload, returning the signature.
     */
    /**
     * @implements {PrivateKey}
     */
    export class Ed25519PrivateKey extends HeliosData implements PrivateKey {
        /**
         * Generate a private key from a random number generator.
         * This is not cryptographically secure, only use this for testing purpose
         * @param {NumberGenerator} random
         * @returns {Ed25519PrivateKey} - Ed25519 private key is 32 bytes long
         */
        static random(random: NumberGenerator): Ed25519PrivateKey;
        /**
         * @param {string | number[]} bytes
         */
        constructor(bytes: string | number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {string}
         */
        get hex(): string;
        /**
         * NOT the Ed25519-Bip32 hierarchial extension algorithm (see ExtendedPrivateKey below)
         * @returns {Ed25519PrivateKey}
         */
        extend(): Ed25519PrivateKey;
        /**
         * @returns {PubKey}
         */
        derivePubKey(): PubKey;
        /**
         * @param {number[]} message
         * @returns {Signature}
         */
        sign(message: number[]): Signature;
        #private;
    }
    /**
     * Used during `Bip32PrivateKey` derivation, to create a new `Bip32PrivateKey` instance with a non-publicly deriveable `PubKey`.
     */
    export const BIP32_HARDEN: 2147483648;
    /**
     * Ed25519-Bip32 extendable `PrivateKey`.
     * @implements {PrivateKey}
     */
    export class Bip32PrivateKey implements PrivateKey {
        /**
         * Generate a Bip32PrivateKey from a random number generator.
         * This is not cryptographically secure, only use this for testing purpose
         * @param {NumberGenerator} random
         * @returns {Bip32PrivateKey}
         */
        static random(random?: NumberGenerator): Bip32PrivateKey;
        /**
         * @param {number[]} entropy
         * @param {boolean} force
         */
        static fromBip39Entropy(entropy: number[], force?: boolean): Bip32PrivateKey;
        /**
         * @param {number[]} bytes
         */
        constructor(bytes: number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @private
         * @type {number[]}
         */
        private get k();
        /**
         * @private
         * @type {number[]}
         */
        private get kl();
        /**
         * @private
         * @type {number[]}
         */
        private get kr();
        /**
         * @private
         * @type {number[]}
         */
        private get c();
        /**
         * @private
         * @param {number} i - child index
         */
        private calcChildZ;
        /**
         * @private
         * @param {number} i
         */
        private calcChildC;
        /**
         * @param {number} i
         * @returns {Bip32PrivateKey}
         */
        derive(i: number): Bip32PrivateKey;
        /**
         * @param {number[]} path
         * @returns {Bip32PrivateKey}
         */
        derivePath(path: number[]): Bip32PrivateKey;
        /**
         * @returns {PubKey}
         */
        derivePubKey(): PubKey;
        /**
         * @example
         * (new Bip32PrivateKey([0x60, 0xd3, 0x99, 0xda, 0x83, 0xef, 0x80, 0xd8, 0xd4, 0xf8, 0xd2, 0x23, 0x23, 0x9e, 0xfd, 0xc2, 0xb8, 0xfe, 0xf3, 0x87, 0xe1, 0xb5, 0x21, 0x91, 0x37, 0xff, 0xb4, 0xe8, 0xfb, 0xde, 0xa1, 0x5a, 0xdc, 0x93, 0x66, 0xb7, 0xd0, 0x03, 0xaf, 0x37, 0xc1, 0x13, 0x96, 0xde, 0x9a, 0x83, 0x73, 0x4e, 0x30, 0xe0, 0x5e, 0x85, 0x1e, 0xfa, 0x32, 0x74, 0x5c, 0x9c, 0xd7, 0xb4, 0x27, 0x12, 0xc8, 0x90, 0x60, 0x87, 0x63, 0x77, 0x0e, 0xdd, 0xf7, 0x72, 0x48, 0xab, 0x65, 0x29, 0x84, 0xb2, 0x1b, 0x84, 0x97, 0x60, 0xd1, 0xda, 0x74, 0xa6, 0xf5, 0xbd, 0x63, 0x3c, 0xe4, 0x1a, 0xdc, 0xee, 0xf0, 0x7a])).sign(textToBytes("Hello World")).bytes == [0x90, 0x19, 0x4d, 0x57, 0xcd, 0xe4, 0xfd, 0xad, 0xd0, 0x1e, 0xb7, 0xcf, 0x16, 0x17, 0x80, 0xc2, 0x77, 0xe1, 0x29, 0xfc, 0x71, 0x35, 0xb9, 0x77, 0x79, 0xa3, 0x26, 0x88, 0x37, 0xe4, 0xcd, 0x2e, 0x94, 0x44, 0xb9, 0xbb, 0x91, 0xc0, 0xe8, 0x4d, 0x23, 0xbb, 0xa8, 0x70, 0xdf, 0x3c, 0x4b, 0xda, 0x91, 0xa1, 0x10, 0xef, 0x73, 0x56, 0x38, 0xfa, 0x7a, 0x34, 0xea, 0x20, 0x46, 0xd4, 0xbe, 0x04]
         * @param {number[]} message
         * @returns {Signature}
         */
        sign(message: number[]): Signature;
        #private;
    }
    /**
     * @implements {PrivateKey}
     */
    export class RootPrivateKey implements PrivateKey {
        /**
         * @param {string[]} phrase
         * @param {string[]} dict
         * @returns {boolean}
         */
        static isValidPhrase(phrase: string[], dict?: string[]): boolean;
        /**
         * @param {string[]} phrase
         * @param {string[]} dict
         * @returns {RootPrivateKey}
         */
        static fromPhrase(phrase: string[], dict?: string[]): RootPrivateKey;
        /**
         * @param {number[]} entropy
         */
        constructor(entropy: number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {number[]}
         */
        get entropy(): number[];
        /**
         * @param {string[]} dict
         * @returns {string[]}
         */
        toPhrase(dict?: string[]): string[];
        /**
         * @param {number} i - childIndex
         * @returns {Bip32PrivateKey}
         */
        derive(i: number): Bip32PrivateKey;
        /**
         * @param {number[]} path
         * @returns {Bip32PrivateKey}
         */
        derivePath(path: number[]): Bip32PrivateKey;
        /**
         * @param {number} accountIndex
         * @returns {Bip32PrivateKey}
         */
        deriveSpendingRootKey(accountIndex?: number): Bip32PrivateKey;
        /**
         * @param {number} accountIndex
         * @returns {Bip32PrivateKey}
         */
        deriveStakingRootKey(accountIndex: number): Bip32PrivateKey;
        /**
         * @param {number} accountIndex
         * @param {number} i
         * @returns {Bip32PrivateKey}
         */
        deriveSpendingKey(accountIndex?: number, i?: number): Bip32PrivateKey;
        /**
         * @param {number} accountIndex
         * @param {number} i
         * @returns {Bip32PrivateKey}
         */
        deriveStakingKey(accountIndex?: number, i?: number): Bip32PrivateKey;
        /**
         * @returns {PubKey}
         */
        derivePubKey(): PubKey;
        /**
         * @param {number[]} message
         * @returns {Signature}
         */
        sign(message: number[]): Signature;
        #private;
    }
    /**
     * Base-type of SpendingRedeemer and MintingRedeemer
     */
    export class Redeemer extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {Redeemer}
         */
        static fromCbor(bytes: number[]): Redeemer;
        /**
         * @param {UplcData} data
         * @param {Profile} profile
         */
        constructor(data: UplcData, profile?: Profile);
        /**
         * @type {UplcData}
         */
        get data(): UplcData;
        /**
         * @type {bigint}
         */
        get memCost(): bigint;
        /**
         * @type {bigint}
         */
        get cpuCost(): bigint;
        /**
         * @param {string} name
         */
        setProgramName(name: string): void;
        /**
         * @type {null | string}
         */
        get programName(): string | null;
        /**
         * type:
         *   0 -> spending
         *   1 -> minting
         *   2 -> certifying
         *   3 -> rewarding
         * @param {number} type
         * @param {number} index
         * @returns {number[]}
         */
        toCborInternal(type: number, index: number): number[];
        /**
         * @returns {Object}
         */
        dumpInternal(): any;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @param {TxBody} body
         * @returns {ConstrData}
         */
        toScriptPurposeData(body: TxBody): ConstrData;
        /**
         * @param {TxBody} body
         */
        updateIndex(body: TxBody): void;
        /**
         * @param {Profile} profile
         */
        setProfile(profile: Profile): void;
        /**
         * @type {Profile}
         */
        get profile(): Profile;
        /**
         * @param {NetworkParams} networkParams
         * @returns {bigint}
         */
        estimateFee(networkParams: NetworkParams): bigint;
        #private;
    }
    export class SpendingRedeemer extends Redeemer {
        /**
         * @param {null | TxInput} input
         * @param {number} inputIndex
         * @param {UplcData} data
         * @param {Cost} exUnits
         */
        constructor(input: null | TxInput, inputIndex: number, data: UplcData, exUnits?: Cost);
        /**
         * @type {number}
         */
        get inputIndex(): number;
        #private;
    }
    export class MintingRedeemer extends Redeemer {
        /**
         * @param {?MintingPolicyHash} mph
         * @param {number} mphIndex
         * @param {UplcData} data
         * @param {Cost} exUnits
         */
        constructor(mph: MintingPolicyHash | null, mphIndex: number, data: UplcData, exUnits?: Cost);
        /**
         * @type {number}
         */
        get mphIndex(): number;
        #private;
    }
    /**
     * Represents either an inline datum, or a hashed datum.
     *
     * Inside the Helios language this type is named `OutputDatum` in order to distinguish it from user defined Datums,
     * But outside helios scripts there isn't much sense to keep using the name 'OutputDatum' instead of Datum.
     */
    export class Datum extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {Datum}
         */
        static fromCbor(bytes: number[]): Datum;
        /**
         * @param {UplcData} data
         * @returns {null | Datum}
         */
        static fromUplcData(data: UplcData): null | Datum;
        /**
         * Constructs a `HashedDatum`. The input data is hashed internally.
         * @param {UplcDataValue | UplcData | HeliosData} data
         * @returns {Datum}
         */
        static hashed(data: UplcDataValue | UplcData | HeliosData): Datum;
        /**
         * @param {UplcDataValue | UplcData | HeliosData} data
         * @returns {Datum}
         */
        static inline(data: UplcDataValue | UplcData | HeliosData): Datum;
        /**
         * @returns {boolean}
         */
        isInline(): boolean;
        /**
         * @returns {boolean}
         */
        isHashed(): boolean;
        /**
         * @type {DatumHash}
         */
        get hash(): DatumHash;
        /**
         * @type {?UplcData}
         */
        get data(): UplcData | null;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @returns {ConstrData}
         */
        toData(): ConstrData;
    }
    /**
     * Inside helios this type is named OutputDatum::Hash in order to distinguish it from the user defined Datum,
     * but outside helios scripts there isn't much sense to keep using the name 'OutputDatum' instead of Datum
     */
    export class HashedDatum extends Datum {
        /**
         * Constructs a `HashedDatum`. The input data is hashed internally.
         * @param {UplcData} data
         * @returns {HashedDatum}
         */
        static fromData(data: UplcData): HashedDatum;
        /**
         * @param {DatumHash} hash
         * @param {null | UplcData} origData
         */
        constructor(hash: DatumHash, origData?: null | UplcData);
        #private;
    }
    export class TxMetadata {
        /**
        * Decodes a TxMetadata instance from Cbor
        * @param {number[]} data
        * @returns {TxMetadata}
        */
        static fromCbor(data: number[]): TxMetadata;
        /**
         *
         * @param {number} tag
         * @param {Metadata} data
         */
        add(tag: number, data: Metadata): void;
        /**
         * @type {number[]}
         */
        get keys(): number[];
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @returns {number[]}
         */
        toCbor(): number[];
        #private;
    }
    export namespace CoinSelection {
        function selectExtremumFirst(utxos: TxInput[], amount: Value, largestFirst: boolean): [TxInput[], TxInput[]];
        const selectSmallestFirst: CoinSelectionAlgorithm;
        const selectLargestFirst: CoinSelectionAlgorithm;
    }
    /**
     * An interface type for a wallet that manages a user's UTxOs and addresses.
     * @interface
     * @typedef {object} Wallet
    *  @property {() => Promise<boolean>} isMainnet Returns `true` if the wallet is connected to the mainnet.
    *  @property {Promise<Address[]>} usedAddresses Returns a list of addresses which already contain UTxOs.
    *  @property {Promise<Address[]>} unusedAddresses Returns a list of unique unused addresses which can be used to send UTxOs to with increased anonimity.
    *  @property {Promise<TxInput[]>} utxos Returns a list of all the utxos controlled by the wallet.
    *  @property {Promise<TxInput[]>} collateral
    *  @property {(tx: Tx) => Promise<Signature[]>} signTx Signs a transaction, returning a list of signatures needed for submitting a valid transaction.
    *  @property {(tx: Tx) => Promise<TxId>} submitTx Submits a transaction to the blockchain and returns the id of that transaction upon success.
    */
    /**
     * Convenience type for browser plugin wallets supporting the CIP 30 dApp connector standard (eg. Eternl, Nami, ...).
     *
     * This is useful in typescript projects to avoid type errors when accessing the handles in `window.cardano`.
     *
     * ```ts
     * // refer to this file in the 'typeRoots' list in tsconfig.json
     *
     * type Cip30SimpleHandle = {
     *   name: string,
     *   icon: string,
     *   enable(): Promise<helios.Cip30Handle>,
     *   isEnabled(): boolean
     * }
     *
     * declare global {
     *   interface Window {
     *     cardano: {
     *       [walletName: string]: Cip30SimpleHandle
     *     };
     *   }
     * }
     * ```
     *
     * @typedef {{
     *     getNetworkId(): Promise<number>,
     *     getUsedAddresses(): Promise<string[]>,
     *     getUnusedAddresses(): Promise<string[]>,
     *     getUtxos(): Promise<string[]>,
     *     getCollateral(): Promise<string[]>,
     *     signTx(txHex: string, partialSign: boolean): Promise<string>,
     *     submitTx(txHex: string): Promise<string>,
     *     experimental: {
     *         getCollateral(): Promise<string[]>
     *     },
     * }} Cip30Handle
     */
    /**
     * Implementation of `Wallet` that lets you connect to a browser plugin wallet.
     * @implements {Wallet}
     */
    export class Cip30Wallet implements Wallet {
        /**
         * Constructs Cip30Wallet using the Cip30Handle which is available in the browser window.cardano context.
         *
         * ```ts
         * const handle: helios.Cip30Handle = await window.cardano.eternl.enable()
         * const wallet = new helios.Cip30Wallet(handle)
         * ```
         * @param {Cip30Handle} handle
         */
        constructor(handle: Cip30Handle);
        /**
         * Returns `true` if the wallet is connected to the mainnet.
         * @returns {Promise<boolean>}
         */
        isMainnet(): Promise<boolean>;
        /**
         * Gets a list of addresses which contain(ed) UTxOs.
         * @type {Promise<Address[]>}
         */
        get usedAddresses(): Promise<Address[]>;
        /**
         * Gets a list of unique unused addresses which can be used to UTxOs to.
         * @type {Promise<Address[]>}
         */
        get unusedAddresses(): Promise<Address[]>;
        /**
         * Gets the complete list of UTxOs (as `TxInput` instances) sitting at the addresses owned by the wallet.
         * @type {Promise<TxInput[]>}
         */
        get utxos(): Promise<TxInput[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get collateral(): Promise<TxInput[]>;
        /**
         * Signs a transaction, returning a list of signatures needed for submitting a valid transaction.
         * @param {Tx} tx
         * @returns {Promise<Signature[]>}
         */
        signTx(tx: Tx): Promise<Signature[]>;
        /**
         * Submits a transaction to the blockchain.
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * High-level helper class for instances that implement the `Wallet` interface.
     */
    export class WalletHelper {
        /**
         * @param {Wallet} wallet
         * @param {undefined | ((addr: Address[]) => Promise<TxInput[]>)} getUtxosFallback
         */
        constructor(wallet: Wallet, getUtxosFallback?: ((addr: Address[]) => Promise<TxInput[]>) | undefined);
        /**
         * Concatenation of `usedAddresses` and `unusedAddresses`.
         * @type {Promise<Address[]>}
         */
        get allAddresses(): Promise<Address[]>;
        /**
         * @returns {Promise<Value>}
         */
        calcBalance(): Promise<Value>;
        /**
         * First `Address` in `allAddresses`.
         * @type {Promise<Address>}
         */
        get baseAddress(): Promise<Address>;
        /**
         * First `Address` in `unusedAddresses` (falls back to last `Address` in `usedAddresses` if not defined).
         * @type {Promise<Address>}
         */
        get changeAddress(): Promise<Address>;
        /**
         * First UTxO in `utxos`. Can be used to distinguish between preview and preprod networks.
         * @type {Promise<null | TxInput>}
         */
        get refUtxo(): Promise<TxInput | null>;
        /**
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(): Promise<TxInput[]>;
        /**
         * Pick a number of UTxOs needed to cover a given Value. The default coin selection strategy is to pick the smallest first.
         * @param {Value} amount
         * @param {CoinSelectionAlgorithm} algorithm
         * @returns {Promise<[TxInput[], TxInput[]]>} The first list contains the selected UTxOs, the second list contains the remaining UTxOs.
         */
        pickUtxos(amount: Value, algorithm?: CoinSelectionAlgorithm): Promise<[TxInput[], TxInput[]]>;
        /**
         * Picks a single UTxO intended as collateral.
         * @param {bigint} amount - 2 Ada should cover most things
         * @returns {Promise<TxInput>}
         */
        pickCollateral(amount?: bigint): Promise<TxInput>;
        /**
         * Returns `true` if the `PubKeyHash` in the given `Address` is controlled by the wallet.
         * @param {Address} addr
         * @returns {Promise<boolean>}
         */
        isOwnAddress(addr: Address): Promise<boolean>;
        /**
         * Returns `true` if the given `PubKeyHash` is controlled by the wallet.
         * @param {PubKeyHash} pkh
         * @returns {Promise<boolean>}
         */
        isOwnPubKeyHash(pkh: PubKeyHash): Promise<boolean>;
        /**
         * @returns {Promise<any>}
         */
        toJson(): Promise<any>;
        #private;
    }
    /**
     * @implements {Wallet}
     */
    export class RemoteWallet implements Wallet {
        /**
         * @param {string | Object} obj
         * @returns {RemoteWallet}
         */
        static fromJson(obj: string | any): RemoteWallet;
        /**
         * @param {boolean} isMainnet
         * @param {Address[]} usedAddresses
         * @param {Address[]} unusedAddresses
         * @param {TxInput[]} utxos
         */
        constructor(isMainnet: boolean, usedAddresses: Address[], unusedAddresses: Address[], utxos: TxInput[]);
        /**
         * @returns {Promise<boolean>}
         */
        isMainnet(): Promise<boolean>;
        /**
         * @type {Promise<Address[]>}
         */
        get usedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<Address[]>}
         */
        get unusedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get utxos(): Promise<TxInput[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get collateral(): Promise<TxInput[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<Signature[]>}
         */
        signTx(tx: Tx): Promise<Signature[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * Blockchain query interface.
     * @interface
     * @typedef {object} Network
     * @property {(address: Address) => Promise<TxInput[]>} getUtxos Returns a complete list of UTxOs at a given address.
     * @property {(id: TxOutputId) => Promise<TxInput>} getUtxo Returns a single TxInput (that might already have been spent).
     * @property {() => Promise<NetworkParams>} getParameters Returns the latest network parameters.
     * @property {(tx: Tx) => Promise<TxId>} submitTx Submits a transaction to the blockchain and returns the id of that transaction upon success.
     */
    /**
     * Blockfrost specific implementation of `Network`.
     * @implements {Network}
     */
    export class BlockfrostV0 implements Network {
        /**
         * Throws an error if a Blockfrost project_id is missing for that specific network.
         * @param {TxInput} refUtxo
         * @param {{
         *     preview?: string,
         *     preprod?: string,
         *     mainnet?: string
         * }} projectIds
         * @returns {Promise<BlockfrostV0>}
         */
        static resolveUsingUtxo(refUtxo: TxInput, projectIds: {
            preview?: string;
            preprod?: string;
            mainnet?: string;
        }): Promise<BlockfrostV0>;
        /**
         * Connects to the same network a given `Wallet` is connected to (preview, preprod or mainnet).
         *
         * Throws an error if a Blockfrost project_id is missing for that specific network.
         * @param {Wallet} wallet
         * @param {{
         *     preview?: string,
         *     preprod?: string,
         *     mainnet?: string
         * }} projectIds
         * @returns {Promise<BlockfrostV0>}
         */
        static resolveUsingWallet(wallet: Wallet, projectIds: {
            preview?: string;
            preprod?: string;
            mainnet?: string;
        }): Promise<BlockfrostV0>;
        /**
        * Connects to the same network a given `Wallet` or the given `TxInput` (preview, preprod or mainnet).
        *
        * Throws an error if a Blockfrost project_id is missing for that specific network.
        * @param {TxInput | Wallet} utxoOrWallet
        * @param {{
        *     preview?: string,
        *     preprod?: string,
        *     mainnet?: string
        * }} projectIds
        * @returns {Promise<BlockfrostV0>}
        */
        static resolve(utxoOrWallet: TxInput | Wallet, projectIds: {
            preview?: string;
            preprod?: string;
            mainnet?: string;
        }): Promise<BlockfrostV0>;
        /**
         * @internal
         * @param {{unit: string, quantity: string}[]} obj
         * @returns {Value}
         */
        static parseValue(obj: {
            unit: string;
            quantity: string;
        }[]): Value;
        /**
         * Constructs a BlockfrostV0 using the network name (preview, preprod or mainnet) and your Blockfrost `project_id`.
         * @param {"preview" | "preprod" | "mainnet"} networkName
         * @param {string} projectId
         */
        constructor(networkName: "preview" | "preprod" | "mainnet", projectId: string);
        /**
         * @type {string}
         */
        get networkName(): string;
        /**
         * @returns {Promise<NetworkParams>}
         */
        getParameters(): Promise<NetworkParams>;
        /**
         * @returns {Promise<any>}
         */
        getLatestEpoch(): Promise<any>;
        /**
         * If the UTxO isn't found an error is throw with the following message format: "UTxO <txId.utxoId> not found".
         * @param {TxOutputId} id
         * @returns {Promise<TxInput>}
         */
        getUtxo(id: TxOutputId): Promise<TxInput>;
        /**
         * Used by `BlockfrostV0.resolve()`.
         * @param {TxInput} utxo
         * @returns {Promise<boolean>}
         */
        hasUtxo(utxo: TxInput): Promise<boolean>;
        /**
         * @internal
         * @param {{
         *   address: string
         *   tx_hash: string
         *   output_index: number
         *   amount: {unit: string, quantity: string}[]
         *   inline_datum: null | string
         *   data_hash: null | string
         *   collateral: boolean
         *   reference_script_hash: null | string
         * }} obj
         */
        restoreTxInput(obj: {
            address: string;
            tx_hash: string;
            output_index: number;
            amount: {
                unit: string;
                quantity: string;
            }[];
            inline_datum: null | string;
            data_hash: null | string;
            collateral: boolean;
            reference_script_hash: null | string;
        }): Promise<TxInput>;
        /**
         * Gets a complete list of UTxOs at a given `Address`.
         * Returns oldest UTxOs first, newest last.
         * @param {Address} address
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(address: Address): Promise<TxInput[]>;
        /**
         * Submits a transaction to the blockchain.
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        /**
         * Allows inspecting the live Blockfrost mempool.
         */
        dumpMempool(): Promise<void>;
        #private;
    }
    /**
     * Koios network interface.
     * @implements {Network}
     */
    export class KoiosV0 implements Network {
        /**
        * Throws an error if a Blockfrost project_id is missing for that specific network.
        * @param {TxInput} refUtxo
        * @returns {Promise<KoiosV0>}
        */
        static resolveUsingUtxo(refUtxo: TxInput): Promise<KoiosV0>;
        /**
         * @param {"preview" | "preprod" | "mainnet"} networkName
         */
        constructor(networkName: "preview" | "preprod" | "mainnet");
        /**
         * @private
         * @type {string}
         */
        private get rootUrl();
        /**
        * @returns {Promise<NetworkParams>}
        */
        getParameters(): Promise<NetworkParams>;
        /**
         * @private
         * @param {TxOutputId[]} ids
         * @returns {Promise<TxInput[]>}
         */
        private getUtxosInternal;
        /**
         * @param {TxOutputId} id
         * @returns {Promise<TxInput>}
         */
        getUtxo(id: TxOutputId): Promise<TxInput>;
        /**
        * Used by `KoiosV0.resolveUsingUtxo()`.
        * @param {TxInput} utxo
        * @returns {Promise<boolean>}
        */
        hasUtxo(utxo: TxInput): Promise<boolean>;
        /**
         * @param {Address} address
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(address: Address): Promise<TxInput[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    export namespace rawNetworkEmulatorParams {
        namespace shelleyGenesis {
            const activeSlotsCoeff: number;
            const epochLength: number;
            const genDelegs: {
                "637f2e950b0fd8f8e3e811c5fbeb19e411e7a2bf37272b84b29c1a0b": {
                    delegate: string;
                    vrf: string;
                };
                "8a4b77c4f534f8b8cc6f269e5ebb7ba77fa63a476e50e05e66d7051c": {
                    delegate: string;
                    vrf: string;
                };
                b00470cd193d67aac47c373602fccd4195aad3002c169b5570de1126: {
                    delegate: string;
                    vrf: string;
                };
                b260ffdb6eba541fcf18601923457307647dce807851b9d19da133ab: {
                    delegate: string;
                    vrf: string;
                };
                ced1599fd821a39593e00592e5292bdc1437ae0f7af388ef5257344a: {
                    delegate: string;
                    vrf: string;
                };
                dd2a7d71a05bed11db61555ba4c658cb1ce06c8024193d064f2a66ae: {
                    delegate: string;
                    vrf: string;
                };
                f3b9e74f7d0f24d2314ea5dfbca94b65b2059d1ff94d97436b82d5b4: {
                    delegate: string;
                    vrf: string;
                };
            };
            const initialFunds: {};
            const maxKESEvolutions: number;
            const maxLovelaceSupply: number;
            const networkId: string;
            const networkMagic: number;
            namespace protocolParams {
                const a0: number;
                const decentralisationParam: number;
                const eMax: number;
                namespace extraEntropy {
                    const tag: string;
                }
                const keyDeposit: number;
                const maxBlockBodySize: number;
                const maxBlockHeaderSize: number;
                const maxTxSize: number;
                const minFeeA: number;
                const minFeeB: number;
                const minPoolCost: number;
                const minUTxOValue: number;
                const nOpt: number;
                const poolDeposit: number;
                namespace protocolVersion {
                    const major: number;
                    const minor: number;
                }
                const rho: number;
                const tau: number;
            }
            const securityParam: number;
            const slotLength: number;
            const slotsPerKESPeriod: number;
            namespace staking {
                const pools: {};
                const stake: {};
            }
            const systemStart: string;
            const updateQuorum: number;
        }
        namespace alonzoGenesis {
            const lovelacePerUTxOWord: number;
            namespace executionPrices {
                namespace prSteps {
                    const numerator: number;
                    const denominator: number;
                }
                namespace prMem {
                    const numerator_1: number;
                    export { numerator_1 as numerator };
                    const denominator_1: number;
                    export { denominator_1 as denominator };
                }
            }
            namespace maxTxExUnits {
                const exUnitsMem: number;
                const exUnitsSteps: number;
            }
            namespace maxBlockExUnits {
                const exUnitsMem_1: number;
                export { exUnitsMem_1 as exUnitsMem };
                const exUnitsSteps_1: number;
                export { exUnitsSteps_1 as exUnitsSteps };
            }
            const maxValueSize: number;
            const collateralPercentage: number;
            const maxCollateralInputs: number;
            namespace costModels {
                const PlutusV1: {
                    "sha2_256-memory-arguments": number;
                    "equalsString-cpu-arguments-constant": number;
                    "cekDelayCost-exBudgetMemory": number;
                    "lessThanEqualsByteString-cpu-arguments-intercept": number;
                    "divideInteger-memory-arguments-minimum": number;
                    "appendByteString-cpu-arguments-slope": number;
                    "blake2b-cpu-arguments-slope": number;
                    "iData-cpu-arguments": number;
                    "encodeUtf8-cpu-arguments-slope": number;
                    "unBData-cpu-arguments": number;
                    "multiplyInteger-cpu-arguments-intercept": number;
                    "cekConstCost-exBudgetMemory": number;
                    "nullList-cpu-arguments": number;
                    "equalsString-cpu-arguments-intercept": number;
                    "trace-cpu-arguments": number;
                    "mkNilData-memory-arguments": number;
                    "lengthOfByteString-cpu-arguments": number;
                    "cekBuiltinCost-exBudgetCPU": number;
                    "bData-cpu-arguments": number;
                    "subtractInteger-cpu-arguments-slope": number;
                    "unIData-cpu-arguments": number;
                    "consByteString-memory-arguments-intercept": number;
                    "divideInteger-memory-arguments-slope": number;
                    "divideInteger-cpu-arguments-model-arguments-slope": number;
                    "listData-cpu-arguments": number;
                    "headList-cpu-arguments": number;
                    "chooseData-memory-arguments": number;
                    "equalsInteger-cpu-arguments-intercept": number;
                    "sha3_256-cpu-arguments-slope": number;
                    "sliceByteString-cpu-arguments-slope": number;
                    "unMapData-cpu-arguments": number;
                    "lessThanInteger-cpu-arguments-intercept": number;
                    "mkCons-cpu-arguments": number;
                    "appendString-memory-arguments-intercept": number;
                    "modInteger-cpu-arguments-model-arguments-slope": number;
                    "ifThenElse-cpu-arguments": number;
                    "mkNilPairData-cpu-arguments": number;
                    "lessThanEqualsInteger-cpu-arguments-intercept": number;
                    "addInteger-memory-arguments-slope": number;
                    "chooseList-memory-arguments": number;
                    "constrData-memory-arguments": number;
                    "decodeUtf8-cpu-arguments-intercept": number;
                    "equalsData-memory-arguments": number;
                    "subtractInteger-memory-arguments-slope": number;
                    "appendByteString-memory-arguments-intercept": number;
                    "lengthOfByteString-memory-arguments": number;
                    "headList-memory-arguments": number;
                    "listData-memory-arguments": number;
                    "consByteString-cpu-arguments-intercept": number;
                    "unIData-memory-arguments": number;
                    "remainderInteger-memory-arguments-minimum": number;
                    "bData-memory-arguments": number;
                    "lessThanByteString-cpu-arguments-slope": number;
                    "encodeUtf8-memory-arguments-intercept": number;
                    "cekStartupCost-exBudgetCPU": number;
                    "multiplyInteger-memory-arguments-intercept": number;
                    "unListData-memory-arguments": number;
                    "remainderInteger-cpu-arguments-model-arguments-slope": number;
                    "cekVarCost-exBudgetCPU": number;
                    "remainderInteger-memory-arguments-slope": number;
                    "cekForceCost-exBudgetCPU": number;
                    "sha2_256-cpu-arguments-slope": number;
                    "equalsInteger-memory-arguments": number;
                    "indexByteString-memory-arguments": number;
                    "addInteger-memory-arguments-intercept": number;
                    "chooseUnit-cpu-arguments": number;
                    "sndPair-cpu-arguments": number;
                    "cekLamCost-exBudgetCPU": number;
                    "fstPair-cpu-arguments": number;
                    "quotientInteger-memory-arguments-minimum": number;
                    "decodeUtf8-cpu-arguments-slope": number;
                    "lessThanInteger-memory-arguments": number;
                    "lessThanEqualsInteger-cpu-arguments-slope": number;
                    "fstPair-memory-arguments": number;
                    "modInteger-memory-arguments-intercept": number;
                    "unConstrData-cpu-arguments": number;
                    "lessThanEqualsInteger-memory-arguments": number;
                    "chooseUnit-memory-arguments": number;
                    "sndPair-memory-arguments": number;
                    "addInteger-cpu-arguments-intercept": number;
                    "decodeUtf8-memory-arguments-slope": number;
                    "equalsData-cpu-arguments-intercept": number;
                    "mapData-cpu-arguments": number;
                    "mkPairData-cpu-arguments": number;
                    "quotientInteger-cpu-arguments-constant": number;
                    "consByteString-memory-arguments-slope": number;
                    "cekVarCost-exBudgetMemory": number;
                    "indexByteString-cpu-arguments": number;
                    "unListData-cpu-arguments": number;
                    "equalsInteger-cpu-arguments-slope": number;
                    "cekStartupCost-exBudgetMemory": number;
                    "subtractInteger-cpu-arguments-intercept": number;
                    "divideInteger-cpu-arguments-model-arguments-intercept": number;
                    "divideInteger-memory-arguments-intercept": number;
                    "cekForceCost-exBudgetMemory": number;
                    "blake2b-cpu-arguments-intercept": number;
                    "remainderInteger-cpu-arguments-constant": number;
                    "tailList-cpu-arguments": number;
                    "encodeUtf8-cpu-arguments-intercept": number;
                    "equalsString-cpu-arguments-slope": number;
                    "lessThanByteString-memory-arguments": number;
                    "multiplyInteger-cpu-arguments-slope": number;
                    "appendByteString-cpu-arguments-intercept": number;
                    "lessThanEqualsByteString-cpu-arguments-slope": number;
                    "modInteger-memory-arguments-slope": number;
                    "addInteger-cpu-arguments-slope": number;
                    "equalsData-cpu-arguments-slope": number;
                    "decodeUtf8-memory-arguments-intercept": number;
                    "chooseList-cpu-arguments": number;
                    "constrData-cpu-arguments": number;
                    "equalsByteString-memory-arguments": number;
                    "cekApplyCost-exBudgetCPU": number;
                    "quotientInteger-memory-arguments-slope": number;
                    "verifySignature-cpu-arguments-intercept": number;
                    "unMapData-memory-arguments": number;
                    "mkCons-memory-arguments": number;
                    "sliceByteString-memory-arguments-slope": number;
                    "sha3_256-memory-arguments": number;
                    "ifThenElse-memory-arguments": number;
                    "mkNilPairData-memory-arguments": number;
                    "equalsByteString-cpu-arguments-slope": number;
                    "appendString-cpu-arguments-intercept": number;
                    "quotientInteger-cpu-arguments-model-arguments-slope": number;
                    "cekApplyCost-exBudgetMemory": number;
                    "equalsString-memory-arguments": number;
                    "multiplyInteger-memory-arguments-slope": number;
                    "cekBuiltinCost-exBudgetMemory": number;
                    "remainderInteger-memory-arguments-intercept": number;
                    "sha2_256-cpu-arguments-intercept": number;
                    "remainderInteger-cpu-arguments-model-arguments-intercept": number;
                    "lessThanEqualsByteString-memory-arguments": number;
                    "tailList-memory-arguments": number;
                    "mkNilData-cpu-arguments": number;
                    "chooseData-cpu-arguments": number;
                    "unBData-memory-arguments": number;
                    "blake2b-memory-arguments": number;
                    "iData-memory-arguments": number;
                    "nullList-memory-arguments": number;
                    "cekDelayCost-exBudgetCPU": number;
                    "subtractInteger-memory-arguments-intercept": number;
                    "lessThanByteString-cpu-arguments-intercept": number;
                    "consByteString-cpu-arguments-slope": number;
                    "appendByteString-memory-arguments-slope": number;
                    "trace-memory-arguments": number;
                    "divideInteger-cpu-arguments-constant": number;
                    "cekConstCost-exBudgetCPU": number;
                    "encodeUtf8-memory-arguments-slope": number;
                    "quotientInteger-cpu-arguments-model-arguments-intercept": number;
                    "mapData-memory-arguments": number;
                    "appendString-cpu-arguments-slope": number;
                    "modInteger-cpu-arguments-constant": number;
                    "verifySignature-cpu-arguments-slope": number;
                    "unConstrData-memory-arguments": number;
                    "quotientInteger-memory-arguments-intercept": number;
                    "equalsByteString-cpu-arguments-constant": number;
                    "sliceByteString-memory-arguments-intercept": number;
                    "mkPairData-memory-arguments": number;
                    "equalsByteString-cpu-arguments-intercept": number;
                    "appendString-memory-arguments-slope": number;
                    "lessThanInteger-cpu-arguments-slope": number;
                    "modInteger-cpu-arguments-model-arguments-intercept": number;
                    "modInteger-memory-arguments-minimum": number;
                    "sha3_256-cpu-arguments-intercept": number;
                    "verifySignature-memory-arguments": number;
                    "cekLamCost-exBudgetMemory": number;
                    "sliceByteString-cpu-arguments-intercept": number;
                };
            }
        }
        namespace latestParams {
            const collateralPercentage_1: number;
            export { collateralPercentage_1 as collateralPercentage };
            export namespace costModels_1 {
                const PlutusScriptV1: {
                    "addInteger-cpu-arguments-intercept": number;
                    "addInteger-cpu-arguments-slope": number;
                    "addInteger-memory-arguments-intercept": number;
                    "addInteger-memory-arguments-slope": number;
                    "appendByteString-cpu-arguments-intercept": number;
                    "appendByteString-cpu-arguments-slope": number;
                    "appendByteString-memory-arguments-intercept": number;
                    "appendByteString-memory-arguments-slope": number;
                    "appendString-cpu-arguments-intercept": number;
                    "appendString-cpu-arguments-slope": number;
                    "appendString-memory-arguments-intercept": number;
                    "appendString-memory-arguments-slope": number;
                    "bData-cpu-arguments": number;
                    "bData-memory-arguments": number;
                    "blake2b_256-cpu-arguments-intercept": number;
                    "blake2b_256-cpu-arguments-slope": number;
                    "blake2b_256-memory-arguments": number;
                    "cekApplyCost-exBudgetCPU": number;
                    "cekApplyCost-exBudgetMemory": number;
                    "cekBuiltinCost-exBudgetCPU": number;
                    "cekBuiltinCost-exBudgetMemory": number;
                    "cekConstCost-exBudgetCPU": number;
                    "cekConstCost-exBudgetMemory": number;
                    "cekDelayCost-exBudgetCPU": number;
                    "cekDelayCost-exBudgetMemory": number;
                    "cekForceCost-exBudgetCPU": number;
                    "cekForceCost-exBudgetMemory": number;
                    "cekLamCost-exBudgetCPU": number;
                    "cekLamCost-exBudgetMemory": number;
                    "cekStartupCost-exBudgetCPU": number;
                    "cekStartupCost-exBudgetMemory": number;
                    "cekVarCost-exBudgetCPU": number;
                    "cekVarCost-exBudgetMemory": number;
                    "chooseData-cpu-arguments": number;
                    "chooseData-memory-arguments": number;
                    "chooseList-cpu-arguments": number;
                    "chooseList-memory-arguments": number;
                    "chooseUnit-cpu-arguments": number;
                    "chooseUnit-memory-arguments": number;
                    "consByteString-cpu-arguments-intercept": number;
                    "consByteString-cpu-arguments-slope": number;
                    "consByteString-memory-arguments-intercept": number;
                    "consByteString-memory-arguments-slope": number;
                    "constrData-cpu-arguments": number;
                    "constrData-memory-arguments": number;
                    "decodeUtf8-cpu-arguments-intercept": number;
                    "decodeUtf8-cpu-arguments-slope": number;
                    "decodeUtf8-memory-arguments-intercept": number;
                    "decodeUtf8-memory-arguments-slope": number;
                    "divideInteger-cpu-arguments-constant": number;
                    "divideInteger-cpu-arguments-model-arguments-intercept": number;
                    "divideInteger-cpu-arguments-model-arguments-slope": number;
                    "divideInteger-memory-arguments-intercept": number;
                    "divideInteger-memory-arguments-minimum": number;
                    "divideInteger-memory-arguments-slope": number;
                    "encodeUtf8-cpu-arguments-intercept": number;
                    "encodeUtf8-cpu-arguments-slope": number;
                    "encodeUtf8-memory-arguments-intercept": number;
                    "encodeUtf8-memory-arguments-slope": number;
                    "equalsByteString-cpu-arguments-constant": number;
                    "equalsByteString-cpu-arguments-intercept": number;
                    "equalsByteString-cpu-arguments-slope": number;
                    "equalsByteString-memory-arguments": number;
                    "equalsData-cpu-arguments-intercept": number;
                    "equalsData-cpu-arguments-slope": number;
                    "equalsData-memory-arguments": number;
                    "equalsInteger-cpu-arguments-intercept": number;
                    "equalsInteger-cpu-arguments-slope": number;
                    "equalsInteger-memory-arguments": number;
                    "equalsString-cpu-arguments-constant": number;
                    "equalsString-cpu-arguments-intercept": number;
                    "equalsString-cpu-arguments-slope": number;
                    "equalsString-memory-arguments": number;
                    "fstPair-cpu-arguments": number;
                    "fstPair-memory-arguments": number;
                    "headList-cpu-arguments": number;
                    "headList-memory-arguments": number;
                    "iData-cpu-arguments": number;
                    "iData-memory-arguments": number;
                    "ifThenElse-cpu-arguments": number;
                    "ifThenElse-memory-arguments": number;
                    "indexByteString-cpu-arguments": number;
                    "indexByteString-memory-arguments": number;
                    "lengthOfByteString-cpu-arguments": number;
                    "lengthOfByteString-memory-arguments": number;
                    "lessThanByteString-cpu-arguments-intercept": number;
                    "lessThanByteString-cpu-arguments-slope": number;
                    "lessThanByteString-memory-arguments": number;
                    "lessThanEqualsByteString-cpu-arguments-intercept": number;
                    "lessThanEqualsByteString-cpu-arguments-slope": number;
                    "lessThanEqualsByteString-memory-arguments": number;
                    "lessThanEqualsInteger-cpu-arguments-intercept": number;
                    "lessThanEqualsInteger-cpu-arguments-slope": number;
                    "lessThanEqualsInteger-memory-arguments": number;
                    "lessThanInteger-cpu-arguments-intercept": number;
                    "lessThanInteger-cpu-arguments-slope": number;
                    "lessThanInteger-memory-arguments": number;
                    "listData-cpu-arguments": number;
                    "listData-memory-arguments": number;
                    "mapData-cpu-arguments": number;
                    "mapData-memory-arguments": number;
                    "mkCons-cpu-arguments": number;
                    "mkCons-memory-arguments": number;
                    "mkNilData-cpu-arguments": number;
                    "mkNilData-memory-arguments": number;
                    "mkNilPairData-cpu-arguments": number;
                    "mkNilPairData-memory-arguments": number;
                    "mkPairData-cpu-arguments": number;
                    "mkPairData-memory-arguments": number;
                    "modInteger-cpu-arguments-constant": number;
                    "modInteger-cpu-arguments-model-arguments-intercept": number;
                    "modInteger-cpu-arguments-model-arguments-slope": number;
                    "modInteger-memory-arguments-intercept": number;
                    "modInteger-memory-arguments-minimum": number;
                    "modInteger-memory-arguments-slope": number;
                    "multiplyInteger-cpu-arguments-intercept": number;
                    "multiplyInteger-cpu-arguments-slope": number;
                    "multiplyInteger-memory-arguments-intercept": number;
                    "multiplyInteger-memory-arguments-slope": number;
                    "nullList-cpu-arguments": number;
                    "nullList-memory-arguments": number;
                    "quotientInteger-cpu-arguments-constant": number;
                    "quotientInteger-cpu-arguments-model-arguments-intercept": number;
                    "quotientInteger-cpu-arguments-model-arguments-slope": number;
                    "quotientInteger-memory-arguments-intercept": number;
                    "quotientInteger-memory-arguments-minimum": number;
                    "quotientInteger-memory-arguments-slope": number;
                    "remainderInteger-cpu-arguments-constant": number;
                    "remainderInteger-cpu-arguments-model-arguments-intercept": number;
                    "remainderInteger-cpu-arguments-model-arguments-slope": number;
                    "remainderInteger-memory-arguments-intercept": number;
                    "remainderInteger-memory-arguments-minimum": number;
                    "remainderInteger-memory-arguments-slope": number;
                    "sha2_256-cpu-arguments-intercept": number;
                    "sha2_256-cpu-arguments-slope": number;
                    "sha2_256-memory-arguments": number;
                    "sha3_256-cpu-arguments-intercept": number;
                    "sha3_256-cpu-arguments-slope": number;
                    "sha3_256-memory-arguments": number;
                    "sliceByteString-cpu-arguments-intercept": number;
                    "sliceByteString-cpu-arguments-slope": number;
                    "sliceByteString-memory-arguments-intercept": number;
                    "sliceByteString-memory-arguments-slope": number;
                    "sndPair-cpu-arguments": number;
                    "sndPair-memory-arguments": number;
                    "subtractInteger-cpu-arguments-intercept": number;
                    "subtractInteger-cpu-arguments-slope": number;
                    "subtractInteger-memory-arguments-intercept": number;
                    "subtractInteger-memory-arguments-slope": number;
                    "tailList-cpu-arguments": number;
                    "tailList-memory-arguments": number;
                    "trace-cpu-arguments": number;
                    "trace-memory-arguments": number;
                    "unBData-cpu-arguments": number;
                    "unBData-memory-arguments": number;
                    "unConstrData-cpu-arguments": number;
                    "unConstrData-memory-arguments": number;
                    "unIData-cpu-arguments": number;
                    "unIData-memory-arguments": number;
                    "unListData-cpu-arguments": number;
                    "unListData-memory-arguments": number;
                    "unMapData-cpu-arguments": number;
                    "unMapData-memory-arguments": number;
                    "verifyEd25519Signature-cpu-arguments-intercept": number;
                    "verifyEd25519Signature-cpu-arguments-slope": number;
                    "verifyEd25519Signature-memory-arguments": number;
                };
                const PlutusScriptV2: {
                    "addInteger-cpu-arguments-intercept": number;
                    "addInteger-cpu-arguments-slope": number;
                    "addInteger-memory-arguments-intercept": number;
                    "addInteger-memory-arguments-slope": number;
                    "appendByteString-cpu-arguments-intercept": number;
                    "appendByteString-cpu-arguments-slope": number;
                    "appendByteString-memory-arguments-intercept": number;
                    "appendByteString-memory-arguments-slope": number;
                    "appendString-cpu-arguments-intercept": number;
                    "appendString-cpu-arguments-slope": number;
                    "appendString-memory-arguments-intercept": number;
                    "appendString-memory-arguments-slope": number;
                    "bData-cpu-arguments": number;
                    "bData-memory-arguments": number;
                    "blake2b_256-cpu-arguments-intercept": number;
                    "blake2b_256-cpu-arguments-slope": number;
                    "blake2b_256-memory-arguments": number;
                    "cekApplyCost-exBudgetCPU": number;
                    "cekApplyCost-exBudgetMemory": number;
                    "cekBuiltinCost-exBudgetCPU": number;
                    "cekBuiltinCost-exBudgetMemory": number;
                    "cekConstCost-exBudgetCPU": number;
                    "cekConstCost-exBudgetMemory": number;
                    "cekDelayCost-exBudgetCPU": number;
                    "cekDelayCost-exBudgetMemory": number;
                    "cekForceCost-exBudgetCPU": number;
                    "cekForceCost-exBudgetMemory": number;
                    "cekLamCost-exBudgetCPU": number;
                    "cekLamCost-exBudgetMemory": number;
                    "cekStartupCost-exBudgetCPU": number;
                    "cekStartupCost-exBudgetMemory": number;
                    "cekVarCost-exBudgetCPU": number;
                    "cekVarCost-exBudgetMemory": number;
                    "chooseData-cpu-arguments": number;
                    "chooseData-memory-arguments": number;
                    "chooseList-cpu-arguments": number;
                    "chooseList-memory-arguments": number;
                    "chooseUnit-cpu-arguments": number;
                    "chooseUnit-memory-arguments": number;
                    "consByteString-cpu-arguments-intercept": number;
                    "consByteString-cpu-arguments-slope": number;
                    "consByteString-memory-arguments-intercept": number;
                    "consByteString-memory-arguments-slope": number;
                    "constrData-cpu-arguments": number;
                    "constrData-memory-arguments": number;
                    "decodeUtf8-cpu-arguments-intercept": number;
                    "decodeUtf8-cpu-arguments-slope": number;
                    "decodeUtf8-memory-arguments-intercept": number;
                    "decodeUtf8-memory-arguments-slope": number;
                    "divideInteger-cpu-arguments-constant": number;
                    "divideInteger-cpu-arguments-model-arguments-intercept": number;
                    "divideInteger-cpu-arguments-model-arguments-slope": number;
                    "divideInteger-memory-arguments-intercept": number;
                    "divideInteger-memory-arguments-minimum": number;
                    "divideInteger-memory-arguments-slope": number;
                    "encodeUtf8-cpu-arguments-intercept": number;
                    "encodeUtf8-cpu-arguments-slope": number;
                    "encodeUtf8-memory-arguments-intercept": number;
                    "encodeUtf8-memory-arguments-slope": number;
                    "equalsByteString-cpu-arguments-constant": number;
                    "equalsByteString-cpu-arguments-intercept": number;
                    "equalsByteString-cpu-arguments-slope": number;
                    "equalsByteString-memory-arguments": number;
                    "equalsData-cpu-arguments-intercept": number;
                    "equalsData-cpu-arguments-slope": number;
                    "equalsData-memory-arguments": number;
                    "equalsInteger-cpu-arguments-intercept": number;
                    "equalsInteger-cpu-arguments-slope": number;
                    "equalsInteger-memory-arguments": number;
                    "equalsString-cpu-arguments-constant": number;
                    "equalsString-cpu-arguments-intercept": number;
                    "equalsString-cpu-arguments-slope": number;
                    "equalsString-memory-arguments": number;
                    "fstPair-cpu-arguments": number;
                    "fstPair-memory-arguments": number;
                    "headList-cpu-arguments": number;
                    "headList-memory-arguments": number;
                    "iData-cpu-arguments": number;
                    "iData-memory-arguments": number;
                    "ifThenElse-cpu-arguments": number;
                    "ifThenElse-memory-arguments": number;
                    "indexByteString-cpu-arguments": number;
                    "indexByteString-memory-arguments": number;
                    "lengthOfByteString-cpu-arguments": number;
                    "lengthOfByteString-memory-arguments": number;
                    "lessThanByteString-cpu-arguments-intercept": number;
                    "lessThanByteString-cpu-arguments-slope": number;
                    "lessThanByteString-memory-arguments": number;
                    "lessThanEqualsByteString-cpu-arguments-intercept": number;
                    "lessThanEqualsByteString-cpu-arguments-slope": number;
                    "lessThanEqualsByteString-memory-arguments": number;
                    "lessThanEqualsInteger-cpu-arguments-intercept": number;
                    "lessThanEqualsInteger-cpu-arguments-slope": number;
                    "lessThanEqualsInteger-memory-arguments": number;
                    "lessThanInteger-cpu-arguments-intercept": number;
                    "lessThanInteger-cpu-arguments-slope": number;
                    "lessThanInteger-memory-arguments": number;
                    "listData-cpu-arguments": number;
                    "listData-memory-arguments": number;
                    "mapData-cpu-arguments": number;
                    "mapData-memory-arguments": number;
                    "mkCons-cpu-arguments": number;
                    "mkCons-memory-arguments": number;
                    "mkNilData-cpu-arguments": number;
                    "mkNilData-memory-arguments": number;
                    "mkNilPairData-cpu-arguments": number;
                    "mkNilPairData-memory-arguments": number;
                    "mkPairData-cpu-arguments": number;
                    "mkPairData-memory-arguments": number;
                    "modInteger-cpu-arguments-constant": number;
                    "modInteger-cpu-arguments-model-arguments-intercept": number;
                    "modInteger-cpu-arguments-model-arguments-slope": number;
                    "modInteger-memory-arguments-intercept": number;
                    "modInteger-memory-arguments-minimum": number;
                    "modInteger-memory-arguments-slope": number;
                    "multiplyInteger-cpu-arguments-intercept": number;
                    "multiplyInteger-cpu-arguments-slope": number;
                    "multiplyInteger-memory-arguments-intercept": number;
                    "multiplyInteger-memory-arguments-slope": number;
                    "nullList-cpu-arguments": number;
                    "nullList-memory-arguments": number;
                    "quotientInteger-cpu-arguments-constant": number;
                    "quotientInteger-cpu-arguments-model-arguments-intercept": number;
                    "quotientInteger-cpu-arguments-model-arguments-slope": number;
                    "quotientInteger-memory-arguments-intercept": number;
                    "quotientInteger-memory-arguments-minimum": number;
                    "quotientInteger-memory-arguments-slope": number;
                    "remainderInteger-cpu-arguments-constant": number;
                    "remainderInteger-cpu-arguments-model-arguments-intercept": number;
                    "remainderInteger-cpu-arguments-model-arguments-slope": number;
                    "remainderInteger-memory-arguments-intercept": number;
                    "remainderInteger-memory-arguments-minimum": number;
                    "remainderInteger-memory-arguments-slope": number;
                    "serialiseData-cpu-arguments-intercept": number;
                    "serialiseData-cpu-arguments-slope": number;
                    "serialiseData-memory-arguments-intercept": number;
                    "serialiseData-memory-arguments-slope": number;
                    "sha2_256-cpu-arguments-intercept": number;
                    "sha2_256-cpu-arguments-slope": number;
                    "sha2_256-memory-arguments": number;
                    "sha3_256-cpu-arguments-intercept": number;
                    "sha3_256-cpu-arguments-slope": number;
                    "sha3_256-memory-arguments": number;
                    "sliceByteString-cpu-arguments-intercept": number;
                    "sliceByteString-cpu-arguments-slope": number;
                    "sliceByteString-memory-arguments-intercept": number;
                    "sliceByteString-memory-arguments-slope": number;
                    "sndPair-cpu-arguments": number;
                    "sndPair-memory-arguments": number;
                    "subtractInteger-cpu-arguments-intercept": number;
                    "subtractInteger-cpu-arguments-slope": number;
                    "subtractInteger-memory-arguments-intercept": number;
                    "subtractInteger-memory-arguments-slope": number;
                    "tailList-cpu-arguments": number;
                    "tailList-memory-arguments": number;
                    "trace-cpu-arguments": number;
                    "trace-memory-arguments": number;
                    "unBData-cpu-arguments": number;
                    "unBData-memory-arguments": number;
                    "unConstrData-cpu-arguments": number;
                    "unConstrData-memory-arguments": number;
                    "unIData-cpu-arguments": number;
                    "unIData-memory-arguments": number;
                    "unListData-cpu-arguments": number;
                    "unListData-memory-arguments": number;
                    "unMapData-cpu-arguments": number;
                    "unMapData-memory-arguments": number;
                    "verifyEcdsaSecp256k1Signature-cpu-arguments": number;
                    "verifyEcdsaSecp256k1Signature-memory-arguments": number;
                    "verifyEd25519Signature-cpu-arguments-intercept": number;
                    "verifyEd25519Signature-cpu-arguments-slope": number;
                    "verifyEd25519Signature-memory-arguments": number;
                    "verifySchnorrSecp256k1Signature-cpu-arguments-intercept": number;
                    "verifySchnorrSecp256k1Signature-cpu-arguments-slope": number;
                    "verifySchnorrSecp256k1Signature-memory-arguments": number;
                };
            }
            export { costModels_1 as costModels };
            export namespace executionUnitPrices {
                const priceMemory: number;
                const priceSteps: number;
            }
            const maxBlockBodySize_1: number;
            export { maxBlockBodySize_1 as maxBlockBodySize };
            export namespace maxBlockExecutionUnits {
                const memory: number;
                const steps: number;
            }
            const maxBlockHeaderSize_1: number;
            export { maxBlockHeaderSize_1 as maxBlockHeaderSize };
            const maxCollateralInputs_1: number;
            export { maxCollateralInputs_1 as maxCollateralInputs };
            export namespace maxTxExecutionUnits {
                const memory_1: number;
                export { memory_1 as memory };
                const steps_1: number;
                export { steps_1 as steps };
            }
            const maxTxSize_1: number;
            export { maxTxSize_1 as maxTxSize };
            const maxValueSize_1: number;
            export { maxValueSize_1 as maxValueSize };
            const minPoolCost_1: number;
            export { minPoolCost_1 as minPoolCost };
            export const monetaryExpansion: number;
            export const poolPledgeInfluence: number;
            export const poolRetireMaxEpoch: number;
            export namespace protocolVersion_1 {
                const major_1: number;
                export { major_1 as major };
                const minor_1: number;
                export { minor_1 as minor };
            }
            export { protocolVersion_1 as protocolVersion };
            export const stakeAddressDeposit: number;
            export const stakePoolDeposit: number;
            export const stakePoolTargetNum: number;
            export const treasuryCut: number;
            export const txFeeFixed: number;
            export const txFeePerByte: number;
            export const utxoCostPerByte: number;
        }
        namespace latestTip {
            const epoch: number;
            const hash: string;
            const slot: number;
            const time: number;
        }
    }
    /**
     * This wallet only has a single private/public key, which isn't rotated. Staking is not yet supported.
     * @implements {Wallet}
     */
    export class SimpleWallet implements Wallet {
        /**
         * @param {Network} network
         * @param {Bip32PrivateKey} privateKey
         */
        constructor(network: Network, privateKey: Bip32PrivateKey);
        /**
         * @type {Bip32PrivateKey}
         */
        get privateKey(): Bip32PrivateKey;
        /**
         * @type {PubKey}
         */
        get pubKey(): PubKey;
        /**
         * @type {PubKeyHash}
         */
        get pubKeyHash(): PubKeyHash;
        /**
         * @type {Address}
         */
        get address(): Address;
        /**
         * @returns {Promise<boolean>}
         */
        isMainnet(): Promise<boolean>;
        /**
         * Assumed wallet was initiated with at least 1 UTxO at the pubkeyhash address.
         * @type {Promise<Address[]>}
         */
        get usedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<Address[]>}
         */
        get unusedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get utxos(): Promise<TxInput[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get collateral(): Promise<TxInput[]>;
        /**
         * Simply assumed the tx needs to by signed by this wallet without checking.
         * @param {Tx} tx
         * @returns {Promise<Signature[]>}
         */
        signTx(tx: Tx): Promise<Signature[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * A simple emulated Network.
     * This can be used to do integration tests of whole dApps.
     * Staking is not yet supported.
     * @implements {Network}
     */
    export class NetworkEmulator implements Network {
        /**
         * Instantiates a NetworkEmulator at slot 0.
         * An optional seed number can be specified, from which all emulated randomness is derived.
         * @param {number} seed
         */
        constructor(seed?: number);
        /**
         * @type {bigint}
         */
        get currentSlot(): bigint;
        /**
         * Creates a new `NetworkParams` instance that has access to current slot
         * (so that the `Tx` validity range can be set automatically during `Tx.finalize()`).
         * @param {NetworkParams} networkParams
         * @returns {NetworkParams}
         */
        initNetworkParams(networkParams: NetworkParams): NetworkParams;
        /**
         * Creates a new SimpleWallet and populates it with a given lovelace quantity and assets.
         * Special genesis transactions are added to the emulated chain in order to create these assets.
         * @param {bigint} lovelace
         * @param {Assets} assets
         * @returns {SimpleWallet}
         */
        createWallet(lovelace?: bigint, assets?: Assets): SimpleWallet;
        /**
         * Creates a UTxO using a GenesisTx.
         * @param {SimpleWallet} wallet
         * @param {bigint} lovelace
         * @param {Assets} assets
         */
        createUtxo(wallet: SimpleWallet, lovelace: bigint, assets?: Assets): void;
        /**
         * Mint a block with the current mempool, and advance the slot by a number of slots.
         * @param {bigint} nSlots
         */
        tick(nSlots: bigint): void;
        /**
         * @returns {Promise<NetworkParams>}
         */
        getParameters(): Promise<NetworkParams>;
        warnMempool(): void;
        /**
         * Throws an error if the UTxO isn't found
         * @param {TxOutputId} id
         * @returns {Promise<TxInput>}
         */
        getUtxo(id: TxOutputId): Promise<TxInput>;
        /**
         * @param {Address} address
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(address: Address): Promise<TxInput[]>;
        dump(): void;
        /**
         * @param {TxInput} utxo
         * @returns {boolean}
         */
        isConsumed(utxo: TxInput): boolean;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * Helper that
     * @implements {Network}
     */
    export class TxChain implements Network {
        /**
         * @param {Network} network
         */
        constructor(network: Network);
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        /**
         * @returns {Promise<NetworkParams>}
         */
        getParameters(): Promise<NetworkParams>;
        /**
         * @param {TxOutputId} id
         * @returns {Promise<TxInput>}
         */
        getUtxo(id: TxOutputId): Promise<TxInput>;
        /**
         * @param {TxInput[]} utxos
         * @param {Address[]} addrs
         * @returns {Promise<TxInput[]>}
         */
        getUtxosInternal(utxos: TxInput[], addrs: Address[]): Promise<TxInput[]>;
        /**
         * @param {Address} addr
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(addr: Address): Promise<TxInput[]>;
        /**
         * @param {Wallet} baseWallet
         * @returns {Wallet}
         */
        asWallet(baseWallet: Wallet): Wallet;
        #private;
    }
    /**
     * @typedef {{
     *   [address: string]: TxInput[]
     * }} NetworkSliceUTxOs
     */
    /**
     * @implements {Network}
     */
    export class NetworkSlice implements Network {
        /**
         * @param {Network} network
         * @param {Address[]} addresses
         * @returns {Promise<NetworkSlice>}
         */
        static init(network: Network, addresses: Address[]): Promise<NetworkSlice>;
        /**
         * @param {any} obj
         * @returns {NetworkSlice}
         */
        static fromJson(obj: any): NetworkSlice;
        /**
         * @param {NetworkParams} params
         * @param {NetworkSliceUTxOs} utxos
         */
        constructor(params: NetworkParams, utxos: NetworkSliceUTxOs);
        /**
         * @returns {any}
         */
        toJson(): any;
        /**
         * @returns {Promise<NetworkParams>}
         */
        getParameters(): Promise<NetworkParams>;
        /**
         * @param {TxOutputId} id
         * @returns {Promise<TxInput>}
         */
        getUtxo(id: TxOutputId): Promise<TxInput>;
        /**
         * @param {Address} addr
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(addr: Address): Promise<TxInput[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * @typedef {() => UplcData} ValueGenerator
     */
    /**
     * @typedef {(args: UplcValue[], res: (UplcValue | RuntimeError), isSimplfied?: boolean) => (boolean | Object.<string, boolean>)} PropertyTest
     */
    /**
     * Helper class for performing fuzzy property-based tests of Helios scripts.
     */
    export class FuzzyTest {
        /**
         * The simplify argument specifies whether optimized versions of the Helios sources should also be tested.
         * @param {number} seed
         * @param {number} runsPerTest
         * @param {boolean} simplify If true then also test the simplified program
         */
        constructor(seed?: number, runsPerTest?: number, simplify?: boolean, printMessages?: boolean);
        reset(): void;
        /**
         * @returns {NumberGenerator}
         */
        newRand(): NumberGenerator;
        /**
         * Returns a gernator for whole numbers between min and max
         * @param {number} min
         * @param {number} max
         * @returns {() => bigint}
         */
        rawInt(min?: number, max?: number): () => bigint;
        /**
         * Returns a generator for whole numbers between min and max, wrapped with IntData
         * @param {number} min
         * @param {number} max
         * @returns {ValueGenerator}
         */
        int(min?: number, max?: number): ValueGenerator;
        /**
         * @param {number} min
         * @param {number} max
         * @returns {ValueGenerator}
         */
        real(min?: number, max?: number): ValueGenerator;
        /**
         * Returns a generator for strings containing any utf-8 character.
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        string(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for strings with ascii characters from 32 (space) to 126 (tilde).
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        ascii(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for bytearrays containing only valid ascii characters
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        asciiBytes(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for bytearrays the are also valid utf8 strings
         * @param {number} minLength - length of the string, not of the bytearray!
         * @param {number} maxLength - length of the string, not of the bytearray!
         * @returns {ValueGenerator}
         */
        utf8Bytes(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for number[]
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {() => number[]}
         */
        rawBytes(minLength?: number, maxLength?: number): () => number[];
        /**
         * Returns a generator for bytearrays
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        bytes(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for booleans,
         * @returns {() => boolean}
         */
        rawBool(): () => boolean;
        /**
         * Returns a generator for booleans, wrapped with ConstrData
         * @returns {ValueGenerator}
         */
        bool(): ValueGenerator;
        /**
         * Returns a generator for options
         * @param {ValueGenerator} someGenerator
         * @param {number} noneProbability
         * @returns {ValueGenerator}
         */
        option(someGenerator: ValueGenerator, noneProbability?: number): ValueGenerator;
        /**
         * Returns a generator for lists
         * @param {ValueGenerator} itemGenerator
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        list(itemGenerator: ValueGenerator, minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for maps
         * @param {ValueGenerator} keyGenerator
         * @param {ValueGenerator} valueGenerator
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        map(keyGenerator: ValueGenerator, valueGenerator: ValueGenerator, minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for objects
         * @param {...ValueGenerator} itemGenerators
         * @returns {ValueGenerator}
         */
        object(...itemGenerators: ValueGenerator[]): ValueGenerator;
        /**
         * Returns a generator for tagged constr
         * @param {number | NumberGenerator} tag
         * @param {...ValueGenerator} fieldGenerators
         * @returns {ValueGenerator}
         */
        constr(tag: number | NumberGenerator, ...fieldGenerators: ValueGenerator[]): ValueGenerator;
        /**
         * Perform a fuzzy/property-based test-run of a Helios source. One value generator must be specified per argument of main.
         *
         * Throws an error if the propTest fails.
         *
         * The propTest can simply return a boolean, or can return an object with boolean values, and if any of these booleans is false the propTest fails (the keys can be used to provide extra information).
         * @param {ValueGenerator[]} argGens
         * @param {string} src
         * @param {PropertyTest} propTest
         * @param {number} nRuns
         * @param {boolean} simplify
         * @returns {Promise<void>} - throws an error if any of the property tests fail
         */
        test(argGens: ValueGenerator[], src: string, propTest: PropertyTest, nRuns?: number, simplify?: boolean): Promise<void>;
        /**
         * @param {Object.<string, ValueGenerator>} paramGenerators
         * @param {string[]} paramArgs
         * @param {string} src
         * @param {PropertyTest} propTest
         * @param {number} nRuns
         * @param {boolean} simplify
         * @returns {Promise<void>}
         */
        testParams(paramGenerators: {
            [x: string]: ValueGenerator;
        }, paramArgs: string[], src: string, propTest: PropertyTest, nRuns?: number, simplify?: boolean): Promise<void>;
        #private;
    }
    /**
     * Needed by transfer() methods
     */
    export type TransferUplcAst = {
        transferByteArrayData: (bytes: number[]) => any;
        transferConstrData: (index: number, fields: any[]) => any;
        transferIntData: (value: bigint) => any;
        transferListData: (items: any[]) => any;
        transferMapData: (pairs: [any, any][]) => any;
        transferSite: (src: any, startPos: number, endPos: number, codeMapSite: null | any) => any;
        transferSource: (raw: string, name: string) => any;
        transferUplcBool: (site: any, value: boolean) => any;
        transferUplcBuiltin: (site: any, name: string | number) => any;
        transferUplcByteArray: (site: any, bytes: number[]) => any;
        transferUplcCall: (site: any, a: any, b: any) => any;
        transferUplcConst: (value: any) => any;
        transferUplcDataValue: (site: any, data: any) => any;
        transferUplcDelay: (site: any, expr: any) => any;
        transferUplcError: (site: any, msg: string) => any;
        transferUplcForce: (site: any, expr: any) => any;
        transferUplcInt: (site: any, value: bigint, signed: boolean) => any;
        transferUplcLambda: (site: any, rhs: any, name: null | string) => any;
        transferUplcList: (site: any, itemType: any, items: any[]) => any;
        transferUplcPair: (site: any, first: any, second: any) => any;
        transferUplcString: (site: any, value: string) => any;
        transferUplcType: (typeBits: string) => any;
        transferUplcUnit: (site: any) => any;
        transferUplcVariable: (site: any, index: any) => any;
    };
    export type CekValue = UplcConst | AppliedUplcBuiltin | UplcLambdaWithEnv | UplcDelayWithEnv;
    export type CekEnv = {
        values: CekValue[];
        callSites: Site[];
    };
    export type ComputingState = {
        computing: UplcTerm;
        env: CekEnv;
    };
    export type ReducingState = {
        reducing: CekValue;
    };
    export type ErrorState = {
        error: string | RuntimeError;
        env: CekEnv;
    };
    export type CekState = ComputingState | ReducingState | ErrorState;
    export type TypeSchema = {
        type: string;
    } | {
        type: "List";
        itemType: TypeSchema;
    } | {
        type: "Map";
        keyType: TypeSchema;
        valueType: TypeSchema;
    } | {
        type: "Option";
        someType: TypeSchema;
    } | {
        type: "Struct";
        fieldTypes: NamedTypeSchema[];
    } | {
        type: "Enum";
        variantTypes: {
            name: string;
            fieldTypes: NamedTypeSchema[];
        }[];
    };
    export type NamedTypeSchema = {
        name: string;
    } & TypeSchema;
    export type ParameterI = {
        name: string;
        typeClass: TypeClass;
    };
    export type InferenceMap = Map<ParameterI, Type>;
    /**
     * Used by the bundle cli command to generate a typescript annotations and (de)serialization code
     * inputTypes form a type union
     */
    export type TypeDetails = {
        inputType: string;
        outputType: string;
        internalType: TypeSchema;
    };
    export type JsToUplcHelpers = {
        [name: string]: (obj: any) => Promise<UplcData>;
    };
    export type UplcToJsHelpers = {
        [name: string]: (data: UplcData) => Promise<any>;
    };
    export type JsToUplcConverter = (obj: any, helpers: JsToUplcHelpers) => Promise<UplcData>;
    export type UplcToJsConverter = (data: UplcData, helpers: UplcToJsHelpers) => Promise<any>;
    export type DataType = Named & Type & {
        asDataType: DataType;
        fieldNames: string[];
        offChainType: (null | HeliosDataClass<HeliosData>);
        typeDetails?: TypeDetails;
        jsToUplc: JsToUplcConverter;
        uplcToJs: UplcToJsConverter;
        ready: boolean;
    };
    export type EnumMemberType = DataType & {
        asEnumMemberType: EnumMemberType;
        constrIndex: number;
        parentType: DataType;
    };
    /**
     * EvalEntities assert themselves
     */
    export type EvalEntity = {
        asDataType: (null | DataType);
        asEnumMemberType: (null | EnumMemberType);
        asFunc: (null | Func);
        asInstance: (null | Instance);
        asMulti: (null | Multi);
        asNamed: (null | Named);
        asNamespace: (null | Namespace);
        asParametric: (null | Parametric);
        asType: (null | Type);
        asTyped: (null | Typed);
        asTypeClass: (null | TypeClass);
        toString(): string;
    };
    export type Func = EvalEntity & {
        asTyped: Typed;
        type: Type;
    } & {
        asFunc: Func;
        funcType: FuncType;
        call(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        } | undefined): (null | Typed | Multi);
    };
    export type Instance = Typed & {
        asInstance: Instance;
        fieldNames: string[];
        instanceMembers: InstanceMembers;
    };
    export type Multi = EvalEntity & {
        asMulti: Multi;
        values: Typed[];
    };
    export type Named = EvalEntity & {
        asNamed: Named;
        name: string;
        path: string;
    };
    export type Namespace = EvalEntity & {
        asNamespace: Namespace;
        namespaceMembers: NamespaceMembers;
    };
    export type Parametric = EvalEntity & {
        asParametric: Parametric;
        offChainType: ((...any: any[]) => HeliosDataClass<HeliosData>) | null;
        typeClasses: TypeClass[];
        apply(types: Type[], site?: Site): EvalEntity;
        inferCall(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        } | undefined, paramTypes?: Type[]): Func;
        infer(site: Site, map: InferenceMap): Parametric;
    };
    export type Type = EvalEntity & {
        asType: Type;
        instanceMembers: InstanceMembers;
        typeMembers: TypeMembers;
        isBaseOf(type: Type): boolean;
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        toTyped(): Typed;
        isParametric(): boolean;
    };
    export type Typed = EvalEntity & {
        asTyped: Typed;
        type: Type;
    };
    export type TypeClass = EvalEntity & {
        asTypeClass: TypeClass;
        genInstanceMembers(impl: Type): TypeClassMembers;
        genTypeMembers(impl: Type): TypeClassMembers;
        isImplementedBy(type: Type): boolean;
        toType(name: string, path: string, parameter?: null | ParameterI): Type;
    };
    export type InstanceMembers = {
        [name: string]: Type | Parametric;
    };
    export type NamespaceMembers = {
        [name: string]: EvalEntity;
    };
    export type TypeMembers = {
        [name: string]: Type | Typed | Parametric;
    };
    export type TypeClassMembers = {
        [name: string]: Type;
    };
    /**
     * The inner 'any' is also Metadata, but jsdoc doesn't allow declaring recursive types
     * Metadata is essentially a JSON schema object
     */
    export type Metadata = {
        map: [any, any][];
    } | any[] | string | number;
    /**
     * Function that generates a random number between 0 and 1
     */
    export type NumberGenerator = () => number;
    export type CodeMap = [number, Site][];
    export type IRDefinitions = Map<string, IR>;
    export type CurvePoint<T extends CurvePoint<T>> = {
        add(other: T): T;
        mul(scalar: bigint): T;
        equals(other: T): boolean;
        encode(): number[];
    };
    export type Decoder = (i: number, bytes: number[]) => void;
    /**
     * Deprecated
     */
    export type HeliosDataClass<T extends HeliosData> = {
        new (...args: any[]): T;
        fromUplcCbor: (bytes: (string | number[])) => T;
        fromUplcData: (data: UplcData) => T;
        isBuiltin(): boolean;
    };
    export type HIntProps = number | bigint;
    export type TimeProps = number | bigint | string | Date;
    export type DurationProps = HIntProps;
    export type BoolProps = boolean | string;
    export type HStringProps = string;
    export type ByteArrayProps = number[] | string;
    export type HashProps = number[] | string;
    export type DatumHashProps = HashProps;
    export type PubKeyProps = number[] | string;
    /**
     * Represents a blake2b-224 hash of a PubKey
     *
     * **Note**: A `PubKeyHash` can also be used as the second part of a payment `Address`, or to construct a `StakeAddress`.
     */
    export type PubKeyHashProps = HashProps;
    export type ScriptHashProps = HashProps;
    export type MintingPolicyHashProps = HashProps;
    export type StakingValidatorHashProps = HashProps;
    export type ValidatorHashProps = HashProps;
    export type TxIdProps = HashProps;
    export type TxOutputIdProps = string | [
        TxId | TxIdProps,
        HInt | HIntProps
    ] | {
        txId: TxId | TxIdProps;
        utxoId: HInt | HIntProps;
    };
    /**
     * An array of bytes, a Bech32 encoded address, or the hexadecimal representation of the underlying bytes.
     */
    export type AddressProps = number[] | string;
    export type AssetClassProps = string | [
        MintingPolicyHash | MintingPolicyHashProps,
        ByteArray | ByteArrayProps
    ] | {
        mph: MintingPolicyHash | MintingPolicyHashProps;
        tokenName: ByteArray | ByteArrayProps;
    };
    export type AssetsProps = [
        AssetClass | AssetClassProps,
        HInt | HIntProps
    ][] | [
        MintingPolicyHash | MintingPolicyHashProps,
        [
            ByteArray | ByteArrayProps,
            HInt | HIntProps
        ][]
    ][];
    export type ValueProps = HInt | HIntProps | [
        HInt | HIntProps,
        Assets | AssetsProps
    ] | {
        lovelace: HInt | HIntProps;
        assets?: Assets | AssetsProps;
    };
    export type Cost = {
        mem: bigint;
        cpu: bigint;
    };
    export type LiveSlotGetter = () => bigint;
    export type CostModelClass = {
        fromParams: (params: NetworkParams, baseName: string) => CostModel;
    };
    /**
     * A Helios/Uplc Program can have different purposes
     */
    export type ScriptPurpose = "testing" | "minting" | "spending" | "staking" | "endpoint" | "module" | "unknown";
    export type UplcRawStack = [null | string, UplcValue][];
    export type UplcRTECallbacks = {
        onPrint: (msg: string) => Promise<void>;
        onStartCall: (site: Site, rawStack: UplcRawStack) => Promise<boolean>;
        onEndCall: (site: Site, rawStack: UplcRawStack) => Promise<void>;
        onIncrCost: (name: string, isTerm: boolean, cost: Cost) => void;
    };
    export type UplcRTECallbacksInternal = UplcRTECallbacks & {
        macros?: {
            [name: string]: (rte: UplcRte, args: UplcValue[]) => Promise<UplcValue>;
        } | undefined;
    };
    /**
     * TODO: purpose as enum type
     */
    export type ProgramProperties = {
        purpose: null | ScriptPurpose;
        callsTxTimeRange: boolean;
        name?: string;
    };
    /**
     * The constructor returns 'any' because it is an instance of TransferableUplcProgram, and the instance methods don't need to be defined here
     */
    export type TransferableUplcProgram<TInstance> = {
        transferUplcProgram: (expr: any, properties: ProgramProperties, version: any[]) => TInstance;
        transferUplcAst: TransferUplcAst;
    };
    /**
     * mem:  in 8 byte words (i.e. 1 mem unit is 64 bits)
     * cpu:  in reference cpu microseconds
     * size: in bytes
     * builtins: breakdown per builtin
     * terms: breakdown per termtype
     * result: result of evaluation
     * messages: printed messages (can be helpful when debugging)
     */
    export type Profile = {
        mem: bigint;
        cpu: bigint;
        size?: number | undefined;
        builtins?: {
            [name: string]: Cost;
        } | undefined;
        terms?: {
            [name: string]: Cost;
        } | undefined;
        result?: RuntimeError | UplcValue | undefined;
        messages?: string[] | undefined;
    };
    export type GenericTypeProps<T extends HeliosData> = {
        name: string;
        path?: string | undefined;
        offChainType?: HeliosDataClass<T> | null | undefined;
        genOffChainType?: (() => HeliosDataClass<T>) | null | undefined;
        fieldNames?: string[] | undefined;
        genInstanceMembers: (self: Type) => InstanceMembers;
        genTypeMembers: (self: Type) => TypeMembers;
        genTypeDetails?: ((self: Type) => TypeDetails) | undefined;
        jsToUplc?: JsToUplcConverter | undefined;
        uplcToJs?: UplcToJsConverter | undefined;
    };
    export type GenericEnumMemberTypeProps<T extends HeliosData> = {
        name: string;
        path?: string | undefined;
        constrIndex: number;
        parentType: DataType;
        offChainType?: HeliosDataClass<T> | undefined;
        genOffChainType?: (() => HeliosDataClass<T>) | undefined;
        fieldNames?: string[] | undefined;
        genInstanceMembers: (self: Type) => InstanceMembers;
        genTypeMembers?: ((self: Type) => TypeMembers) | undefined;
        genTypeDetails?: ((self: Type) => TypeDetails) | undefined;
        jsToUplc?: JsToUplcConverter | undefined;
        uplcToJs?: UplcToJsConverter | undefined;
    };
    export type ScriptTypes = {
        [name: string]: ScriptHashType;
    };
    /**
     * Interface for:
     *   * IRErrorExpr
     *   * IRCallExpr
     *   * IRFuncExpr
     *   * IRNameExpr
     *   * IRLiteralExpr
     *
     * The copy() method is needed because inlining can't use the same IRNameExpr twice,
     *   so any inlineable expression is copied upon inlining to assure each nested IRNameExpr is unique.
     *   This is important to do even the the inlined expression is only called once, because it might still be inlined into multiple other locations that are eliminated in the next iteration.
     */
    export type IRExpr = {
        site: Site;
        resolveNames(scope: IRScope): void;
        toString(indent?: string): string;
        copy(): IRExpr;
        toUplc(): UplcTerm;
    };
    export type IRValue = {
        code: number;
        hash(depth?: number): number[];
        toString(): string;
        isLiteral(): boolean;
        hasError(maybe: boolean): boolean;
        withoutLiterals(): IRValue;
        withoutErrors(): IRValue;
        dump(depth?: number): any;
    };
    export type UserTypes = {
        [name: string]: any;
    };
    export type ProgramConfig = {
        allowPosParams: boolean;
        invertEntryPoint: boolean;
    };
    export type PrivateKey = {
        /**
         * Generates the corresponding public key.
         */
        derivePubKey: () => PubKey;
        /**
         * Signs a byte-array payload, returning the signature.
         */
        sign: (msg: number[]) => Signature;
    };
    /**
     * Returns two lists. The first list contains the selected UTxOs, the second list contains the remaining UTxOs.
     */
    export type CoinSelectionAlgorithm = (utxos: TxInput[], amount: Value) => [TxInput[], TxInput[]];
    /**
     * An interface type for a wallet that manages a user's UTxOs and addresses.
     */
    export type Wallet = {
        /**
         * Returns `true` if the wallet is connected to the mainnet.
         */
        isMainnet: () => Promise<boolean>;
        /**
         * Returns a list of addresses which already contain UTxOs.
         */
        usedAddresses: Promise<Address[]>;
        /**
         * Returns a list of unique unused addresses which can be used to send UTxOs to with increased anonimity.
         */
        unusedAddresses: Promise<Address[]>;
        /**
         * Returns a list of all the utxos controlled by the wallet.
         */
        utxos: Promise<TxInput[]>;
        collateral: Promise<TxInput[]>;
        /**
         * Signs a transaction, returning a list of signatures needed for submitting a valid transaction.
         */
        signTx: (tx: Tx) => Promise<Signature[]>;
        /**
         * Submits a transaction to the blockchain and returns the id of that transaction upon success.
         */
        submitTx: (tx: Tx) => Promise<TxId>;
    };
    /**
     * Convenience type for browser plugin wallets supporting the CIP 30 dApp connector standard (eg. Eternl, Nami, ...).
     *
     * This is useful in typescript projects to avoid type errors when accessing the handles in `window.cardano`.
     *
     * ```ts
     * // refer to this file in the 'typeRoots' list in tsconfig.json
     *
     * type Cip30SimpleHandle = {
     *   name: string,
     *   icon: string,
     *   enable(): Promise<helios.Cip30Handle>,
     *   isEnabled(): boolean
     * }
     *
     * declare global {
     *   interface Window {
     *     cardano: {
     *       [walletName: string]: Cip30SimpleHandle
     *     };
     *   }
     * }
     * ```
     */
    export type Cip30Handle = {
        getNetworkId(): Promise<number>;
        getUsedAddresses(): Promise<string[]>;
        getUnusedAddresses(): Promise<string[]>;
        getUtxos(): Promise<string[]>;
        getCollateral(): Promise<string[]>;
        signTx(txHex: string, partialSign: boolean): Promise<string>;
        submitTx(txHex: string): Promise<string>;
        experimental: {
            getCollateral(): Promise<string[]>;
        };
    };
    /**
     * Blockchain query interface.
     */
    export type Network = {
        /**
         * Returns a complete list of UTxOs at a given address.
         */
        getUtxos: (address: Address) => Promise<TxInput[]>;
        /**
         * Returns a single TxInput (that might already have been spent).
         */
        getUtxo: (id: TxOutputId) => Promise<TxInput>;
        /**
         * Returns the latest network parameters.
         */
        getParameters: () => Promise<NetworkParams>;
        /**
         * Submits a transaction to the blockchain and returns the id of that transaction upon success.
         */
        submitTx: (tx: Tx) => Promise<TxId>;
    };
    /**
     * collectUtxos removes tx inputs from the list, and appends txoutputs sent to the address to the end.
     */
    export type EmulatorTx = {
        id(): TxId;
        consumes(utxo: TxInput): boolean;
        collectUtxos(address: Address, utxos: TxInput[]): TxInput[];
        getUtxo(id: TxOutputId): (null | TxInput);
        dump(): void;
    };
    export type NetworkSliceUTxOs = {
        [address: string]: TxInput[];
    };
    export type ValueGenerator = () => UplcData;
    export type PropertyTest = (args: UplcValue[], res: (UplcValue | RuntimeError), isSimplfied?: boolean) => (boolean | {
        [x: string]: boolean;
    });
    /**
     * @internal
     */
    class IRExprTagger {
        genTag(): number;
        #private;
    }
    /**
     * UplcStack contains a value that can be retrieved using a Debruijn index.
     */
    class UplcStack {
        /**
         * @param {null | UplcStack | UplcRte} parent
         * @param {null | UplcValue} value
         * @param {null | string} valueName
         */
        constructor(parent: null | UplcStack | UplcRte, value?: null | UplcValue, valueName?: null | string);
        incrStartupCost(): void;
        incrVariableCost(): void;
        incrLambdaCost(): void;
        incrDelayCost(): void;
        incrCallCost(): void;
        incrConstCost(): void;
        incrForceCost(): void;
        incrBuiltinCost(): void;
        /**
         * @param {UplcBuiltin} fn
         * @param {UplcValue[]} args
         */
        calcAndIncrCost(fn: UplcBuiltin, ...args: UplcValue[]): void;
        /**
         * Gets a value using the Debruijn index. If 'i == 1' then the current value is returned.
         * Otherwise 'i' is decrement and passed to the parent stack.
         * @param {number} i
         * @returns {UplcValue}
         */
        get(i: number): UplcValue;
        /**
         *
         * @param {string} name
         * @param {UplcValue[]} args
         * @returns {Promise<UplcValue>}
         */
        callMacro(name: string, args: UplcValue[]): Promise<UplcValue>;
        /**
         * Instantiates a child stack.
         * @param {UplcValue} value
         * @param {?string} valueName
         * @returns {UplcStack}
         */
        push(value: UplcValue, valueName?: string | null): UplcStack;
        /**
         * Calls the onPrint callback in the RTE (root of stack).
         * @param {string} msg
         * @returns {Promise<void>}
         */
        print(msg: string): Promise<void>;
        /**
         * Calls the onStartCall callback in the RTE (root of stack).
         * @param {Site} site
         * @param {UplcRawStack} rawStack
         * @returns {Promise<void>}
         */
        startCall(site: Site, rawStack: UplcRawStack): Promise<void>;
        /**
         * Calls the onEndCall callback in the RTE (root of stack).
         * @param {Site} site
         * @param {UplcRawStack} rawStack
         * @param {UplcValue} result
         * @returns {Promise<void>}
         */
        endCall(site: Site, rawStack: UplcRawStack, result: UplcValue): Promise<void>;
        /**
         * @returns {UplcRawStack}
         */
        toList(): UplcRawStack;
        #private;
    }
    /**
     * @internal
     * @extends {UplcTermWithEnv<UplcLambda>}
     */
    class UplcLambdaWithEnv extends UplcTermWithEnv<UplcLambda> {
        /**
         * @param {T} term
         * @param {CekEnv} env
         */
        constructor(term: UplcLambda, env: CekEnv);
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {PreCallFrame} frame
         * @returns {Promise<CekState>}
         */
        reducePreCallFrame(rte: UplcRte, stack: UplcFrame[], frame: PreCallFrame): Promise<CekState>;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ForceFrame} frame
         * @returns {Promise<CekState>}
         */
        reduceForceFrame(rte: UplcRte, stack: UplcFrame[], frame: ForceFrame): Promise<CekState>;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ReducingState} state
         * @param {CallFrame} frame
         * @returns {Promise<CekState>}
         */
        reduceCallFrame(rte: UplcRte, stack: UplcFrame[], state: ReducingState, frame: CallFrame): Promise<CekState>;
    }
    /**
     * @internal
     */
    class AppliedUplcBuiltin {
        /**
         * @param {UplcBuiltin} term
         * @param {number} forceCount
         * @param {CekValue[]} args
         */
        constructor(term: UplcBuiltin, forceCount?: number, args?: CekValue[]);
        /**
         * @readonly
         * @type {UplcBuiltin}
         */
        readonly term: UplcBuiltin;
        /**
         * @readonly
         * @type {number}
         */
        readonly forceCount: number;
        /**
         * @readonly
         * @type {CekValue[]}
         */
        readonly args: CekValue[];
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @returns {AppliedUplcBuiltin}
         */
        force(): AppliedUplcBuiltin;
        /**
         * @param {CekValue} arg
         * @returns {AppliedUplcBuiltin}
         */
        apply(arg: CekValue): AppliedUplcBuiltin;
        /**
         * @returns {boolean}
         */
        isFullForced(): boolean;
        /**
         * @returns {boolean}
         */
        isFullyApplied(): boolean;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {Site[]} sites
         * @returns {Promise<CekValue>}
         */
        evalCek(rte: UplcRte, sites: Site[]): Promise<CekValue>;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {PreCallFrame} frame
         * @returns {Promise<CekState>}
         */
        reducePreCallFrame(rte: UplcRte, stack: UplcFrame[], frame: PreCallFrame): Promise<CekState>;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ForceFrame} frame
         * @returns {Promise<CekState>}
         */
        reduceForceFrame(rte: UplcRte, stack: UplcFrame[], frame: ForceFrame): Promise<CekState>;
        /**
         *
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ReducingState} state
         * @param {CallFrame} frame
         * @returns {Promise<CekState>}
         */
        reduceCallFrame(rte: UplcRte, stack: UplcFrame[], state: ReducingState, frame: CallFrame): Promise<CekState>;
    }
    /**
     * Wrapper for a builtin function (written in IR)
     */
    class RawFunc {
        /**
         * Construct a RawFunc, and immediately scan the definition for dependencies
         * @param {string} name
         * @param {string} definition
         */
        constructor(name: string, definition: string);
        get name(): string;
        /**
         * @returns {IR}
         */
        toIR(): IR;
        /**
         * Loads 'this.#dependecies' (if not already loaded), then load 'this'
         * @param {Map<string, RawFunc>} db
         * @param {IRDefinitions} dst
         * @returns {void}
         */
        load(db: Map<string, RawFunc>, dst: IRDefinitions): void;
        #private;
    }
    /**
     * Parent class of EnumSwitchExpr and DataSwitchExpr
     */
    class SwitchExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} controlExpr - input value of the switch
         * @param {SwitchCase[]} cases
         * @param {null | SwitchDefault} defaultCase
        */
        constructor(site: Site, controlExpr: Expr, cases: SwitchCase[], defaultCase?: null | SwitchDefault);
        get controlExpr(): Expr;
        get cases(): SwitchCase[];
        get defaultCase(): SwitchDefault | null;
        /**
         * If there isn't enough coverage then we can simply set the default case to void, so the other branches can be error, print or assert
         */
        setDefaultCaseToVoid(): void;
        #private;
    }
    /**
     * @internal
     */
    class IRStack {
        /**
         * @returns {IRStack}
         */
        static empty(): IRStack;
        /**
         * @param {[IRVariable, IRValue][]} values
         * @param {boolean} isLiteral
         */
        constructor(values: [IRVariable, IRValue][], isLiteral: boolean);
        dump(depth?: number): {
            values?: any[] | undefined;
            hash: number;
            hashes: number[];
            isLiteral: boolean;
        };
        /**
         * @type {number}
         */
        get code(): number;
        /**
         * @param {number} depth
         * @returns {number[]}
         */
        hash(depth?: number): number[];
        /**
         * @returns {boolean}
         */
        isLiteral(): boolean;
        /**
         * @return {IRStack}
         */
        withoutLiterals(): IRStack;
        /**
         * @param {IRVariable} v
         * @returns {IRValue}
         */
        getValue(v: IRVariable): IRValue;
        /**
         * @param {[IRVariable, IRValue][]} args
         * @returns {IRStack}
         */
        extend(args: [IRVariable, IRValue][]): IRStack;
        /**
         * @param {Set<IRVariable>} irVars
         * @returns {IRStack}
         */
        filter(irVars: Set<IRVariable>): IRStack;
        /**
         * Both stack are expected to have the same shape
         * TODO: get rid of this
         * @param {IRStack} other
         * @returns {IRStack}
         */
        merge(other: IRStack): IRStack;
        #private;
    }
    /**
     * A Module is a collection of statements
     */
    class Module {
        /**
         * @param {string} rawSrc
         * @returns {Module}
         */
        static new(rawSrc: string): Module;
        /**
         * @param {Word} name
         * @param {Statement[]} statements
         */
        constructor(name: Word, statements: Statement[]);
        throwErrors(): void;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @type {Statement[]}
         */
        get statements(): Statement[];
        /**
         * @param {string} namespace
         * @param {(name: string, cs: ConstStatement) => void} callback
         */
        loopConstStatements(namespace: string, callback: (name: string, cs: ConstStatement) => void): void;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @param {ModuleScope} scope
         */
        evalTypes(scope: ModuleScope): void;
        /**
         * This module can depend on other modules
         * TODO: detect circular dependencies
         * @param {Module[]} modules
         * @param {Module[]} stack
         * @returns {Module[]}
         */
        filterDependencies(modules: Module[], stack?: Module[]): Module[];
        #private;
    }
    /**
     * The entrypoint module
     */
    class MainModule extends Module {
        /**
         * @type {FuncStatement}
         */
        get mainFunc(): FuncStatement;
    }
    /**
     * @internal
     * @extends {UplcTermWithEnv<UplcDelay>}
     */
    class UplcDelayWithEnv extends UplcTermWithEnv<UplcDelay> {
        /**
         * @param {T} term
         * @param {CekEnv} env
         */
        constructor(term: UplcDelay, env: CekEnv);
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {PreCallFrame} frame
         * @returns {CekState}
         */
        reducePreCallFrame(rte: UplcRte, stack: UplcFrame[], frame: PreCallFrame): CekState;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ForceFrame} frame
         * @returns {CekState}
         */
        reduceForceFrame(rte: UplcRte, stack: UplcFrame[], frame: ForceFrame): CekState;
    }
    /**
     * @internal
     * @template {UplcTerm} T
     */
    class UplcTermWithEnv<T extends UplcTerm> {
        /**
         * @param {T} term
         * @param {CekEnv} env
         */
        constructor(term: T, env: CekEnv);
        /**
        * @readonly
        * @type {T}
        */
        readonly term: T;
        /**
         * @readonly
         * @type {CekEnv}
         */
        readonly env: CekEnv;
        /**
         * @type {Site}
         */
        get site(): Site;
        toString(): string;
    }
    export {};
}
