declare module "helios" {
    /**
     * Needed by transfer() methods
     * @typedef {{
     *   transferByteArrayData: (bytes: number[]) => any,
     *   transferConstrData: (index: number, fields: any[]) => any,
     *   transferIntData: (value: bigint) => any,
     *   transferListData: (items: any[]) => any,
     *   transferMapData: (pairs: [any, any][]) => any,
     *   transferSite: (src: any, startPos: number, endPos: number, codeMapSite: null | any) => any,
     *   transferSource: (raw: string, name: string) => any,
     *   transferUplcBool: (site: any, value: boolean) => any,
     *   transferUplcBuiltin: (site: any, name: string | number) => any,
     *   transferUplcByteArray: (site: any, bytes: number[]) => any,
     *   transferUplcCall: (site: any, a: any, b: any) => any,
     *   transferUplcConst: (value: any) => any,
     *   transferUplcDataValue: (site: any, data: any) => any,
     *   transferUplcDelay: (site: any, expr: any) => any,
     *   transferUplcError: (site: any, msg: string) => any,
     *   transferUplcForce: (site: any, expr: any) => any,
     *   transferUplcInt: (site: any, value: bigint, signed: boolean) => any,
     *   transferUplcLambda: (site: any, rhs: any, name: null | string) => any,
     *   transferUplcList: (site: any, itemType: any, items: any[]) => any,
     *   transferUplcPair: (site: any, first: any, second: any) => any,
     *   transferUplcString: (site: any, value: string) => any,
     *   transferUplcType: (typeBits: string) => any,
     *   transferUplcUnit: (site: any) => any,
     *   transferUplcVariable: (site: any, index: any) => any
     * }} TransferUplcAst
     */
    /**
     * Throws an error if 'cond' is false.
     * @internal
     * @param {boolean} cond
     * @param {string} msg
     */
    export function assert(cond: boolean, msg?: string): void;
    /**
     * Throws an error if 'obj' is undefined. Returns 'obj' itself (for chained application).
     * @internal
     * @template T
     * @param {T | undefined | null} obj
     * @param {string} msg
     * @returns {T}
     */
    export function assertDefined<T>(obj: T | null | undefined, msg?: string): T;
    /**
     * @internal
     * @template Tin, Tout
     * @param {Tin} obj
     * @param {{new(...any): Tout}} C
     * @returns {Tout}
     */
    export function assertClass<Tin, Tout>(obj: Tin, C: new (...any: any[]) => Tout, msg?: string): Tout;
    /**
     * @internal
     * @param {string} str
     * @param {string} msg
     * @returns {string}
     */
    export function assertNonEmpty(str: string, msg?: string): string;
    /**
     * @internal
     * @param {any} obj
     * @param {string} msg
     * @returns {number}
     */
    export function assertNumber(obj: any, msg?: string): number;
    /**
     * @internal
     * @template T
     * @param {(T | null)[]} lst
     * @returns {null | (T[])}
     */
    export function reduceNull<T>(lst: (T | null)[]): T[] | null;
    /**
     * @internal
     * @template Ta
     * @template Tb
     * @param {[Ta | null, Tb | null][]} pairs
     * @returns {null | [Ta, Tb][]}
     */
    export function reduceNullPairs<Ta, Tb>(pairs: [Ta | null, Tb | null][]): [Ta, Tb][] | null;
    /**
     * Compares two objects (deep recursive comparison)
     * @internal
     * @template T
     * @param {T} a
     * @param {T} b
     * @returns {boolean}
     */
    export function eq<T>(a: T, b: T): boolean;
    /**
     * Throws an error if two object aren't equal (deep comparison).
     * Used by unit tests that are autogenerated from JSDoc inline examples.
     * @internal
     * @template T
     * @param {T} a
     * @param {T} b
     * @param {string} msg
     */
    export function assertEq<T>(a: T, b: T, msg: string): void;
    /**
     * Divides two integers. Assumes a and b are whole numbers. Rounds down the result.
     * @example
     * idiv(355, 113) == 3
     * @internal
     * @param {number} a
     * @param {number} b
     */
    export function idiv(a: number, b: number): number;
    /**
     * 2 to the power 'p' for bigint.
     * @internal
     * @param {bigint} p
     * @returns {bigint}
     */
    export function ipow2(p: bigint): bigint;
    /**
     * Masks bits of 'b' by setting bits outside the range ['i0', 'i1') to 0.
     * 'b' is an 8 bit integer (i.e. number between 0 and 255).
     * The return value is also an 8 bit integer, shift right by 'i1'.
     
     * @example
     * imask(0b11111111, 1, 4) == 0b0111 // (i.e. 7)
     * @internal
     * @param {number} b
     * @param {number} i0
     * @param {number} i1
     * @returns {number}
     */
    export function imask(b: number, i0: number, i1: number): number;
    /**
     * Make sure resulting number fits in uint8
     * @internal
     * @param {number} x
     */
    export function imod8(x: number): number;
    /**
     * Converts an unbounded integer into a list of uint8 numbers (big endian)
     * Used by the CBOR encoding of data structures, and by Ed25519
     * @internal
     * @param {bigint} x
     * @returns {number[]}
     */
    export function bigIntToBytes(x: bigint): number[];
    /**
     * Converts a list of uint8 numbers into an unbounded int (big endian)
     * Used by the CBOR decoding of data structures.
     * @internal
     * @param {number[]} b
     * @return {bigint}
     */
    export function bytesToBigInt(b: number[]): bigint;
    /**
     * Little Endian 32 bytes
     * @internal
     * @param {number[]} b
     * @returns {bigint}
     */
    export function leBytesToBigInt(b: number[]): bigint;
    /**
     * Little Endian 32 bytes
     * @internal
     * @param {bigint} x
     * @returns {number[]}
     */
    export function bigIntToLe32Bytes(x: bigint): number[];
    /**
     * Prepends zeroes to a bit-string so that 'result.length == n'.
     * @example
     * padZeroes("1111", 8) == "00001111"
     * @internal
     * @param {string} bits
     * @param {number} n
     * @returns {string}
     */
    export function padZeroes(bits: string, n: number): string;
    /**
     * Converts a 8 bit integer number into a bit string with an optional "0b" prefix.
     * The result is padded with leading zeroes to become 'n' chars long ('2 + n' chars long if you count the "0b" prefix).
     * @example
     * byteToBitString(7) == "0b00000111"
     * @internal
     * @param {number} b
     * @param {number} n
     * @param {boolean} prefix
     * @returns {string}
     */
    export function byteToBitString(b: number, n?: number, prefix?: boolean): string;
    /**
     * Converts a hexadecimal string into a list of bytes.
     * @example
     * hexToBytes("00ff34") == [0, 255, 52]
     * @param {string} hex
     * @returns {number[]}
     */
    export function hexToBytes(hex: string): number[];
    /**
     * Converts a list of uint8 bytes into its hexadecimal string representation.
     * @example
     * bytesToHex([0, 255, 52]) == "00ff34"
     * @param {number[]} bytes
     * @returns {string}
     */
    export function bytesToHex(bytes: number[]): string;
    /**
     * Encodes a string into a list of uint8 bytes using UTF-8 encoding.
     * @example
     * textToBytes("hello world") == [104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]
     * @param {string} str
     * @returns {number[]}
     */
    export function textToBytes(str: string): number[];
    /**
     * Decodes a list of uint8 bytes into a string using UTF-8 encoding.
     * @example
     * bytesToText([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100]) == "hello world"
     * @param {number[]} bytes
     * @returns {string}
     */
    export function bytesToText(bytes: number[]): string;
    /**
     * Replaces the tab characters of a string with spaces.
     * This is used to create a prettier IR (which is built-up from many template js strings in this file, which might contain tabs depending on the editor used)
     * @example
     * replaceTabs("\t\t\t") == [TAB, TAB, TAB].join("")
     * @internal
     * @param {string} str
     * @returns {string}
     */
    export function replaceTabs(str: string): string;
    /**
     * Template string tag function that doesn't do anything and just returns the template string as a string.
     * Can be used as a marker of Helios sources so that syntax highlighting can work inside JS/TS files.
     * @example
     * hl`hello ${"world"}!` == "hello world!"
     * @param {string[]} a
     * @param  {...any} b
     * @returns {string}
     */
    export function hl(a: string[], ...b: any[]): string;
    /**
     * Display a warning message that a certain feature will be deprecated at some point in the future.
     * @internal
     * @param {string} feature
     * @param {string} futureVersion
     * @param {string} alternative
     * @param {string} docUrl
     */
    export function deprecationWarning(feature: string, futureVersion: string, alternative: string, docUrl?: string): void;
    /**
     * @internal
     * @param {undefined | null | Token} t
     * @param {Site} site
     * @param {string} msg
     * @returns {null | Token}
     */
    export function assertToken(t: undefined | null | Token, site: Site, msg?: string): null | Token;
    /**
     * Changes the value of BLAKE2B_DIGEST_SIZE
     *  (because the nodejs crypto module only supports
     *   blake2b-512 and not blake2b-256, and we want to avoid non-standard dependencies in the
     *   test-suite)
     * @internal
     * @param {number} s - 32 or 64
     */
    export function setBlake2bDigestSize(s: number): void;
    /**
     * @internal
     * @param {NumberGenerator} random
     * @param {number} n
     * @returns {number[]}
     */
    export function randomBytes(random: NumberGenerator, n: number): number[];
    /**
     * Dynamically constructs a new List class, depending on the item type.
     * @internal
     * @template {HeliosData} T
     * @param {HeliosDataClass<T>} ItemClass
     * @returns {HeliosDataClass<HList_>}
     */
    export function HList<T extends HeliosData>(ItemClass: HeliosDataClass<T>): HeliosDataClass<{
        /**
         * @type {T[]}
         */
        "__#1@#items": T[];
        /**
         * @internal
         * @type {string}
         */
        readonly _listTypeName: string;
        /**
         * @type {T[]}
         */
        readonly items: T[];
        /**
         * @internal
         * @returns {UplcData}
         */
        _toUplcData(): UplcData;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
        /**
         * Defaults to cbor encoding of uplc data structure.
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @returns {string}
         */
        toCborHex(): string;
    }>;
    /**
     * @internal
     * @template {HeliosData} TKey
     * @template {HeliosData} TValue
     * @param {HeliosDataClass<TKey>} KeyClass
     * @param {HeliosDataClass<TValue>} ValueClass
     * @returns {HeliosDataClass<HMap_>}
     */
    export function HMap<TKey extends HeliosData, TValue extends HeliosData>(KeyClass: HeliosDataClass<TKey>, ValueClass: HeliosDataClass<TValue>): HeliosDataClass<{
        /**
         * @type {[TKey, TValue][]}
         */
        "__#2@#pairs": [TKey, TValue][];
        /**
         * @internal
         * @type {string}
         */
        readonly _mapTypeName: string;
        /**
         * @type {[TKey, TValue][]}
         */
        readonly pairs: [TKey, TValue][];
        /**
         * @internal
         * @returns {UplcData}
         */
        _toUplcData(): UplcData;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
        /**
         * Defaults to cbor encoding of uplc data structure.
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @returns {string}
         */
        toCborHex(): string;
    }>;
    /**
     * @internal
     * @template {HeliosData} T
     * @param {HeliosDataClass<T>} SomeClass
     * @returns {HeliosDataClass<Option_>}
     */
    export function Option<T extends HeliosData>(SomeClass: HeliosDataClass<T>): HeliosDataClass<{
        /**
         * @type {?T}
         */
        "__#3@#value": T | null;
        /**
         * @internal
         * @type {string}
         */
        readonly _optionTypeName: string;
        /**
         * @type {?T}
         */
        readonly some: T | null;
        /**
         * @internal
         * @returns {UplcData}
         */
        _toUplcData(): UplcData;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
        /**
         * Defaults to cbor encoding of uplc data structure.
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @returns {string}
         */
        toCborHex(): string;
    }>;
    /**
     * Use this function to check cost-model parameters
     * @internal
     * @param {NetworkParams} networkParams
     */
    export function dumpCostModels(networkParams: NetworkParams): void;
    /**
     * Returns index of a named builtin
     * Throws an error if builtin doesn't exist
     * @internal
     * @param {string} name
     * @returns
     */
    export function findUplcBuiltin(name: string): number;
    /**
     * Checks if a named builtin exists
     * @internal
     * @param {string} name
     * @param {boolean} strict - if true then throws an error if builtin doesn't exist
     * @returns {boolean}
     */
    export function isUplcBuiltin(name: string, strict?: boolean): boolean;
    /**
     * @internal
     * @typedef {UplcConst | AppliedUplcBuiltin | UplcLambdaWithEnv | UplcDelayWithEnv} CekValue
     */
    /**
     * @internal
     * @typedef {{
     * 	 values: CekValue[],
     *   callSites: Site[]
     * }} CekEnv
     */
    /**
     * @internal
     * @typedef {{computing: UplcTerm, env: CekEnv}} ComputingState
     */
    /**
     * @internal
     * @typedef {{reducing: CekValue}} ReducingState
     */
    /**
     * @internal
     * @typedef {{error: string | RuntimeError, env: CekEnv}} ErrorState
     */
    /**
     * @internal
     * @typedef {ComputingState | ReducingState | ErrorState} CekState
     */
    /**
     * @internal
     * @param {UplcRte} rte
     * @param {UplcTerm} start
     * @param {null | UplcValue[]} args
     * @returns {Promise<UplcValue>}
     */
    export function evalCek(rte: UplcRte, start: UplcTerm, args?: null | UplcValue[]): Promise<UplcValue>;
    /**
     * Deserializes a flat encoded `UplcProgram`.
     * @param {number[]} bytes
     * @param {ProgramProperties} properties
     * @returns {UplcProgram}
     */
    export function deserializeUplcBytes(bytes: number[], properties?: ProgramProperties): UplcProgram;
    /**
     * Parses a plutus core program. Returns a `UplcProgram` instance.
     * @param {string | {cborHex: string}} json a raw JSON string or a parsed JSON object
     * @returns {UplcProgram}
     */
    export function deserializeUplc(json: string | {
        cborHex: string;
    }): UplcProgram;
    /**
     * Tokenizes a string (wrapped in Source)
     * Also used by VSCode plugin
     * @internal
     * @param {Source} src
     * @returns {Token[] | null}
     */
    export function tokenize(src: Source): Token[] | null;
    /**
     * Tokenizes an IR string with a codemap to the original source
     * @internal
     * @param {string} rawSrc
     * @param {CodeMap} codeMap
     * @returns {Token[]}
     */
    export function tokenizeIR(rawSrc: string, codeMap: CodeMap): Token[];
    /**
     * @template {HeliosData} T
     */
    /**
     * @internal
     * @typedef {{
     *   type:  string
     * } | {
     *   type:     "List"
     *   itemType: TypeSchema
     * } | {
     *   type:      "Map"
     *   keyType:   TypeSchema
     *   valueType: TypeSchema
     * } | {
     *   type:     "Option"
     *   someType: TypeSchema
     * } | {
     *   type:       "Struct"
     *   fieldTypes: NamedTypeSchema[]
     * } | {
     *   type:         "Enum"
     *   variantTypes: {name: string, fieldTypes: NamedTypeSchema[]}[]
     * }} TypeSchema
     */
    /**
     * @internal
     * @typedef {{
     * 	 name: string
     * } & TypeSchema} NamedTypeSchema
     */
    /**
     * @internal
     * @typedef {{
     *   name: string
     *   typeClass: TypeClass
     * }} ParameterI
     */
    /**
     * @internal
     * @typedef {Map<ParameterI, Type>} InferenceMap
     */
    /**
     * Used by the bundle cli command to generate a typescript annotations and (de)serialization code
     * inputTypes form a type union
     * @internal
     * @typedef {{
     *   inputType:    string
     *   outputType:   string
     *   internalType: TypeSchema
     * }} TypeDetails
     */
    /**
     * @internal
     * @typedef {{[name: string]: (obj: any) => Promise<UplcData>}} JsToUplcHelpers
     */
    /**
     * @internal
     * @typedef {{[name: string]: (data: UplcData) => Promise<any>}} UplcToJsHelpers
     */
    /**
     * @internal
     * @typedef {(obj: any, helpers: JsToUplcHelpers) => Promise<UplcData>} JsToUplcConverter
     */
    /**
     * @internal
     * @typedef {(data: UplcData, helpers: UplcToJsHelpers) => Promise<any>} UplcToJsConverter
     */
    /**
     * @internal
     * @typedef {Named & Type & {
     *   asDataType:   DataType
     *   fieldNames:   string[]
     *   offChainType: (null | HeliosDataClass<HeliosData>)
     *   typeDetails?: TypeDetails
     *   jsToUplc:     JsToUplcConverter
     *   uplcToJs:     UplcToJsConverter
     *   ready:        boolean
     * }} DataType
     */
    /**
     * @internal
     * @typedef {DataType & {
     *   asEnumMemberType: EnumMemberType
     *   constrIndex:      number
     *   parentType:       DataType
     * }} EnumMemberType
     */
    /**
     * EvalEntities assert themselves
     * @internal
     * @typedef {{
     *   asDataType:       (null | DataType)
     *   asEnumMemberType: (null | EnumMemberType)
     *   asFunc:           (null | Func)
     *   asInstance:       (null | Instance)
     *   asMulti:          (null | Multi)
     *   asNamed:          (null | Named)
     *   asNamespace:      (null | Namespace)
     *   asParametric:     (null | Parametric)
     * 	 asType:           (null | Type)
     *   asTyped:          (null | Typed)
     *   asTypeClass:      (null | TypeClass)
     *   toString():       string
     * }} EvalEntity
     */
    /**
     * @internal
     * @typedef {Typed & {
     *   asFunc: Func
     * 	 funcType: FuncType
     *   call(site: Site, args: Typed[], namedArgs?: {[name: string]: Typed}): (null | Typed | Multi)
     * }} Func
     */
    /**
     * @internal
     * @typedef {Typed & {
     *   asInstance:      Instance
     *   fieldNames:      string[]
     *   instanceMembers: InstanceMembers
     * }} Instance
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *	 asMulti: Multi
     *   values:  Typed[]
     * }} Multi
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asNamed: Named
     *   name:    string
     *   path:    string
     * }} Named
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asNamespace: Namespace
     *   namespaceMembers: NamespaceMembers
     * }} Namespace
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asParametric: Parametric
     *   offChainType: (null | ((...any) => HeliosDataClass<HeliosData>))
     *   typeClasses: TypeClass[]
     *   apply(types: Type[], site?: Site): EvalEntity
     *   inferCall(site: Site, args: Typed[], namedArgs?: {[name: string]: Typed}, paramTypes?: Type[]): Func
     * 	 infer(site: Site, map: InferenceMap): Parametric
     * }} Parametric
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asType:               Type
     *   instanceMembers:      InstanceMembers
     *   typeMembers:          TypeMembers
     *   isBaseOf(type: Type): boolean
     *   infer(site: Site, map: InferenceMap, type: null | Type): Type
     *   toTyped():            Typed
     *   isParametric():       boolean
     * }} Type
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asTyped: Typed
     *   type: Type
     * }} Typed
     */
    /**
     * @internal
     * @typedef {EvalEntity & {
     *   asTypeClass:                        TypeClass
     *   genInstanceMembers(impl: Type):     TypeClassMembers
     *   genTypeMembers(impl: Type):         TypeClassMembers
     *   isImplementedBy(type: Type):        boolean
     *   toType(name: string, path: string, parameter?: null | ParameterI): Type
     * }} TypeClass
     */
    /**
     * @internal
     * @typedef {{[name: string]: (Parametric | Type)}} InstanceMembers
     */
    /**
     * @internal
     * @typedef {{[name: string]: EvalEntity}} NamespaceMembers
     */
    /**
     * @internal
     * @typedef {{[name: string]: (Parametric | Type | Typed)}} TypeMembers
     */
    /**
     * @internal
     * @typedef {{[name: string]: Type}} TypeClassMembers
     */
    /**
     * @internal
     * @param {Parametric} parametric
     * @param {Type[]} types
     * @returns {DataType}
     */
    export function applyTypes(parametric: Parametric, ...types: Type[]): DataType;
    /**
     * @internal
     * @param {Type} type
     * @returns {InstanceMembers}
     */
    export function genCommonInstanceMembers(type: Type): InstanceMembers;
    /**
     * @internal
     * @param {Type} type
     * @returns {TypeMembers}
     */
    export function genCommonTypeMembers(type: Type): TypeMembers;
    /**
     * @internal
     * @param {Type} type
     * @param {Type} parentType
     * @returns {TypeMembers}
     */
    export function genCommonEnumTypeMembers(type: Type, parentType: Type): TypeMembers;
    /**
     * @internal
     * @param {Type[]} itemTypes
     * @returns {Type}
     */
    export function IteratorType$(itemTypes: Type[]): Type;
    /**
     * @internal
     * @param {Type} itemType
     * @returns {DataType}
     */
    export function ListType$(itemType: Type): DataType;
    /**
     * @internal
     * @param {Type} keyType
     * @param {Type} valueType
     * @returns {DataType}
     */
    export function MapType$(keyType: Type, valueType: Type): DataType;
    /**
     * @internal
     * @param {Type} someType
     * @returns {DataType}
     */
    export function OptionType$(someType: Type): DataType;
    /**
     * Set the statistics collector (used by the test-suite)
     * @internal
     * @param {(name: string, count: number) => void} callback
     */
    export function setRawUsageNotifier(callback: (name: string, count: number) => void): void;
    /**
     * Load all raw generics so all possible implementations can be generated correctly during type parameter injection phase
     * @internal
     * @param {ToIRContext} ctx
     * @returns {IRDefinitions}
     */
    export function fetchRawGenerics(ctx: ToIRContext): IRDefinitions;
    /**
     * Doesn't add templates
     * @internal
     * @param {ToIRContext} ctx
     * @param {IR} ir
     * @param {null | IRDefinitions} userDefs - some userDefs might have the __helios prefix
     * @returns {IRDefinitions}
     */
    export function fetchRawFunctions(ctx: ToIRContext, ir: IR, userDefs?: null | IRDefinitions): IRDefinitions;
    /**
     * @internal
     * @param {ToIRContext} ctx
     * @param {IR} ir
     * @returns {IR}
     */
    export function wrapWithRawFunctions(ctx: ToIRContext, ir: IR): IR;
    /**
     * Used by VSCode plugin and CLI
     * The sources can't be modified directly because that messes up the codemapping
     * @internal
     * @param {(path: StringLiteral) => (string | null)} fn
     */
    export function setImportPathTranslator(fn: (path: StringLiteral) => (string | null)): void;
    /**
     * @internal
     * @param {Token[]} ts
     * @returns {Statement[]}
     */
    export function buildProgramStatements(ts: Token[]): Statement[];
    /**
     * @internal
     * @param {Token[]} ts
     * @param {null | ScriptPurpose} expectedPurpose
     * @returns {[ScriptPurpose, Word] | null} - [purpose, name] (ScriptPurpose is an integer)
     * @internal
     */
    export function buildScriptPurpose(ts: Token[], expectedPurpose?: null | ScriptPurpose): [ScriptPurpose, Word] | null;
    /**
     * Also used by VSCode plugin
     * @internal
     * @param {Token[]} ts
     * @param {null | ScriptPurpose} expectedPurpose
     * @returns {[null | ScriptPurpose, Word | null, Statement[], number]}
     */
    export function buildScript(ts: Token[], expectedPurpose?: null | ScriptPurpose): [null | ScriptPurpose, Word | null, Statement[], number];
    /**
     * Quickly extract the script purpose header of a script source, by parsing only the minimally necessary characters.
     * @param {string} rawSrc
     * @returns {null | [ScriptPurpose, string]} Returns `null` if the script header is missing or syntactically incorrect. The first string returned is the script purpose, the second value returned is the script name.
     */
    export function extractScriptPurposeAndName(rawSrc: string): null | [ScriptPurpose, string];
    /**
     * Build an Intermediate Representation expression
     * @param {Token[]} ts
     * @returns {IRExpr}
     * @internal
     */
    export function buildIRExpr(ts: Token[]): IRExpr;
    /**
     * Returns Uint8Array with the same length as the number of chars in the script.
     * Each resulting byte respresents a different syntax category.
     * This approach should be faster than a RegExp based a approach.
     * @param {string} src
     * @returns {Uint8Array}
     */
    export function highlight(src: string): Uint8Array;
    /**
     * @internal
     * @param {TypeSchema} schema
     * @param {any} obj
     * @param {JsToUplcHelpers} helpers
     * @returns {Promise<UplcData>}
     */
    export function jsToUplcInternal(schema: TypeSchema, obj: any, helpers: JsToUplcHelpers): Promise<UplcData>;
    /**
     * @internal
     * @param {TypeSchema} schema
     * @param {any} obj
     * @param {JsToUplcHelpers} helpers
     * @returns {Promise<UplcData>}
     */
    export function jsToUplc(schema: TypeSchema, obj: any, helpers: JsToUplcHelpers): Promise<UplcData>;
    /**
     * @internal
     * @param {TypeSchema} schema
     * @param {UplcData} data
     * @param {UplcToJsHelpers} helpers
     * @returns {Promise<any>}
     */
    export function uplcToJs(schema: TypeSchema, data: UplcData, helpers: UplcToJsHelpers): Promise<any>;
    /**
     * Current version of the Helios library.
     */
    export const VERSION: "0.15.11";
    /**
     * A tab used for indenting of the IR.
     * 2 spaces.
     * @internal
     * @type {string}
     */
    export const TAB: string;
    /**
     * A Real in Helios is a fixed point number with REAL_PRECISION precision
     * @internal
     * @type {number}
     */
    export const REAL_PRECISION: number;
    export namespace config {
        function set(props: {
            DEBUG?: boolean | undefined;
            STRICT_BABBAGE?: boolean | undefined;
            IS_TESTNET?: boolean | undefined;
            N_DUMMY_INPUTS?: number | undefined;
            AUTO_SET_VALIDITY_RANGE?: boolean | undefined;
            VALIDITY_RANGE_START_OFFSET?: number | undefined;
            VALIDITY_RANGE_END_OFFSET?: number | undefined;
            IGNORE_UNEVALUATED_CONSTANTS?: boolean | undefined;
            CHECK_CASTS?: boolean | undefined;
            MAX_ASSETS_PER_CHANGE_OUTPUT?: number | undefined;
        }): void;
        const DEBUG: boolean;
        const STRICT_BABBAGE: boolean;
        const IS_TESTNET: boolean;
        const N_DUMMY_INPUTS: number;
        const AUTO_SET_VALIDITY_RANGE: boolean;
        const VALIDITY_RANGE_START_OFFSET: number;
        const VALIDITY_RANGE_END_OFFSET: number;
        const IGNORE_UNEVALUATED_CONSTANTS: boolean;
        const CHECK_CASTS: boolean;
        const MAX_ASSETS_PER_CHANGE_OUTPUT: undefined;
    }
    /**
     * Read non-byte aligned numbers
     * @internal
     */
    export class BitReader {
        /**
         * @param {number[]} bytes
         * @param {boolean} truncate - if true then read last bits as low part of number, if false pad with zero bits
         */
        constructor(bytes: number[], truncate?: boolean);
        /**
         * @internal
         * @returns {boolean}
         */
        eof(): boolean;
        /**
         * Reads a number of bits (<= 8) and returns the result as an unsigned number
         * @internal
         * @param {number} n - number of bits to read
         * @returns {number}
         */
        readBits(n: number): number;
        /**
         * Moves position to next byte boundary
         * @internal
         * @param {boolean} force - if true then move to next byte boundary if already at byte boundary
         */
        moveToByteBoundary(force?: boolean): void;
        /**
         * Reads 8 bits
         * @internal
         * @returns {number}
         */
        readByte(): number;
        /**
         * Dumps remaining bits we #pos isn't yet at end.
         * This is intended for debugging use.
         * @internal
         */
        dumpRemainingBits(): void;
        #private;
    }
    /**
     * BitWriter turns a string of '0's and '1's into a list of bytes.
     * Finalization pads the bits using '0*1' if not yet aligned with the byte boundary.
     * @internal
     */
    export class BitWriter {
        /**
         * @internal
         * @type {number}
         */
        get length(): number;
        /**
         * Write a string of '0's and '1's to the BitWriter.
         * @internal
         * @param {string} bitChars
         */
        write(bitChars: string): void;
        /**
         * @internal
         * @param {number} byte
         */
        writeByte(byte: number): void;
        /**
         * Add padding to the BitWriter in order to align with the byte boundary.
         * If 'force == true' then 8 bits are added if the BitWriter is already aligned.
         * @internal
         * @param {boolean} force
         */
        padToByteBoundary(force?: boolean): void;
        /**
         * Pop n bits of the end
         * @param {number} n
         * @returns {string}
         */
        pop(n: number): string;
        /**
         * Pads the BitWriter to align with the byte boundary and returns the resulting bytes.
         * @internal
         * @param {boolean} force - force padding (will add one byte if already aligned)
         * @returns {number[]}
         */
        finalize(force?: boolean): number[];
        #private;
    }
    /**
     * Function that generates a random number between 0 and 1
     * @typedef {() => number} NumberGenerator
     */
    /**
     * A Source instance wraps a string so we can use it cheaply as a reference inside a Site.
     * Also used by VSCode plugin
     */
    export class Source {
        /**
         * @param {string} raw
         * @param {string} name
         */
        constructor(raw: string, name: string);
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * @internal
         * @type {string}
         */
        get raw(): string;
        /**
         * @internal
         * @type {string}
         */
        get name(): string;
        /**
         * @type {Error[]}
         */
        get errors(): Error[];
        throwErrors(): void;
        /**
         * Get char from the underlying string.
         * Should work fine utf-8 runes.
         * @internal
         * @param {number} pos
         * @returns {string}
         */
        getChar(pos: number): string;
        /**
         * Returns word under pos
         * @internal
         * @param {number} pos
         * @returns {?string}
         */
        getWord(pos: number): string | null;
        /**
         * @internal
         * @type {number}
         */
        get length(): number;
        /**
         * Calculates the line number of the line where the given character is located (0-based).
         * @internal
         * @param {number} pos
         * @returns {number}
         */
        posToLine(pos: number): number;
        /**
         * Calculates the column and line number where the given character is located (0-based).
         * @internal
         * @param {number} pos
         * @returns {[number, number]}
         */
        posToLineAndCol(pos: number): [number, number];
        /**
         * Creates a more human-readable version of the source by prepending the line-numbers to each line.
         * The line-numbers are at least two digits.
         * @example
         * (new Source("hello\nworld")).pretty() == "01  hello\n02  world"
         * @internal
         * @returns {string}
         */
        pretty(): string;
        #private;
    }
    /**
     * Each Token/Expression/Statement has a Site, which encapsulates a position in a Source
     */
    export class Site {
        static dummy(): Site;
        /**
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {Site | null} codeMapSite
         */
        constructor(src: Source, startPos: number, endPos?: number, codeMapSite?: Site | null);
        /**
         *
         * @param {TransferUplcAst} other
         */
        transfer(other: TransferUplcAst): any;
        get src(): Source;
        get startPos(): number;
        get endPos(): number;
        get endSite(): Site | null;
        /**
         * @param {Site} other
         * @returns {Site}
         */
        merge(other: Site): Site;
        /**
         * @param {?Site} site
         */
        setEndSite(site: Site | null): void;
        /**
         * @type {?Site}
         */
        get codeMapSite(): Site | null;
        /**
         * @param {Site} site
         */
        setCodeMapSite(site: Site): void;
        /**
         * Returns a SyntaxError
         * @param {string} info
         * @returns {UserError}
         */
        syntaxError(info?: string): UserError;
        /**
         * Returns a TypeError
         * @param {string} info
         * @returns {UserError}
         */
        typeError(info?: string): UserError;
        /**
         * Returns a ReferenceError
         * @param {string} info
         * @returns {UserError}
         */
        referenceError(info?: string): UserError;
        /**
         * Calculates the column,line position in 'this.#src'
         * @returns {[number, number, number, number]} - [startLine, startCol, endLine, endCol]
         */
        getFilePos(): [number, number, number, number];
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * UserErrors are generated when the user of Helios makes a mistake (eg. a syntax error).
     */
    export class UserError extends Error {
        /**
         * @internal
         * @param {string} type
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {string} info
         */
        static new(type: string, src: Source, startPos: number, endPos: number, info?: string): UserError;
        /**
         * Constructs a SyntaxError
         * @internal
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {string} info
         * @returns {UserError}
         */
        static syntaxError(src: Source, startPos: number, endPos: number, info?: string): UserError;
        /**
         * Constructs a TypeError
         * @internal
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {string} info
         * @returns {UserError}
         */
        static typeError(src: Source, startPos: number, endPos: number, info?: string): UserError;
        /**
         * @param {Error} e
         * @returns {boolean}
         */
        static isTypeError(e: Error): boolean;
        /**
         * Constructs a ReferenceError (i.e. name undefined, or name unused)
         * @internal
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         * @param {string} info
         * @returns {UserError}
         */
        static referenceError(src: Source, startPos: number, endPos: number, info?: string): UserError;
        /**
         * @param {Error} e
         * @returns {boolean}
         */
        static isReferenceError(e: Error): boolean;
        /**
         * Catches any UserErrors thrown inside 'fn()`.
         * Dumps the error
         * @template T
         * @param {() => T} fn
         * @param {boolean} verbose
         * @returns {T | undefined}
         */
        static catch<T>(fn: () => T, verbose?: boolean): T | undefined;
        /**
         * @internal
         * @param {string} msg
         * @param {Source} src
         * @param {number} startPos
         * @param {number} endPos
         */
        constructor(msg: string, src: Source, startPos: number, endPos?: number);
        /**
         * @internal
         * @type {Source}
         */
        get src(): Source;
        /**
         * Filled with CBOR hex representations of Datum, Redeemer and ScriptContext by validation scripts throwing errors during `tx.finalize()`; and Redeemer and ScriptContext by minting scripts throwing errors.
         * @type {Object}
         */
        get context(): any;
        /**
         * @internal
         */
        get data(): void;
        /**
         * @internal
         * @type {number}
         */
        get startPos(): number;
        /**
         * Calculates column/line position in 'this.src'.
         * @internal
         * @returns {[number, number, number, number]} - [startLine, startCol, endLine, endCol]
         */
        getFilePos(): [number, number, number, number];
        /**
         * Dumps the error without throwing.
         * If 'verbose == true' the Source is also pretty printed with line-numbers.
         * @internal
         * @param {boolean} verbose
         */
        dump(verbose?: boolean): void;
        #private;
    }
    /**
     * Used for errors thrown during Uplc evaluation
     */
    export class RuntimeError extends Error {
        /**
         * @internal
         * @param {string} msg
         */
        constructor(msg: string);
        get context(): any;
        #private;
    }
    /**
     * Token is the base class of all Expressions and Statements
     * @internal
     */
    export class Token {
        /**
         * @param {Site} site
         */
        constructor(site: Site);
        get site(): Site;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * Returns 'true' if 'this' is a literal primitive, a literal struct constructor, or a literal function expression.
         * @returns {boolean}
         */
        isLiteral(): boolean;
        /**
         * Returns 'true' if 'this' is a Word token.
         * @param {?(string | string[])} value
         * @returns {boolean}
         */
        isWord(value?: (string | string[]) | null): boolean;
        /**
         * @returns {boolean}
         */
        isKeyword(): boolean;
        /**
         * Returns 'true' if 'this' is a Symbol token (eg. '+', '(' etc.)
         * @param {?(string | string[])} value
         * @returns {boolean}
         */
        isSymbol(value?: (string | string[]) | null): boolean;
        /**
         * Returns 'true' if 'this' is a group (eg. '(...)').
         * @param {?string} value
         * @param {number | null} nFields
         * @returns {boolean}
         */
        isGroup(value: string | null, nFields?: number | null): boolean;
        /**
         * Returns a SyntaxError at the current Site.
         * @param {string} msg
         * @returns {UserError}
         */
        syntaxError(msg: string): UserError;
        /**
         * Returns a TypeError at the current Site.
         * @param {string} msg
         * @returns {UserError}
         */
        typeError(msg: string): UserError;
        /**
         * Returns a ReferenceError at the current Site.
         * @param {string} msg
         * @returns {UserError}
         */
        referenceError(msg: string): UserError;
        /**
         * Throws a SyntaxError if 'this' isn't a Word.
         * @param {?(string | string[])} value
         * @returns {Word | null}
         */
        assertWord(value?: (string | string[]) | null): Word | null;
        /**
         * Throws a SyntaxError if 'this' isn't a Symbol.
         * @param {?(string | string[])} value
         * @returns {SymbolToken | null}
         */
        assertSymbol(value?: (string | string[]) | null): SymbolToken | null;
        /**
         * Throws a SyntaxError if 'this' isn't a Group.
         * @param {?string} type
         * @param {?number} nFields
         * @returns {Group | null}
         */
        assertGroup(type?: string | null, nFields?: number | null): Group | null;
        #private;
    }
    /**
     * A Word token represents a token that matches /[A-Za-z_][A-Za-z_0-9]/
     * @internal
     */
    export class Word extends Token {
        /**
         * @param {string} value
         * @returns {Word}
         */
        static new(value: string): Word;
        /**
         * Finds the index of the first Word(value) in a list of tokens
         * Returns -1 if none found
         * @param {Token[]} ts
         * @param {string | string[]} value
         * @returns {number}
         */
        static find(ts: Token[], value: string | string[]): number;
        /**
         * @param {Site} site
         * @param {string} value
         */
        constructor(site: Site, value: string);
        get value(): string;
        /**
         * @param {?(string | string[])} value
         * @returns {Word}
         */
        assertWord(value?: (string | string[]) | null): Word;
        /**
         * @returns {Word}
         */
        assertNotInternal(): Word;
        /**
         * @returns {Word | null}
         */
        assertNotKeyword(): Word | null;
        #private;
    }
    /**
     * Symbol token represent anything non alphanumeric
     * @internal
     */
    export class SymbolToken extends Token {
        /**
         * Finds the index of the first Symbol(value) in a list of tokens.
         * Returns -1 if none found.
         * @param {Token[]} ts
         * @param {string | string[]} value
         * @returns {number}
         */
        static find(ts: Token[], value: string | string[]): number;
        /**
         * Finds the index of the last Symbol(value) in a list of tokens.
         * Returns -1 if none found.
         * @param {Token[]} ts
         * @param {string | string[]} value
         * @returns {number}
         */
        static findLast(ts: Token[], value: string | string[]): number;
        /**
         * @param {Site} site
         * @param {string} value
         */
        constructor(site: Site, value: string);
        get value(): string;
        /**
         * @param {?(string | string[])} value
         * @returns {SymbolToken}
         */
        assertSymbol(value: (string | string[]) | null): SymbolToken;
        #private;
    }
    /**
     * Group token can '(...)', '[...]' or '{...}' and can contain comma separated fields.
     * @internal
     */
    export class Group extends Token {
        /**
         * @param {Token} t
         * @returns {boolean}
         */
        static isOpenSymbol(t: Token): boolean;
        /**
         * @param {Token} t
         * @returns {boolean}
         */
        static isCloseSymbol(t: Token): boolean;
        /**
         * Returns the corresponding closing bracket, parenthesis or brace.
         * Throws an error if not a group symbol.
         * @example
         * Group.matchSymbol("(") == ")"
         * @param {string | SymbolToken} t
         * @returns {string}
         */
        static matchSymbol(t: string | SymbolToken): string;
        /**
         * Finds the index of first Group(type) in list of tokens
         * Returns -1 if none found.
         * @param {Token[]} ts
         * @param {string} type
         * @returns {number}
         */
        static find(ts: Token[], type: string): number;
        /**
         * @param {Site} site
         * @param {string} type - "(", "[" or "{"
         * @param {Token[][]} fields
         * @param {?SymbolToken} firstComma
         */
        constructor(site: Site, type: string, fields: Token[][], firstComma?: SymbolToken | null);
        get fields(): Token[][];
        /**
         * @param {?string} type
         * @param {number | null} nFields
         * @returns {boolean}
         */
        isGroup(type?: string | null, nFields?: number | null): boolean;
        #private;
    }
    /**
     * Base class of literal tokens
     * @internal
     */
    export class PrimitiveLiteral extends Token {
    }
    /**
     * Signed int literal token
     * @internal
     */
    export class IntLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {bigint} value
         */
        constructor(site: Site, value: bigint);
        get value(): bigint;
        #private;
    }
    /**
     * Fixed point number literal token
     * @internal
     */
    export class RealLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {bigint} value
         */
        constructor(site: Site, value: bigint);
        get value(): bigint;
        #private;
    }
    /**
     * Bool literal token
     * @internal
     */
    export class BoolLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {boolean} value
         */
        constructor(site: Site, value: boolean);
        get value(): boolean;
        #private;
    }
    /**
     * ByteArray literal token
     * @internal
     */
    export class ByteArrayLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {number[]} bytes
         */
        constructor(site: Site, bytes: number[]);
        get bytes(): number[];
        #private;
    }
    /**
     * String literal token (utf8)
     * @internal
     */
    export class StringLiteral extends PrimitiveLiteral {
        /**
         * @param {Site} site
         * @param {string} value
         */
        constructor(site: Site, value: string);
        get value(): string;
        #private;
    }
    /**
     * @internal
     * @typedef {[number, Site][]} CodeMap
     */
    /**
     * @internal
     * @typedef {Map<string, IR>} IRDefinitions
     */
    /**
     * The IR class combines a string of intermediate representation sourcecode with an optional site.
     * The site is used for mapping IR code to the original source code.
     * @internal
     */
    export class IR {
        /**
         * Wraps 'inner' IR source with some definitions (used for top-level statements and for builtins)
         * @internal
         * @param {IR} inner
         * @param {IRDefinitions} definitions - name -> definition
         * @returns {IR}
         */
        static wrapWithDefinitions(inner: IR, definitions: IRDefinitions): IR;
        /**
         * @param {string | IR[]} content
         * @param {null | Site} site
         */
        constructor(content: string | IR[], site?: null | Site);
        /**
         * @internal
         * @type {string | IR[]}
         */
        get content(): string | IR[];
        /**
         * @internal
         * @type {?Site}
         */
        get site(): Site | null;
        /**
         * @returns {any}
         */
        dump(): any;
        /**
         * Returns a list containing IR instances that themselves only contain strings
         * @internal
         * @returns {IR[]}
         */
        flatten(): IR[];
        /**
         * Intersperse nested IR content with a separator
         * @internal
         * @param {string} sep
         * @returns {IR}
         */
        join(sep: string): IR;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @internal
         * @returns {[string, CodeMap]}
         */
        generateSource(): [string, CodeMap];
        /**
         * @returns {string}
         */
        pretty(): string;
        /**
         * @param {string} str
         * @returns {boolean}
         */
        includes(str: string): boolean;
        /**
         * @param {RegExp} re
         * @param {string} newStr
         * @returns {IR}
         */
        replace(re: RegExp, newStr: string): IR;
        /**
         *
         * @param {RegExp} re
         * @param {(match: string) => void} callback
         */
        search(re: RegExp, callback: (match: string) => void): void;
        #private;
    }
    /**
     * @internal
     */
    export const RE_IR_PARAMETRIC_NAME: RegExp;
    /**
     * Type type parameter prefix
     * @internal
     */
    export const TTPP: "__T";
    /**
     * Func type parameter prefix
     * @internal
     */
    export const FTPP: "__F";
    /**
     * @internal
     */
    export class IRParametricName {
        /**
         * @param {string} base
         * @param {number} nTtps
         * @param {string} fn
         * @param {number} nFtps
         * @returns
         */
        static newTemplate(base: string, nTtps: number, fn?: string, nFtps?: number): IRParametricName;
        /**
         * @example
         * IRParametricName.matches("__helios__map[__T0@__T1]__fold[__F2@__F3]") == true
         * @example
         * IRParametricName.matches("__helios__int") == false
         * @example
         * IRParametricName.matches("__helios__option[__T0]__none__new") == true
         * @param {string} str
         * @returns {boolean}
         */
        static matches(str: string): boolean;
        /**
         * @param {string} name
         * @returns {boolean}
         */
        static isTemplate(name: string): boolean;
        /**
         * @example
         * IRParametricName.parse("__helios__map[__T0@__T1]__fold[__F0@__F1]").toString() == "__helios__map[__T0@__T1]__fold[__F0@__F1]"
         * @example
         * IRParametricName.parse("__helios__map[__helios__bytearray@__helios__map[__helios__bytearray@__helios__int]]__fold[__F0@__F1]").toString() == "__helios__map[__helios__bytearray@__helios__map[__helios__bytearray@__helios__int]]__fold[__F0@__F1]"
         * @example
         * IRParametricName.parse("__helios__map[__helios__bytearray@__helios__map[__helios__bytearray@__helios__list[__T0]]]__fold[__F0@__F1]").toString() == "__helios__map[__helios__bytearray@__helios__map[__helios__bytearray@__helios__list[__T0]]]__fold[__F0@__F1]"
         * @param {string} str
         * @param {boolean} preferType
         * @returns {IRParametricName}
         */
        static parse(str: string, preferType?: boolean): IRParametricName;
        /**
         * @param {string} base
         * @param {string[]} ttp
         * @param {string} fn
         * @param {string[]} ftp
         */
        constructor(base: string, ttp: string[], fn?: string, ftp?: string[]);
        /**
         * @type {string}
         */
        get base(): string;
        /**
         * @param {string[]} ttp
         * @param {string[]} ftp
         * @returns {IRParametricName}
         */
        toImplementation(ttp: string[], ftp?: string[]): IRParametricName;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @return {string}
         */
        toTemplate(): string;
        /**
         * @param {IR} ir
         * @returns {IR}
         */
        replaceTemplateNames(ir: IR): IR;
        #private;
    }
    export namespace Crypto {
        function mulberry32(seed: number): NumberGenerator;
        function rand(seed: number): NumberGenerator;
        function encodeBase32(bytes: number[], alphabet?: string): string;
        function decodeBase32(encoded: string, alphabet?: string): number[];
        function encodeBech32(hrp: string, data: number[]): string;
        function decodeBech32(addr: string): [string, number[]];
        function verifyBech32(encoded: string): boolean;
        function sha2_256(bytes: number[]): number[];
        function sha2_512(bytes: number[]): number[];
        function sha3(bytes: number[]): number[];
        function blake2b(bytes: number[], digestSize?: number): number[];
        function hmacSha2_256(key: number[], message: number[]): number[];
        function hmacSha2_512(key: number[], message: number[]): number[];
        function pbkdf2(prf: (key: number[], msg: number[]) => number[], password: number[], salt: number[], iters: number, dkLength: number): number[];
    }
    export namespace Ed25519 {
        function deriveBip32PublicKey(extendedKey: number[]): number[];
        function derivePublicKey(privateKey: number[]): number[];
        function signBip32(message: number[], extendedKey: number[]): number[];
        function sign(message: number[], privateKey: number[]): number[];
        function verify(signature: number[], message: number[], publicKey: number[]): boolean;
    }
    /**
     * Standard English Bip39 dictionary consisting of 2048 words allowing wallet root keys to be formed by a phrase of 12, 15, 18, 21 or 24 of these words.
     */
    export const BIP39_DICT_EN: string[];
    /**
     * @typedef {(i: number, bytes: number[]) => void} Decoder
     */
    /**
     * Base class of any Cbor serializable data class
     * Also
     */
    export class CborData {
        /**
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @returns {string}
         */
        toCborHex(): string;
    }
    export namespace Cbor {
        function encodeHead(m: number, n: bigint): number[];
        function decodeHead(bytes: number[]): [number, bigint];
        function encodeIndefHead(m: number): number[];
        function decodeIndefHead(bytes: number[]): number;
        function isNull(bytes: number[]): boolean;
        function encodeNull(): number[];
        function decodeNull(bytes: number[]): void;
        function encodeBool(b: boolean): number[];
        function decodeBool(bytes: number[]): boolean;
        function isBytes(bytes: number[]): boolean;
        function isDefBytes(bytes: number[]): boolean;
        function isIndefBytes(bytes: number[]): boolean;
        function encodeBytes(bytes: number[], splitIntoChunks?: boolean): number[];
        function decodeBytes(bytes: number[]): number[];
        function isUtf8(bytes: number[]): boolean;
        function encodeUtf8(str: string, split?: boolean): number[];
        function decodeUtf8Internal(bytes: number[]): string;
        function decodeUtf8(bytes: number[]): string;
        function encodeInteger(n: bigint): number[];
        function decodeInteger(bytes: number[]): bigint;
        function isIndefList(bytes: number[]): boolean;
        function encodeIndefListStart(): number[];
        function encodeListInternal(list: CborData[] | number[][]): number[];
        function encodeIndefListEnd(): number[];
        function encodeList(list: CborData[] | number[][]): number[];
        function encodeIndefList(list: CborData[] | number[][]): number[];
        function isDefList(bytes: number[]): boolean;
        function encodeDefListStart(n: bigint): number[];
        function encodeDefList(list: CborData[] | number[][]): number[];
        function isList(bytes: number[]): boolean;
        function decodeList(bytes: number[], itemDecoder: Decoder): void;
        function isTuple(bytes: number[]): boolean;
        function encodeTuple(tuple: number[][]): number[];
        function decodeTuple(bytes: number[], tupleDecoder: Decoder): number;
        function isMap(bytes: number[]): boolean;
        function encodeMapInternal(pairList: [number[] | CborData, number[] | CborData][]): number[];
        function encodeMap(pairList: [number[] | CborData, number[] | CborData][]): number[];
        function decodeMap(bytes: number[], pairDecoder: Decoder): void;
        function isObject(bytes: number[]): boolean;
        function encodeObject(object: Map<number, number[] | CborData>): number[];
        function decodeObject(bytes: number[], fieldDecoder: Decoder): Set<number>;
        function encodeTag(tag: bigint): number[];
        function decodeTag(bytes: number[]): bigint;
        function isConstr(bytes: number[]): boolean;
        function encodeConstrTag(tag: number): number[];
        function encodeConstr(tag: number, fields: CborData[] | number[][]): number[];
        function decodeConstrTag(bytes: number[]): number;
        function decodeConstr(bytes: number[], fieldDecoder: Decoder): number;
    }
    /**
     * Base class for Plutus-core data classes (not the same as Plutus-core value classes!)
     */
    export class UplcData extends CborData {
        /**
         * @param {number[] | string} bytes
         * @returns {UplcData}
         */
        static fromCbor(bytes: number[] | string): UplcData;
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * Estimate of memory usage during validation
         * @type {number}
         */
        get memSize(): number;
        /**
         * Compares the schema jsons
         * @param {UplcData} other
         * @returns {boolean}
         */
        isSame(other: UplcData): boolean;
        /**
         * @internal
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @internal
         * @type {bigint}
         */
        get int(): bigint;
        /**
         * @internal
         * @type {number}
         */
        get index(): number;
        /**
         * @internal
         * @type {UplcData[]}
         */
        get fields(): UplcData[];
        /**
         * @internal
         * @type {UplcData[]}
         */
        get list(): UplcData[];
        /**
         * @internal
         * @type {[UplcData, UplcData][]}
         */
        get map(): [UplcData, UplcData][];
        /**
         * @internal
         * @returns {IR}
         */
        toIR(): IR;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
    }
    /**
     * Represents an unbounded integer (bigint).
     */
    export class IntData extends UplcData {
        /**
         * Calculate the mem size of a integer (without the DATA_NODE overhead)
         * @internal
         * @param {bigint} value
         * @returns {number}
         */
        static memSizeInternal(value: bigint): number;
        /**
         * @param {number[]} bytes
         * @returns {IntData}
         */
        static fromCbor(bytes: number[]): IntData;
        /**
         * @param {bigint} value
         */
        constructor(value: bigint);
        /**
         * @type {bigint}
         */
        get value(): bigint;
        #private;
    }
    /**
     * Plutus-core bytearray data class.
     * Wraps a regular list of uint8 numbers (so not Uint8Array)
     */
    export class ByteArrayData extends UplcData {
        /**
         * Applies utf-8 encoding
         * @param {string} s
         * @returns {ByteArrayData}
         */
        static fromString(s: string): ByteArrayData;
        /**
         * Calculates the mem size of a byte array without the DATA_NODE overhead.
         * @param {number[]} bytes
         * @returns {number}
         */
        static memSizeInternal(bytes: number[]): number;
        /**
         * @param {number[]} bytes
         * @returns {ByteArrayData}
         */
        static fromCbor(bytes: number[]): ByteArrayData;
        /**
         * Bytearray comparison, which can be used for sorting bytearrays
         * @internal
         * @example
         * ByteArrayData.comp(hexToBytes("0101010101010101010101010101010101010101010101010101010101010101"), hexToBytes("0202020202020202020202020202020202020202020202020202020202020202")) == -1
         * @param {number[]} a
         * @param {number[]} b
         * @returns {number} - 0 -> equals, 1 -> gt, -1 -> lt
         */
        static comp(a: number[], b: number[]): number;
        /**
         * @param {number[]} bytes
         */
        constructor(bytes: number[]);
        /**
         * @returns {string}
         */
        toHex(): string;
        /**
         * @type {string}
         */
        get hex(): string;
        #private;
    }
    /**
     * Represents a list of other `UplcData` instances.
     */
    export class ListData extends UplcData {
        /**
         * @param {number[]} bytes
         * @returns {ListData}
         */
        static fromCbor(bytes: number[]): ListData;
        /**
         * @param {UplcData[]} items
         */
        constructor(items: UplcData[]);
        #private;
    }
    /**
     * Represents a list of pairs of other `UplcData` instances.
     */
    export class MapData extends UplcData {
        /**
         * @param {number[]} bytes
         * @returns {MapData}
         */
        static fromCbor(bytes: number[]): MapData;
        /**
         * @param {[UplcData, UplcData][]} pairs
         */
        constructor(pairs: [UplcData, UplcData][]);
        #private;
    }
    /**
     * Represents a tag index and a list of `UplcData` fields.
     */
    export class ConstrData extends UplcData {
        /**
         * @param {number[]} bytes
         * @returns {ConstrData}
         */
        static fromCbor(bytes: number[]): ConstrData;
        /**
         * @param {number} index
         * @param {UplcData[]} fields
         */
        constructor(index: number, fields: UplcData[]);
        #private;
    }
    /**
     * Base-type of all data-types that exist both on- and off-chain, and map directly to Helios instances.
     * @deprecated
     */
    export class HeliosData extends CborData {
        /**
         * Most HeliosData classes are builtins.
         * @internal
         * @returns {boolean}
         */
        static isBuiltin(): boolean;
        /**
         * Name begins with underscore so it can never conflict with structure field names.
         * @internal
         * @returns {UplcData}
         */
        _toUplcData(): UplcData;
        /**
         * @returns {string}
         */
        toSchemaJson(): string;
    }
    /**
     * Deprecated
     * @internal
     * @template {HeliosData} T
     * @typedef {{
     *   new(...args: any[]): T
     *   fromUplcCbor: (bytes: (string | number[])) => T
     *   fromUplcData: (data: UplcData) => T
     *   isBuiltin(): boolean
     * }} HeliosDataClass
     */
    /**
     * @deprecated
     * @typedef {number | bigint} HIntProps
     */
    /**
     * Helios Int type
     * @deprecated
     */
    export class HInt extends HeliosData {
        /**
         * @internal
         * @param {HIntProps} rawValue
         * @returns {bigint}
         */
        static cleanConstructorArg(rawValue: HIntProps): bigint;
        /**
         * @param {HInt | HIntProps} props
         * @returns {HInt}
         */
        static fromProps(props: HInt | HIntProps): HInt;
        /**
         * @param {UplcData} data
         * @returns {HInt}
         */
        static fromUplcData(data: UplcData): HInt;
        /**
         * @param {string | number[]} bytes
         * @returns {HInt}
         */
        static fromUplcCbor(bytes: string | number[]): HInt;
        /**
         * @param {number[]} bytes
         * @returns {HInt}
         */
        static fromCbor(bytes: number[]): HInt;
        /**
         * @param {HIntProps} rawValue
         */
        constructor(rawValue: HIntProps);
        /**
         * @type {bigint}
         */
        get value(): bigint;
        /**
         * @returns {string}
         */
        dump(): string;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        eq(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        neq(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        ge(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        gt(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        le(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt | HIntProps} other
         * @returns {boolean}
         */
        lt(other: HInt | HIntProps): boolean;
        /**
         * @param {HInt| HIntProps} other
         * @returns {HInt}
         */
        add(other: HInt | HIntProps): HInt;
        /**
         * @param {HInt | HIntProps} other
         * @returns {HInt}
         */
        sub(other: HInt | HIntProps): HInt;
        /**
         * @param {HInt| HIntProps} other
         * @returns {HInt}
         */
        mul(other: HInt | HIntProps): HInt;
        #private;
    }
    /**
     * @internal
     * @typedef {number | bigint | string | Date} TimeProps
     */
    /**
     * Milliseconds since 1 jan 1970
     * @internal
     */
    export class Time extends HInt {
        /**
        * @internal
        * @param {TimeProps} props
        * @returns {bigint}
        */
        static cleanConstructorArg(props: TimeProps): bigint;
        /**
         * @param {Time | TimeProps} props
         * @returns {Time}
         */
        static fromProps(props: Time | TimeProps): Time;
        /**
         * @param {TimeProps} props
         */
        constructor(props: TimeProps);
    }
    /**
     * @internal
     * @typedef {HIntProps} DurationProps
     */
    /**
     * Difference between two time values in milliseconds.
     * @internal
     */
    export class Duration extends HInt {
    }
    /**
     * @internal
     * @typedef {boolean | string} BoolProps
     */
    /**
     * Helios Bool type
     * @internal
     */
    export class Bool extends HeliosData {
        /**
         * @internal
         * @param {BoolProps} props
         * @returns {boolean}
         */
        static cleanConstructorArg(props: BoolProps): boolean;
        /**
         * @param {Bool | BoolProps} props
         * @returns {Bool}
         */
        static fromProps(props: Bool | BoolProps): Bool;
        /**
         * @param {UplcData} data
         * @returns {Bool}
         */
        static fromUplcData(data: UplcData): Bool;
        /**
         * @param {string | number[]} bytes
         * @returns {Bool}
         */
        static fromUplcCbor(bytes: string | number[]): Bool;
        /**
         * @param {BoolProps} props
         */
        constructor(props: BoolProps);
        /**
         * @type {boolean}
         */
        get bool(): boolean;
        #private;
    }
    /**
     * @internal
     * @typedef {string} HStringProps
     */
    /**
     * Helios String type.
     * Can't be named 'String' because that would interfere with the javascript 'String'-type
     * @internal
     */
    export class HString extends HeliosData {
        /**
         * @param {HString | HStringProps} props
         * @returns {HString}
         */
        static fromProps(props: HString | HStringProps): HString;
        /**
         * @param {UplcData} data
         * @returns {HString}
         */
        static fromUplcData(data: UplcData): HString;
        /**
         * @param {string | number[]} bytes
         * @returns {HString}
         */
        static fromUplcCbor(bytes: string | number[]): HString;
        /**
         * @param {HStringProps} props
         */
        constructor(props: HStringProps);
        /**
         * @type {string}
         */
        get string(): string;
        #private;
    }
    /**
     * @deprecated
     * @typedef {number[] | string} ByteArrayProps
     */
    /**
     * Helios ByteArray type
     * @deprecated
     */
    export class ByteArray extends HeliosData {
        /**
         * @internal
         * @param {ByteArrayProps} props
         */
        static cleanConstructorArg(props: ByteArrayProps): number[];
        /**
         * @param {ByteArray | ByteArrayProps} props
         * @returns {ByteArray}
         */
        static fromProps(props: ByteArray | ByteArrayProps): ByteArray;
        /**
         * @param {UplcData} data
         * @returns {ByteArray}
         */
        static fromUplcData(data: UplcData): ByteArray;
        /**
         * @param {string | number[]} bytes
         * @returns {ByteArray}
         */
        static fromUplcCbor(bytes: string | number[]): ByteArray;
        /**
         * @param {number[]} bytes
         * @returns {ByteArray}
         */
        static fromCbor(bytes: number[]): ByteArray;
        /**
         * @param {ByteArrayProps} props
         */
        constructor(props: ByteArrayProps);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * Hexadecimal representation.
         * @type {string}
         */
        get hex(): string;
        /**
         * @param {ByteArray | ByteArrayProps} other
         * @returns {boolean}
         */
        eq(other: ByteArray | ByteArrayProps): boolean;
        #private;
    }
    /**
     * @typedef {number[] | string} HashProps
     */
    /**
     * Base class of all hash-types
     */
    export class Hash extends HeliosData {
        /**
         * @internal
         * @param {HashProps} props
         * @returns {number[]}
         */
        static cleanConstructorArg(props: HashProps): number[];
        /**
         * @param {Hash | HashProps} props
         * @returns {Hash}
         */
        static fromProps(props: Hash | HashProps): Hash;
        /**
         * Used internally for metadataHash and scriptDataHash
         * @param {number[]} bytes
         * @returns {Hash}
         */
        static fromCbor(bytes: number[]): Hash;
        /**
         * Might be needed for internal use
         * @param {string} str
         * @returns {Hash}
         */
        static fromHex(str: string): Hash;
        /**
         * @param {Hash} a
         * @param {Hash} b
         * @returns {number}
         */
        static compare(a: Hash, b: Hash): number;
        /**
         * @param {HashProps} props
         */
        constructor(props: HashProps);
        /**
         * @readonly
         * @type {number[]}
         */
        readonly bytes: number[];
        /**
         * Hexadecimal representation.
         * @returns {string}
         */
        get hex(): string;
        /**
         * @internal
         * @returns {string}
         */
        dump(): string;
        /**
         * @param {Hash} other
         * @returns {boolean}
         */
        eq(other: Hash): boolean;
    }
    /**
     * @typedef {HashProps} DatumHashProps
     */
    /**
     * Represents a blake2b-256 hash of datum data.
     */
    export class DatumHash extends Hash {
        /**
         * @param {UplcData} data
         * @returns {DatumHash}
         */
        static fromUplcData(data: UplcData): DatumHash;
        /**
         * @param {string | number[]} bytes
         * @returns {DatumHash}
         */
        static fromUplcCbor(bytes: string | number[]): DatumHash;
    }
    /**
     * @typedef {number[] | string} PubKeyProps
     */
    export class PubKey extends HeliosData {
        /**
         * @param {PubKey | PubKeyProps} props
         * @returns {PubKey}
         */
        static fromProps(props: PubKey | PubKeyProps): PubKey;
        /**
         * @returns {PubKey}
         */
        static dummy(): PubKey;
        /**
         * @param {UplcData} data
         * @returns {PubKey}
         */
        static fromUplcData(data: UplcData): PubKey;
        /**
         * @param {string | number[]} bytes
         * @returns {PubKey}
         */
        static fromUplcCbor(bytes: string | number[]): PubKey;
        /**
         * @param {number[]} bytes
         * @returns {PubKey}
         */
        static fromCbor(bytes: number[]): PubKey;
        /**
         * @param {PubKeyProps} props
         */
        constructor(props: PubKeyProps);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * Hexadecimal representation.
         * @type {string}
         */
        get hex(): string;
        /**
         * Can also be used as a Stake key hash
         * @type {PubKeyHash}
         */
        get pubKeyHash(): PubKeyHash;
        /**
         * @returns {boolean}
         */
        isDummy(): boolean;
        /**
         * @returns {number[]}
         */
        hash(): number[];
        /**
         * @returns {string}
         */
        dump(): string;
        #private;
    }
    /**
     * Represents a blake2b-224 hash of a PubKey
     *
     * **Note**: A `PubKeyHash` can also be used as the second part of a payment `Address`, or to construct a `StakeAddress`.
     * @typedef {HashProps} PubKeyHashProps
     */
    export class PubKeyHash extends Hash {
        /**
         * @returns {PubKeyHash}
         */
        static dummy(): PubKeyHash;
        /**
         * @param {UplcData} data
         * @returns {PubKeyHash}
         */
        static fromUplcData(data: UplcData): PubKeyHash;
        /**
         * @param {string | number[]} bytes
         * @returns {PubKeyHash}
         */
        static fromUplcCbor(bytes: string | number[]): PubKeyHash;
    }
    /**
     * @internal
     * @typedef {HashProps} ScriptHashProps
     */
    /**
     * Base class of MintingPolicyHash, ValidatorHash and StakingValidatorHash
     */
    export class ScriptHash extends Hash {
    }
    /**
     * @typedef {HashProps} MintingPolicyHashProps
     */
    /**
     * Represents a blake2b-224 hash of a minting policy script
     *
     * **Note**: to calculate this hash the script is first encoded as a CBOR byte-array and then prepended by a script version byte.
     */
    export class MintingPolicyHash extends ScriptHash {
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} props
         * @returns {MintingPolicyHash}
         */
        static fromProps(props: MintingPolicyHash | MintingPolicyHashProps): MintingPolicyHash;
        /**
         * @param {number[]} bytes
         * @returns {MintingPolicyHash}
         */
        static fromCbor(bytes: number[]): MintingPolicyHash;
        /**
         * @param {UplcData} data
         * @returns {MintingPolicyHash}
         */
        static fromUplcData(data: UplcData): MintingPolicyHash;
        /**
         * @param {string | number[]} bytes
         * @returns {MintingPolicyHash}
         */
        static fromUplcCbor(bytes: string | number[]): MintingPolicyHash;
        /**
         * @param {string} str
         * @returns {MintingPolicyHash}
         */
        static fromHex(str: string): MintingPolicyHash;
        /**
         * Encodes as bech32 string using 'asset' as human readable part
         * @returns {string}
         */
        toBech32(): string;
    }
    /**
     * @typedef {HashProps} StakingValidatorHashProps
     */
    /**
     * Represents a blake2b-224 hash of a staking script.
     *
     * **Note**: before hashing, the staking script is first encoded as a CBOR byte-array and then prepended by a script version byte.
     */
    export class StakingValidatorHash extends ScriptHash {
        /**
         * @param {UplcData} data
         * @returns {StakingValidatorHash}
         */
        static fromUplcData(data: UplcData): StakingValidatorHash;
        /**
         * @param {string | number[]} bytes
         * @returns {StakingValidatorHash}
         */
        static fromUplcCbor(bytes: string | number[]): StakingValidatorHash;
    }
    /**
     * @typedef {HashProps} ValidatorHashProps
     */
    /**
     * Represents a blake2b-224 hash of a spending validator script (first encoded as a CBOR byte-array and prepended by a script version byte).
     */
    export class ValidatorHash extends ScriptHash {
        /**
         * @param {UplcData} data
         * @returns {ValidatorHash}
         */
        static fromUplcData(data: UplcData): ValidatorHash;
        /**
         * @param {string | number[]} bytes
         * @returns {ValidatorHash}
         */
        static fromUplcCbor(bytes: string | number[]): ValidatorHash;
    }
    /**
     * @typedef {HashProps} TxIdProps
     */
    /**
     * Represents the hash of a transaction.
     *
     * This is also used to identify an UTxO (along with the index of the UTxO in the list of UTxOs created by the transaction).
     */
    export class TxId extends Hash {
        /**
         * @param {UplcData} data
         * @returns {TxId}
         */
        static fromUplcData(data: UplcData): TxId;
        /**
         * @param {string | number[]} bytes
         * @returns {TxId}
         */
        static fromUplcCbor(bytes: string | number[]): TxId;
        /**
         * Filled with 255 so that the internal show() function has max execution budget cost
         * @param {number} fill
         * @returns {TxId}
         */
        static dummy(fill?: number): TxId;
    }
    /**
     * @typedef {string | [
     * 	 TxId | TxIdProps,
     *   HInt | HIntProps
     * ] | {
     *   txId: TxId | TxIdProps
     *   utxoId: HInt | HIntProps
     * }} TxOutputIdProps
     */
    /**
     * Id of a Utxo
     */
    export class TxOutputId extends HeliosData {
        /**
         * @param  {TxOutputIdProps} props
         * @returns {[TxId | TxIdProps, HInt | HIntProps]}
         */
        static cleanConstructorArgs(props: TxOutputIdProps): [TxId | TxIdProps, HInt | HIntProps];
        /**
         * @returns {TxOutputId}
         */
        static dummy(): TxOutputId;
        /**
         * @param {TxOutputId | TxOutputIdProps} props
         * @returns {TxOutputId}
         */
        static fromProps(props: TxOutputId | TxOutputIdProps): TxOutputId;
        /**
         * @param {UplcData} data
         * @returns {TxOutputId}
         */
        static fromUplcData(data: UplcData): TxOutputId;
        /**
         * @param {string | number[]} bytes
         * @returns {TxOutputId}
         */
        static fromUplcCbor(bytes: string | number[]): TxOutputId;
        /**
         * @param {string | number[]} rawBytes
         * @returns {TxOutputId}
         */
        static fromCbor(rawBytes: string | number[]): TxOutputId;
        /**
         *
         * @param {TxOutputId} a
         * @param {TxOutputId} b
         * @returns {number}
         */
        static comp(a: TxOutputId, b: TxOutputId): number;
        /**
         * @overload
         * @param {TxId} txId
         * @param {bigint | number} utxoId
         */
        /**
         * @overload
         * @param {TxOutputIdProps} props
         */
        /**
         * @param {([TxOutputIdProps] | [TxId, bigint | number])} args
         */
        constructor(...args: ([TxOutputIdProps] | [TxId, bigint | number]));
        /**
         * @type {TxId}
         */
        get txId(): TxId;
        /**
         * @type {number}
         */
        get utxoIdx(): number;
        /**
         * @param {TxOutputId} other
         * @returns {boolean}
         */
        eq(other: TxOutputId): boolean;
        /**
         * @returns {ConstrData}
         */
        _toUplcData(): ConstrData;
        #private;
    }
    /**
     * An array of bytes, a Bech32 encoded address, or the hexadecimal representation of the underlying bytes.
     * @typedef {number[] | string} AddressProps
     */
    /**
     * Wrapper for Cardano address bytes. An `Address` consists of three parts internally:
     *   * Header (1 byte, see [CIP 19](https://cips.cardano.org/cips/cip19/))
     *   * Witness hash (28 bytes that represent the `PubKeyHash` or `ValidatorHash`)
     *   * Optional staking credential (0 or 28 bytes)
     */
    export class Address extends HeliosData {
        /**
         * @internal
         * @param {AddressProps} props
         * @returns {number[]}
         */
        static cleanConstructorArg(props: AddressProps): number[];
        /**
         * @param {Address | AddressProps} props
         * @returns {Address}
         */
        static fromProps(props: Address | AddressProps): Address;
        /**
         * Returns a dummy address (based on a PubKeyHash with all null bytes)
         * @returns {Address}
         */
        static dummy(): Address;
        /**
         * Deserializes bytes into an `Address`.
         * @param {number[]} bytes
         * @returns {Address}
         */
        static fromCbor(bytes: number[]): Address;
        /**
         * Converts a Bech32 string into an `Address`.
         * @param {string} str
         * @returns {Address}
         */
        static fromBech32(str: string): Address;
        /**
         * Constructs an `Address` using a hexadecimal string representation of the address bytes.
         * Doesn't check validity.
         * @param {string} hex
         * @returns {Address}
         */
        static fromHex(hex: string): Address;
        /**
        * Constructs an Address using either a `PubKeyHash` (i.e. simple payment address)
        * or `ValidatorHash` (i.e. script address),
        * without a staking hash.
        * @param {PubKeyHash | ValidatorHash} hash
        * @param {boolean} isTestnet Defaults to `config.IS_TESTNET`
        * @returns {Address}
        */
        static fromHash(hash: PubKeyHash | ValidatorHash, isTestnet?: boolean): Address;
        /**
         * Constructs an Address using either a `PubKeyHash` (i.e. simple payment address)
         * or `ValidatorHash` (i.e. script address),
         * in combination with an optional staking hash (`PubKeyHash` or `StakingValidatorHash`).
         * @param {PubKeyHash | ValidatorHash} hash
         * @param {null | (PubKeyHash | StakingValidatorHash)} stakingHash
         * @param {boolean} isTestnet Defaults to `config.IS_TESTNET`
         * @returns {Address}
         */
        static fromHashes(hash: PubKeyHash | ValidatorHash, stakingHash?: null | (PubKeyHash | StakingValidatorHash), isTestnet?: boolean): Address;
        /**
         * Simple payment address with an optional staking hash (`PubKeyHash` or `StakingValidatorHash`).
         * @internal
         * @param {PubKeyHash} hash
         * @param {null | (PubKeyHash | StakingValidatorHash)} stakingHash
         * @param {boolean} isTestnet Defaults to `config.IS_TESTNET`
         * @returns {Address}
         */
        static fromPubKeyHash(hash: PubKeyHash, stakingHash?: null | (PubKeyHash | StakingValidatorHash), isTestnet?: boolean): Address;
        /**
         * Simple script address with an optional staking hash (`PubKeyHash` or `StakingValidatorHash`).
         * @internal
         * @param {ValidatorHash} hash
         * @param {null | (PubKeyHash | StakingValidatorHash)} stakingHash
         * @param {boolean} isTestnet Defaults to `config.IS_TESTNET`
         * @returns {Address}
         */
        static fromValidatorHash(hash: ValidatorHash, stakingHash?: null | (PubKeyHash | StakingValidatorHash), isTestnet?: boolean): Address;
        /**
         * Returns `true` if the given `Address` is a testnet address.
         * @param {Address} address
         * @returns {boolean}
         */
        static isForTestnet(address: Address): boolean;
        /**
         * @param {UplcData} data
         * @param {boolean} isTestnet
         * @returns {Address}
         */
        static fromUplcData(data: UplcData, isTestnet?: boolean): Address;
        /**
         * @internal
         * @param {string | number[]} bytes
         * @param {boolean} isTestnet
         * @returns {Address}
         */
        static fromUplcCbor(bytes: string | number[], isTestnet?: boolean): Address;
        /**
         * Used to sort txbody withdrawals.
         * @internal
         * @param {Address} a
         * @param {Address} b
         * @return {number}
         */
        static compStakingHashes(a: Address, b: Address): number;
        /**
         * @param {number[] | string} bytesOrBech32String
         */
        constructor(bytesOrBech32String: number[] | string);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * Converts a `Address` into its hexadecimal representation.
         * @returns {string}
         */
        toHex(): string;
        /**
         * Converts a `Address` into its hexadecimal representation.
         * @returns {string}
         */
        get hex(): string;
        /**
         * Converts an `Address` into its Bech32 representation.
         * @returns {string}
         */
        toBech32(): string;
        /**
         * @param {Address} other
         * @returns {boolean}
         */
        eq(other: Address): boolean;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @internal
         * @returns {ConstrData}
         */
        toCredentialData(): ConstrData;
        /**
         * @internal
         * @returns {ConstrData}
         */
        toStakingData(): ConstrData;
        /**
         * Returns the underlying `PubKeyHash` of a simple payment address, or `null` for a script address.
         * @type {null | PubKeyHash}
         */
        get pubKeyHash(): PubKeyHash | null;
        /**
         * Returns the underlying `ValidatorHash` of a script address, or `null` for a regular payment address.
         * @type {null | ValidatorHash}
         */
        get validatorHash(): ValidatorHash | null;
        /**
         * Returns the underlying `PubKeyHash` or `StakingValidatorHash`, or `null` for non-staked addresses.
         * @type {null | PubKeyHash | StakingValidatorHash}
         */
        get stakingHash(): PubKeyHash | StakingValidatorHash | null;
        #private;
    }
    /**
     * @typedef {string | [
     *   MintingPolicyHash | MintingPolicyHashProps,
     *   ByteArray | ByteArrayProps
     * ] | {
     *   mph: MintingPolicyHash | MintingPolicyHashProps,
     *   tokenName: ByteArray | ByteArrayProps
     * }} AssetClassProps
     */
    /**
     * Represents a `MintingPolicyHash` combined with a token name.
     */
    export class AssetClass extends HeliosData {
        /**
         * @internal
         * @param {AssetClassProps} props
         * @returns {[MintingPolicyHash | MintingPolicyHashProps, ByteArray | ByteArrayProps]}
         */
        static cleanConstructorArgs(props: AssetClassProps): [MintingPolicyHash | MintingPolicyHashProps, ByteArray | ByteArrayProps];
        /**
         * @param {AssetClass | AssetClassProps} props
         * @returns {AssetClass}
         */
        static fromProps(props: AssetClass | AssetClassProps): AssetClass;
        /**
         *
         * @param {UplcData} data
         * @returns {AssetClass}
         */
        static fromUplcData(data: UplcData): AssetClass;
        /**
         * Deserializes bytes into an `AssetClass`.
         * @param {number[]} bytes
         * @returns {AssetClass}
         */
        static fromCbor(bytes: number[]): AssetClass;
        /**
         * @param {string | number[]} bytes
         * @returns {AssetClass}
         */
        static fromUplcCbor(bytes: string | number[]): AssetClass;
        /**
         * @type {AssetClass}
         */
        static get ADA(): AssetClass;
        /**
         * Intelligently converts arguments.
         *
         * The format for single argument string is "<hex-encoded-mph>.<hex-encoded-token-name>".
         * @param {AssetClassProps} props
         */
        constructor(props: AssetClassProps);
        /**
         * @type {MintingPolicyHash}
         */
        get mintingPolicyHash(): MintingPolicyHash;
        /**
         * @type {ByteArray}
         */
        get tokenName(): ByteArray;
        /**
         * Used when generating script contexts for running programs
         * @returns {ConstrData}
         */
        _toUplcData(): ConstrData;
        /**
         * Cip14 fingerprint
         * This involves a hash, so you can't use a fingerprint to calculate the underlying policy/tokenName.
         * @returns {string}
         */
        toFingerprint(): string;
        #private;
    }
    /**
     * @typedef {[
     *   AssetClass | AssetClassProps,
     *   HInt | HIntProps
     * ][] | [
     *   MintingPolicyHash | MintingPolicyHashProps,
     *   [
     *     ByteArray | ByteArrayProps,
     *     HInt | HIntProps
     *   ][]
     * ][]} AssetsProps
     */
    /**
     * Represents a list of non-Ada tokens.
     */
    export class Assets extends CborData {
        /**
         * @param {Assets | AssetsProps} props
         * @returns {Assets}
         */
        static fromProps(props: Assets | AssetsProps): Assets;
        /**
         * @param {number[]} bytes
         * @returns {Assets}
         */
        static fromCbor(bytes: number[]): Assets;
        /**
         * **Note**: the assets are normalized by removing entries with 0 tokens, and merging all entries with the same MintingPolicyHash and token name.
         * @param {AssetsProps} props Either a list of `AssetClass`/quantity pairs, or a list of `MintingPolicyHash`/`tokens` pairs (where each `tokens` entry is a bytearray/quantity pair).
         */
        constructor(props?: AssetsProps);
        /**
         * @private
         * @type {[MintingPolicyHash, [ByteArray, HInt][]][]}
         */
        private assets;
        /**
         * Returns a list of all the minting policies.
         * @type {MintingPolicyHash[]}
         */
        get mintingPolicies(): MintingPolicyHash[];
        /**
         * @type {number}
         */
        get nTokenTypes(): number;
        /**
         * Returns empty if mph not found
         * @param {MintingPolicyHash} mph
         * @returns {[ByteArray, HInt][]}
         */
        getTokens(mph: MintingPolicyHash): [ByteArray, HInt][];
        /**
         * @returns {boolean}
         */
        isZero(): boolean;
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {ByteArray | ByteArrayProps} tokenName
         * @returns {boolean}
         */
        has(mph: MintingPolicyHash | MintingPolicyHashProps, tokenName: ByteArray | ByteArrayProps): boolean;
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {ByteArray | ByteArrayProps} tokenName
         * @returns {bigint}
         */
        get(mph: MintingPolicyHash | MintingPolicyHashProps, tokenName: ByteArray | ByteArrayProps): bigint;
        /**
         * Mutates 'this'
         */
        removeZeroes(): void;
        /**
         * Removes zeros and merges duplicates.
         * In-place algorithm.
         * Keeps the same order as much as possible.
         */
        normalize(): void;
        /**
         * Mutates 'this'.
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {ByteArray | ByteArrayProps} tokenName
         * @param {HInt | HIntProps} qty
         */
        addComponent(mph: MintingPolicyHash | MintingPolicyHashProps, tokenName: ByteArray | ByteArrayProps, qty: HInt | HIntProps): void;
        /**
         * @internal
         * @param {Assets} other
         * @param {(a: bigint, b: bigint) => bigint} op
         * @returns {Assets}
         */
        applyBinOp(other: Assets, op: (a: bigint, b: bigint) => bigint): Assets;
        /**
         * @param {Assets} other
         * @returns {Assets}
         */
        add(other: Assets): Assets;
        /**
         * @param {Assets} other
         * @returns {Assets}
         */
        sub(other: Assets): Assets;
        /**
         * @param {HInt | HIntProps} scalar
         * @returns {Assets}
         */
        mul(scalar: HInt | HIntProps): Assets;
        /**
         * Mutates 'this'.
         * Throws error if mph is already contained in 'this'.
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {[ByteArray | ByteArrayProps, HInt | HIntProps][]} tokens
         */
        addTokens(mph: MintingPolicyHash | MintingPolicyHashProps, tokens: [ByteArray | ByteArrayProps, HInt | HIntProps][]): void;
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @returns {ByteArray[]}
         */
        getTokenNames(mph: MintingPolicyHash | MintingPolicyHashProps): ByteArray[];
        /**
         * @param {Assets} other
         * @returns {boolean}
         */
        eq(other: Assets): boolean;
        /**
         * Strict gt, if other contains assets this one doesn't contain => return false
         * @param {Assets} other
         * @returns {boolean}
         */
        gt(other: Assets): boolean;
        /**
         * @param {Assets} other
         * @returns {boolean}
         */
        ge(other: Assets): boolean;
        /**
         * @returns {boolean}
         */
        allPositive(): boolean;
        /**
         * Throws an error if any contained quantity <= 0n
         */
        assertAllPositive(): void;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * Used when generating script contexts for running programs
         * @returns {MapData}
         */
        _toUplcData(): MapData;
        /**
         * Makes sure minting policies are in correct order, and for each minting policy make sure the tokens are in the correct order
         * Mutates 'this'
         */
        sort(): void;
        assertSorted(): void;
    }
    /**
     * @typedef {HInt | HIntProps | [
     *   HInt | HIntProps,
     *   Assets | AssetsProps
     * ] | {
     *   lovelace: HInt| HIntProps,
     *   assets?:   Assets | AssetsProps
     * }} ValueProps
     */
    /**
     * Represents a collection of tokens.
     */
    export class Value extends HeliosData {
        /**
         * @param {ValueProps} props
         * @param {null | Assets | AssetsProps} maybeAssets
         * @returns {[HInt | HIntProps, Assets | AssetsProps]}
         */
        static cleanConstructorArgs(props: ValueProps, maybeAssets: null | Assets | AssetsProps): [HInt | HIntProps, Assets | AssetsProps];
        /**
         * @param {ValueProps | Value} props
         * @returns {Value}
         */
        static fromProps(props: ValueProps | Value): Value;
        /**
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {ByteArray | ByteArrayProps} tokenName
         * @param {HInt | HIntProps} qty
         * @returns {Value}
         */
        static asset(mph: MintingPolicyHash | MintingPolicyHashProps, tokenName: ByteArray | ByteArrayProps, qty: HInt | HIntProps): Value;
        /**
         * @param {number[]} bytes
         * @returns {Value}
         */
        static fromCbor(bytes: number[]): Value;
        /**
         * @param {Value[]} values
         * @returns {Value}
         */
        static sum(values: Value[]): Value;
        /**
         * Converts a `UplcData` instance into a `Value`. Throws an error if it isn't in the right format.
         * @param {UplcData} data
         * @returns {Value}
         */
        static fromUplcData(data: UplcData): Value;
        /**
         * @param {string | number[]} bytes
         * @returns {Value}
         */
        static fromUplcCbor(bytes: string | number[]): Value;
        /**
         * @param {ValueProps} props
         * @param {null | Assets | AssetsProps} assets
         */
        constructor(props?: ValueProps, assets?: null | Assets | AssetsProps);
        /**
         * Gets the `Assets` contained in the `Value`.
         * @type {Assets}
         */
        get assets(): Assets;
        /**
         * Gets the lovelace quantity contained in the `Value`.
         * @type {bigint}
         */
        get lovelace(): bigint;
        /**
         * Mutates the quantity of lovelace in a `Value`.
         * @param {HInt | HIntProps} lovelace
         */
        setLovelace(lovelace: HInt | HIntProps): void;
        /**
         * Adds two `Value` instances together. Returns a new `Value` instance.
         * @param {Value} other
         * @returns {Value}
         */
        add(other: Value): Value;
        /**
         * Substracts one `Value` instance from another. Returns a new `Value` instance.
         * @param {Value} other
         * @returns {Value}
         */
        sub(other: Value): Value;
        /**
         * Multiplies a `Value` by a whole number.
         * @param {HInt | HIntProps} scalar
         * @returns {Value}
         */
        mul(scalar: HInt | HIntProps): Value;
        /**
         * Checks if two `Value` instances are equal (`Assets` need to be in the same order).
         * @param {Value} other
         * @returns {boolean}
         */
        eq(other: Value): boolean;
        /**
         * Checks if a `Value` instance is strictly greater than another `Value` instance. Returns false if any asset is missing.
         * @param {Value} other
         * @returns {boolean}
         */
        gt(other: Value): boolean;
        /**
         * Checks if a `Value` instance is strictly greater or equal to another `Value` instance. Returns false if any asset is missing.
         * @param {Value} other
         * @returns {boolean}
         */
        ge(other: Value): boolean;
        /**
         * Throws an error if any of the `Value` entries is negative.
         *
         * Used when building transactions because transactions can't contain negative values.
         * @returns {Value} - returns this
         */
        assertAllPositive(): Value;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * Used when building script context
         * @param {boolean} isInScriptContext
         * @returns {MapData}
         */
        _toUplcData(isInScriptContext?: boolean): MapData;
        #private;
    }
    /**
     * @typedef {Object} Cost
     * @property {bigint} mem
     * @property {bigint} cpu
     */
    /**
     * @typedef {() => bigint} LiveSlotGetter
     */
    /**
     * Wrapper for the raw JSON containing all the current network parameters.
     *
     * NetworkParams is needed to be able to calculate script budgets and perform transaction building checks.
     *
     * The raw JSON can be downloaded from the following CDN locations:
     *
     *  - Preview: [https://d1t0d7c2nekuk0.cloudfront.net/preview.json](https://d1t0d7c2nekuk0.cloudfront.net/preview.json)
     *  - Preprod: [https://d1t0d7c2nekuk0.cloudfront.net/preprod.json](https://d1t0d7c2nekuk0.cloudfront.net/preprod.json)
     *  - Mainnet: [https://d1t0d7c2nekuk0.cloudfront.net/mainnet.json](https://d1t0d7c2nekuk0.cloudfront.net/mainnet.json)
     *
     * These JSONs are updated every 15 minutes.
     */
    export class NetworkParams {
        /**
         * @param {Object} raw
         * @param {null | LiveSlotGetter} liveSlotGetter
         */
        constructor(raw: any, liveSlotGetter?: null | LiveSlotGetter);
        /**
         * @type {Object}
         */
        get raw(): any;
        /**
         * @type {null | bigint}
         */
        get liveSlot(): bigint | null;
        /**
         * @internal
         * @type {Object}
         */
        get costModel(): any;
        /**
         * @internal
         * @param {string} key
         * @returns {number}
         */
        getCostModelParameter(key: string): number;
        /**
         * @internal
         * @param {string} name
         * @returns {Cost}
         */
        getTermCost(name: string): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreStartupCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreVariableCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreLambdaCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreDelayCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreCallCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreConstCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreForceCost(): Cost;
        /**
         * @internal
         * @type {Cost}
         */
        get plutusCoreBuiltinCost(): Cost;
        /**
         * @internal
         * @type {[number, number]} - a + b*size
         */
        get txFeeParams(): [number, number];
        /**
         * @internal
         * @type {[number, number]} - [memFee, cpuFee]
         */
        get exFeeParams(): [number, number];
        /**
         * @internal
         * @type {number[]}
         */
        get sortedCostParams(): number[];
        /**
         * @internal
         * @type {number}
         */
        get lovelacePerUTXOByte(): number;
        /**
         * @internal
         * @type {number}
         */
        get minCollateralPct(): number;
        /**
         * @internal
         * @type {number}
         */
        get maxCollateralInputs(): number;
        /**
         * @internal
         * @type {[number, number]} - [mem, cpu]
         */
        get maxTxExecutionBudget(): [number, number];
        /**
         * @internal
         * @type {number}
         */
        get maxTxSize(): number;
        /**
         * @internal
         * @type {bigint}
         */
        get maxTxFee(): bigint;
        /**
         * Calculates the time (in milliseconds in 01/01/1970) associated with a given slot number.
         * @param {bigint} slot
         * @returns {bigint}
         */
        slotToTime(slot: bigint): bigint;
        /**
         * Calculates the slot number associated with a given time. Time is specified as milliseconds since 01/01/1970.
         * @param {bigint} time Milliseconds since 1970
         * @returns {bigint}
         */
        timeToSlot(time: bigint): bigint;
        #private;
    }
    /**
     * Each builtin has an associated CostModel.
     * The CostModel calculates the execution cost of a builtin, depending on the byte-size of the inputs.
     * @internal
     */
    export class CostModel {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName
         * @returns {CostModel}
         */
        static fromParams(params: NetworkParams, baseName: string): CostModel;
        /**
         * @param {number[]} args
         * @returns {bigint}
         */
        calc(args: number[]): bigint;
        /**
         * @returns {string}
         */
        dump(): string;
    }
    /**
     * A simple constant cost, independent of arg size.
     * @internal
     */
    export class ConstCost extends CostModel {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {ConstCost}
         */
        static fromParams(params: NetworkParams, baseName: string): ConstCost;
        /**
         * @param {bigint} constant
         */
        constructor(constant: bigint);
        #private;
    }
    /**
     * cost = a + b*size(arg)
     * @internal
     */
    export class LinearCost extends CostModel {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {[bigint, bigint]}
         */
        static getParams(params: NetworkParams, baseName: string): [bigint, bigint];
        /**
         * a + b*SizeFn(x, y)
         * @param {bigint} a - intercept
         * @param {bigint} b - slope
         */
        constructor(a: bigint, b: bigint);
        /**
         * @param  {number} size
         * @returns {bigint}
         */
        calcInternal(size: number): bigint;
        #private;
    }
    /**
     * cost = a + b*size(args[i])
     * @internal
     */
    export class ArgSizeCost extends LinearCost {
        /**
         * @param {bigint} a - intercept
         * @param {bigint} b - slope
         * @param {number} i - index of the arg
         */
        constructor(a: bigint, b: bigint, i: number);
        #private;
    }
    /**
     * cost = a + b*size(arg0)
     * @internal
     */
    export class Arg0SizeCost extends ArgSizeCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {Arg0SizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): Arg0SizeCost;
        /**
         * @param {bigint} a
         * @param {bigint} b
         */
        constructor(a: bigint, b: bigint);
    }
    /**
     * cost = a + b*size(arg1)
     * @internal
     */
    export class Arg1SizeCost extends ArgSizeCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {Arg1SizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): Arg1SizeCost;
        /**
         * @param {bigint} a
         * @param {bigint} b
         */
        constructor(a: bigint, b: bigint);
    }
    /**
     * cost = a + b*size(arg2)
     * @internal
     */
    export class Arg2SizeCost extends ArgSizeCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {Arg2SizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): Arg2SizeCost;
        /**
         * @param {bigint} a
         * @param {bigint} b
         */
        constructor(a: bigint, b: bigint);
    }
    /**
     * cost = a + b*min(args)
     * @internal
     */
    export class MinArgSizeCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {MaxArgSizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): MaxArgSizeCost;
    }
    /**
     * cost = a + b*max(args)
     * @internal
     */
    export class MaxArgSizeCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {MaxArgSizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): MaxArgSizeCost;
    }
    /**
     * cost = a + b*sum(sizes(args))
     * @internal
     */
    export class SumArgSizesCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {MaxArgSizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): MaxArgSizeCost;
    }
    /**
     * cost = a + b*max(size(arg0)-size(arg1), min)
     * (only for Uplc functions with two arguments)
     * @internal
     */
    export class ArgSizeDiffCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {ArgSizeDiffCost}
         */
        static fromParams(params: NetworkParams, baseName: string): ArgSizeDiffCost;
        /**
         * @param {bigint} a - intercept
         * @param {bigint} b - slope
         * @param {number} min
         */
        constructor(a: bigint, b: bigint, min: number);
        #private;
    }
    /**
     * cost = (size(arg0) > size(arg1)) ? constant : a + b*size(arg0)*size(arg1)
     * (only for Uplc functions with two arguments)
     * @internal
     */
    export class ArgSizeProdCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {MaxArgSizeCost}
         */
        static fromParams(params: NetworkParams, baseName: string): MaxArgSizeCost;
        /**
         * @param {bigint} a - intercept
         * @param {bigint} b - slope
         * @param {bigint} constant
         */
        constructor(a: bigint, b: bigint, constant: bigint);
        #private;
    }
    /**
     * cost = (size(arg0) != size(arg1)) ? constant : a + b*size(arg0)
     * (only for Uplc functions with two arguments)
     * @internal
     */
    export class ArgSizeDiagCost extends LinearCost {
        /**
         * @param {NetworkParams} params
         * @param {string} baseName - eg. addInteger-cpu-arguments
         * @returns {ArgSizeDiagCost}
         */
        static fromParams(params: NetworkParams, baseName: string): ArgSizeDiagCost;
        /**
         * @param {bigint} a
         * @param {bigint} b
         * @param {bigint} constant
         */
        constructor(a: bigint, b: bigint, constant: bigint);
        #private;
    }
    /**
     * @internal
     * @typedef CostModelClass
     * @property {(params: NetworkParams, baseName: string) => CostModel} fromParams
     */
    /**
     * Cost-model configuration of UplcBuiltin.
     * Also specifies the number of times a builtin must be 'forced' before being callable.
     * @internal
     */
    export class UplcBuiltinConfig {
        /**
         * @param {string} name
         * @param {number} forceCount - number of type parameters of a Plutus-core builtin function (0, 1 or 2)
         * @param {number} nArgs
         * @param {boolean} allowAny
         * @param {CostModelClass} memCostModelClass
         * @param {CostModelClass} cpuCostModelClass
         */
        constructor(name: string, forceCount: number, nArgs: number, allowAny: boolean, memCostModelClass: CostModelClass, cpuCostModelClass: CostModelClass);
        get name(): string;
        get forceCount(): number;
        get nArgs(): number;
        get allowAny(): boolean;
        /**
         * @param {NetworkParams} params
         * @returns {[CostModel, CostModel]}
         */
        instantiateCostModels(params: NetworkParams): [CostModel, CostModel];
        /**
         * @param {NetworkParams} params
         * @param {number[]} argSizes
         * @returns {Cost}
         */
        calcCost(params: NetworkParams, argSizes: number[]): Cost;
        /**
         * @param {NetworkParams} params
         */
        dumpCostModel(params: NetworkParams): void;
        #private;
    }
    /**
     * A list of all PlutusScript builins, with associated costmodels (actual costmodel parameters are loaded from NetworkParams during runtime)
     * @internal
     * @type {UplcBuiltinConfig[]}
     */
    export const UPLC_BUILTINS: UplcBuiltinConfig[];
    /**
     * @internal
     */
    export const UPLC_MACROS_OFFSET: number;
    /**
     * Index to helios-specific macro mapping
     * @internal
     */
    export const UPLC_MACROS: string[];
    /**
     * A Helios/Uplc Program can have different purposes
     * @typedef {"testing" | "minting" | "spending" | "staking" | "endpoint" | "module" | "unknown"} ScriptPurpose
     */
    /**
     * a UplcValue is passed around by Plutus-core expressions.
     */
    export class UplcValue {
        /**
         * @param {Site} site
         */
        constructor(site: Site);
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * Return a copy of the UplcValue at a different Site.
         * @internal
         * @param {Site} newSite
         * @returns {UplcValue}
         */
        copy(newSite: Site): UplcValue;
        /**
         * @internal
         * @type {Site}
         */
        get site(): Site;
        /**
         * @internal
         * @type {number}
         */
        get length(): number;
        /**
         * Size in words (8 bytes, 64 bits) occupied in target node
         * @internal
         * @type {number}
         */
        get memSize(): number;
        /**
         * @returns {boolean}
         */
        isAny(): boolean;
        /**
         * @type {bigint}
         */
        get int(): bigint;
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {string}
         */
        get string(): string;
        /**
         * @type {boolean}
         */
        get bool(): boolean;
        /**
         * Distinguishes a pair from a mapItem
         * @returns {boolean}
         */
        isPair(): boolean;
        /**
         * @type {UplcValue}
         */
        get first(): UplcValue;
        /**
         * @type {UplcValue}
         */
        get second(): UplcValue;
        /**
         * Distinguishes a list from a map
         * @returns {boolean}
         */
        isList(): boolean;
        /**
         * @type {UplcType}
         */
        get itemType(): UplcType;
        /**
         * @type {UplcValue[]}
         */
        get list(): UplcValue[];
        /**
         * @returns {boolean}
         */
        isData(): boolean;
        /**
         * @type {UplcData}
         */
        get data(): UplcData;
        /**
         * @internal
         * @returns {Promise<UplcValue>}
         */
        force(): Promise<UplcValue>;
        /**
         * @internal
         * @returns {UplcUnit}
         */
        assertUnit(): UplcUnit;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @internal
         * @returns {string}
         */
        typeBits(): string;
        /**
         * Encodes value without type header
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlatValueInternal(bitWriter: BitWriter): void;
        /**
         * Encodes value with plutus flat encoding.
         * Member function not named 'toFlat' as not to confuse with 'toFlat' member of terms.
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlatValue(bitWriter: BitWriter): void;
        #private;
    }
    /**
     * Represents the typeBits of a UPLC primitive.
     */
    export class UplcType {
        /**
         * @returns {UplcType}
         */
        static newDataType(): UplcType;
        /**
         * @returns {UplcType}
         */
        static newDataPairType(): UplcType;
        /**
         * @param {number[]} lst
         * @returns {UplcType}
         */
        static fromNumbers(lst: number[]): UplcType;
        /**
         * @param {string} typeBits
         */
        constructor(typeBits: string);
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * @returns {string}
         */
        typeBits(): string;
        /**
         * @param {UplcValue} value
         * @returns {boolean}
         */
        isSameType(value: UplcValue): boolean;
        /**
         * @returns {boolean}
         */
        isData(): boolean;
        /**
         * @returns {boolean}
         */
        isDataPair(): boolean;
        #private;
    }
    /**
     * @typedef {[null | string, UplcValue][]} UplcRawStack
     */
    /**
     * @typedef {{
     *	 onPrint: (msg: string) => Promise<void>
     *   onStartCall: (site: Site, rawStack: UplcRawStack) => Promise<boolean>
     *   onEndCall: (site: Site, rawStack: UplcRawStack) => Promise<void>
     *   onIncrCost: (name: string, isTerm: boolean, cost: Cost) => void
     * }} UplcRTECallbacks
     */
    /**
     * @internal
     * @typedef {UplcRTECallbacks & {
     *   macros?: {[name: string]: (rte: UplcRte, args: UplcValue[]) => Promise<UplcValue>}
     * }} UplcRTECallbacksInternal
     */
    /**
     * Configures the Uplc evaluator to print messages to `console`.
     * @type {UplcRTECallbacks}
     */
    export const DEFAULT_UPLC_RTE_CALLBACKS: UplcRTECallbacks;
    /**
     * Plutus-core Runtime Environment is used for controlling the programming evaluation (eg. by a debugger)
     * @internal
     */
    export class UplcRte {
        /**
         * @param {UplcRTECallbacksInternal} callbacks
         * @param {null | NetworkParams} networkParams
         */
        constructor(callbacks?: UplcRTECallbacksInternal, networkParams?: null | NetworkParams);
        /**
         * @type {string[]}
         */
        get messages(): string[];
        /**
         * @returns {string}
         */
        popLastMessage(): string;
        /**
         * @returns {boolean}
         */
        hasError(): boolean;
        /**
         * @returns {string | RuntimeError}
         */
        getError(): string | RuntimeError;
        /**
         * @param {string | RuntimeError} err
         * @returns {UplcValue}
         */
        error(err: string | RuntimeError): UplcValue;
        throwError(): void;
        /**
         * @param {string} name - for breakdown
         * @param {boolean} isTerm
         * @param {Cost} cost
         */
        incrCost(name: string, isTerm: boolean, cost: Cost): void;
        incrStartupCost(): void;
        incrVariableCost(): void;
        incrLambdaCost(): void;
        incrDelayCost(): void;
        incrCallCost(): void;
        incrConstCost(): void;
        incrForceCost(): void;
        incrBuiltinCost(): void;
        /**
         * @param {UplcBuiltin} fn
         * @param {UplcValue[]} args
         */
        calcAndIncrCost(fn: UplcBuiltin, ...args: UplcValue[]): void;
        /**
         * @param {string} name
         * @param {UplcValue[]} args
         * @returns {Promise<UplcValue>}
         */
        callMacro(name: string, args: UplcValue[]): Promise<UplcValue>;
        /**
         * Gets variable using Debruijn index. Throws error here because UplcRTE is the stack root and doesn't contain any values.
         * @param {number} i
         * @returns {UplcValue}
         */
        get(i: number): UplcValue;
        /**
         * Creates a child stack.
         * @param {UplcValue} value
         * @param {?string} valueName
         * @returns {UplcStack}
         */
        push(value: UplcValue, valueName?: string | null): UplcStack;
        /**
         * Calls the print callback (or does nothing if print callback isn't defined)
         * @param {string | string[]} rawMsg
         * @returns {Promise<void>}
         */
        print(rawMsg: string | string[]): Promise<void>;
        /**
         * Calls the onStartCall callback.
         * @param {Site} site
         * @param {UplcRawStack} rawStack
         * @returns {Promise<void>}
         */
        startCall(site: Site, rawStack: UplcRawStack): Promise<void>;
        /**
         * Calls the onEndCall callback if '#notifyCalls == true'.
         * '#notifyCalls' is set to true if 'rawStack == #marker'.
         * @param {Site} site
         * @param {UplcRawStack} rawStack
         * @param {UplcValue} result
         * @returns {Promise<void>}
         */
        endCall(site: Site, rawStack: UplcRawStack, result: UplcValue): Promise<void>;
        /**
         * @returns {UplcRawStack}
         */
        toList(): UplcRawStack;
        #private;
    }
    /**
     * Allows doing a dummy eval of a UplcProgram in order to determine some non-changing properties (eg. the address fetched via the network in an EndpointProgram)
     * @internal
     */
    export class UplcAny extends UplcValue {
    }
    /**
     * @internal
     */
    export class UplcDelayedValue extends UplcValue {
        /**
         * @param {Site} site
         * @param {() => (UplcValue | Promise<UplcValue>)} evaluator
         */
        constructor(site: Site, evaluator: () => (UplcValue | Promise<UplcValue>));
        #private;
    }
    /**
     * Primitive equivalent of `IntData`.
     */
    export class UplcInt extends UplcValue {
        /**
         * Constructs a UplcInt without requiring a Site
         * @param {bigint | number} value
         * @returns {UplcInt}
         */
        static new(value: bigint | number): UplcInt;
        /**
         * Creates a UplcInt wrapped in a UplcConst, so it can be used a term
         * @param {Site} site
         * @param {bigint} value
         * @returns
         */
        static newSignedTerm(site: Site, value: bigint): UplcConst;
        /**
         * Parses a single byte in the Plutus-core byte-list representation of an int
         * @param {number} b
         * @returns {number}
         */
        static parseRawByte(b: number): number;
        /**
         * Returns true if 'b' is the last byte in the Plutus-core byte-list representation of an int.
         * @param {number} b
         * @returns {boolean}
         */
        static rawByteIsLast(b: number): boolean;
        /**
         * Combines a list of Plutus-core bytes into a bigint (leading bit of each byte is ignored).
         * Differs from bytesToBigInt in utils.js because only 7 bits are used from each byte.
         * @param {number[]} bytes
         * @returns {bigint}
         */
        static bytesToBigInt(bytes: number[]): bigint;
        /**
         * @param {Site} site
         * @param {bigint} value - supposed to be arbitrary precision
         * @param {boolean} signed - unsigned is only for internal use
         */
        constructor(site: Site, value: bigint, signed?: boolean);
        /**
         * @readonly
         * @type {bigint}
         */
        readonly value: bigint;
        /**
         * @readonly
         * @type {boolean}
         */
        readonly signed: boolean;
        /**
         * @param {Site} newSite
         * @returns {UplcInt}
         */
        copy(newSite: Site): UplcInt;
        /**
         * Applies zigzag encoding
         * @example
         * (new UplcInt(Site.dummy(), -1n, true)).toUnsigned().int == 1n
         * @example
         * (new UplcInt(Site.dummy(), -1n, true)).toUnsigned().toSigned().int == -1n
         * @example
         * (new UplcInt(Site.dummy(), -2n, true)).toUnsigned().toSigned().int == -2n
         * @example
         * (new UplcInt(Site.dummy(), -3n, true)).toUnsigned().toSigned().int == -3n
         * @example
         * (new UplcInt(Site.dummy(), -4n, true)).toUnsigned().toSigned().int == -4n
         * @returns {UplcInt}
         */
        toUnsigned(): UplcInt;
        /**
         * Unapplies zigzag encoding
         * @example
         * (new UplcInt(Site.dummy(), 1n, false)).toSigned().int == -1n
         * @returns {UplcInt}
        */
        toSigned(): UplcInt;
        /**
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlatInternal(bitWriter: BitWriter): void;
        /**
         * Encodes unsigned integer with plutus flat encoding.
         * Throws error if signed.
         * Used by encoding plutus core program version and debruijn indices.
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlatUnsigned(bitWriter: BitWriter): void;
    }
    /**
     * Primitive equivalent of `ByteArrayData`.
     */
    export class UplcByteArray extends UplcValue {
        /**
         * Construct a UplcByteArray without requiring a Site
         * @internal
         * @param {number[]} bytes
         * @returns {UplcByteArray}
         */
        static new(bytes: number[]): UplcByteArray;
        /**
         * Creates new UplcByteArray wrapped in UplcConst so it can be used as a term.
         * @internal
         * @param {Site} site
         * @param {number[]} bytes
         * @returns {UplcConst}
         */
        static newTerm(site: Site, bytes: number[]): UplcConst;
        /**
         * Write a list of bytes to the bitWriter using flat encoding.
         * Used by UplcString, UplcByteArray and UplcDataValue
         * Equivalent to E_B* function in Plutus-core docs
         * @internal
         * @param {BitWriter} bitWriter
         * @param {number[]} bytes
         * @param {boolean} pad
         */
        static writeBytes(bitWriter: BitWriter, bytes: number[], pad?: boolean): void;
        /**
         * @param {Site} site
         * @param {number[]} bytes
         */
        constructor(site: Site, bytes: number[]);
        /**
         * @internal
         * @param {Site} newSite
         * @returns {UplcByteArray}
         */
        copy(newSite: Site): UplcByteArray;
        #private;
    }
    /**
     * Primitive string value.
     */
    export class UplcString extends UplcValue {
        /**
         * Constructs a UplcStrin without requiring a Site
         * @param {string} value
         * @returns {UplcString}
         */
        static new(value: string): UplcString;
        /**
         * Creates a new UplcString wrapped with UplcConst so it can be used as a term.
         * @param {Site} site
         * @param {string} value
         * @returns {UplcConst}
         */
        static newTerm(site: Site, value: string): UplcConst;
        /**
         * @param {Site} site
         * @param {string} value
         */
        constructor(site: Site, value: string);
        /**
         * @param {Site} newSite
         * @returns {UplcString}
         */
        copy(newSite: Site): UplcString;
        #private;
    }
    /**
     * Primitive unit value.
     */
    export class UplcUnit extends UplcValue {
        /**
         * Constructs a UplcUnit without requiring a Site
         * @returns {UplcUnit}
         */
        static new(): UplcUnit;
        /**
         * Creates a new UplcUnit wrapped with UplcConst so it can be used as a term
         * @param {Site} site
         * @returns {UplcConst}
         */
        static newTerm(site: Site): UplcConst;
    }
    /**
     * JS/TS equivalent of the Helios language `Bool` type.
     */
    export class UplcBool extends UplcValue {
        /**
         * Constructs a UplcBool without requiring a Site
         * @param {boolean} value
         * @returns {UplcBool}
         */
        static new(value: boolean): UplcBool;
        /**
         * Creates a new UplcBool wrapped with UplcConst so it can be used as a term.
         * @param {Site} site
         * @param {boolean} value
         * @returns {UplcConst}
         */
        static newTerm(site: Site, value: boolean): UplcConst;
        /**
         * @param {Site} site
         * @param {boolean} value
         */
        constructor(site: Site, value: boolean);
        /**
         * @param {Site} newSite
         * @returns {UplcBool}
         */
        copy(newSite: Site): UplcBool;
        #private;
    }
    /**
     * Primitive pair value.
     */
    export class UplcPair extends UplcValue {
        /**
         * Constructs a UplcPair without requiring a Site
         * @param {UplcValue} first
         * @param {UplcValue} second
         * @returns {UplcPair}
         */
        static new(first: UplcValue, second: UplcValue): UplcPair;
        /**
         * Creates a new UplcBool wrapped with UplcConst so it can be used as a term.
         * @param {Site} site
         * @param {UplcValue} first
         * @param {UplcValue} second
         * @returns {UplcConst}
         */
        static newTerm(site: Site, first: UplcValue, second: UplcValue): UplcConst;
        /**
         * @param {Site} site
         * @param {UplcValue} first
         * @param {UplcValue} second
         */
        constructor(site: Site, first: UplcValue, second: UplcValue);
        /**
         * @param {Site} newSite
         * @returns {UplcPair}
         */
        copy(newSite: Site): UplcPair;
        /**
         * @type {UplcData}
         */
        get key(): UplcData;
        /**
         * @type {UplcData}
         */
        get value(): UplcData;
        #private;
    }
    /**
     * Plutus-core list value class.
     * Only used during evaluation.
    */
    export class UplcList extends UplcValue {
        /**
         * Constructs a UplcList without requiring a Site
         * @param {UplcType} type
         * @param {UplcValue[]} items
         */
        static new(type: UplcType, items: UplcValue[]): UplcList;
        /**
         * @param {Site} site
         * @param {UplcType} itemType
         * @param {UplcValue[]} items
         */
        constructor(site: Site, itemType: UplcType, items: UplcValue[]);
        /**
         * @param {Site} newSite
         * @returns {UplcList}
         */
        copy(newSite: Site): UplcList;
        /**
         * @returns {boolean}
         */
        isDataList(): boolean;
        /**
         * @returns {boolean}
         */
        isDataMap(): boolean;
        #private;
    }
    /**
     *  Child type of `UplcValue` that wraps a `UplcData` instance.
     */
    export class UplcDataValue extends UplcValue {
        /**
         * @param {UplcDataValue | UplcData} data
         * @returns {UplcData}
         */
        static unwrap(data: UplcDataValue | UplcData): UplcData;
        /**
         * @param {Site} site
         * @param {UplcData} data
         */
        constructor(site: Site, data: UplcData);
        /**
         * @param {Site} newSite
         * @returns {UplcDataValue}
         */
        copy(newSite: Site): UplcDataValue;
        #private;
    }
    /**
     * Base class of Plutus-core terms
     */
    export class UplcTerm {
        /**
         * @param {Site} site
         * @param {number} type
         */
        constructor(site: Site, type: number);
        /**
         * @type {number}
         */
        get type(): number;
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @param {TransferUplcAst} other
         * @returns {any}
         */
        transfer(other: TransferUplcAst): any;
        /**
         * Generic term toString method
         * @returns {string}
         */
        toString(): string;
        /**
         * Writes bits of flat encoded Plutus-core terms to bitWriter. Doesn't return anything.
         * @internal
         * @param {BitWriter} bitWriter
         * @param {null | Map<string, number>} codeMapFileIndices
         */
        toFlat(bitWriter: BitWriter, codeMapFileIndices?: null | Map<string, number>): void;
        #private;
    }
    /**
     * Plutus-core variable ref term (index is a Debruijn index)
     */
    export class UplcVariable extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcInt} index
         */
        constructor(site: Site, index: UplcInt);
        /**
         * @readonly
         * @type {UplcInt}
         */
        readonly index: UplcInt;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
    }
    /**
     * Plutus-core delay term.
     */
    export class UplcDelay extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcTerm} expr
         */
        constructor(site: Site, expr: UplcTerm);
        /**
         * @readonly
         * @type {UplcTerm}
         */
        readonly expr: UplcTerm;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
    }
    /**
     * Plutus-core lambda term
     */
    export class UplcLambda extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcTerm} expr
         * @param {null | string} argName
         */
        constructor(site: Site, expr: UplcTerm, argName?: null | string);
        /**
         * @readonly
         * @type {UplcTerm}
         */
        readonly expr: UplcTerm;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
        #private;
    }
    /**
     * Plutus-core function application term (i.e. function call)
     */
    export class UplcCall extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcTerm} fn
         * @param {UplcTerm} arg
         */
        constructor(site: Site, fn: UplcTerm, arg: UplcTerm);
        /**
         * @readonly
         * @type {UplcTerm}
         */
        readonly fn: UplcTerm;
        /**
         * @readonly
         * @type {UplcTerm}
         */
        readonly arg: UplcTerm;
        /**
         * @internal
         * @type {Site}
         */
        get callSite(): Site;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
    }
    /**
     * Plutus-core const term (i.e. a literal in conventional sense)
     */
    export class UplcConst extends UplcTerm {
        /**
         * @param {UplcValue} value
         */
        constructor(value: UplcValue);
        /**
         * @readonly
         * @type {UplcValue}
         */
        readonly value: UplcValue;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {PreCallFrame} frame
         * @returns {CekState}
         */
        reducePreCallFrame(rte: UplcRte, stack: UplcFrame[], frame: PreCallFrame): CekState;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ForceFrame} frame
         * @returns {CekState}
         */
        reduceForceFrame(rte: UplcRte, stack: UplcFrame[], frame: ForceFrame): CekState;
    }
    /**
     * Plutus-core force term
     */
    export class UplcForce extends UplcTerm {
        /**
         * @param {Site} site
         * @param {UplcTerm} expr
         */
        constructor(site: Site, expr: UplcTerm);
        /**
         * @readonly
         */
        readonly expr: UplcTerm;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
    }
    /**
     * Plutus-core error term
     */
    export class UplcError extends UplcTerm {
        /**
         * @param {Site} site
         * @param {string} msg
         */
        constructor(site: Site, msg?: string);
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
        #private;
    }
    /**
     * Plutus-core builtin function ref term
     */
    export class UplcBuiltin extends UplcTerm {
        /**
         * Used by IRCoreCallExpr
         * @internal
         * @param {Word} name
         * @param {UplcValue[]} args
         * @returns {UplcValue}
         */
        static evalStatic(name: Word, args: UplcValue[]): UplcValue;
        /**
         * @param {Site} site
         * @param {string | number} name
         */
        constructor(site: Site, name: string | number);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {number}
         */
        get nArgs(): number;
        /**
         * @internal
         * @returns {boolean}
         */
        allowAny(): boolean;
        /**
         * @internal
         * @returns {boolean}
         */
        isMacro(): boolean;
        /**
         * @internal
         * @param {NetworkParams} params
         * @param  {...UplcValue} args
         * @returns {Cost}
         */
        calcCost(params: NetworkParams, ...args: UplcValue[]): Cost;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ComputingState} state
         * @returns {CekState}
         */
        computeCek(rte: UplcRte, stack: UplcFrame[], state: ComputingState): CekState;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {Site} site
         * @param {UplcValue[]} args
         * @returns {Promise<UplcValue>}
         */
        evalMacro(rte: UplcRte, site: Site, args: UplcValue[]): Promise<UplcValue>;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {Site} site
         * @param {UplcValue[]} args
         * @returns {UplcValue | Promise<UplcValue>} // trace returns a Promise (async print), all the other builtins return a synchronous value
         */
        evalBuiltin(rte: UplcRte, site: Site, args: UplcValue[]): UplcValue | Promise<UplcValue>;
        /**
         * @internal
         * @type {number}
         */
        get forceCount(): number;
        #private;
    }
    /**
     * @internal
     */
    export class UplcFrame {
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ReducingState} state
         * @returns {Promise<CekState>}
         */
        reduceCek(rte: UplcRte, stack: UplcFrame[], state: ReducingState): Promise<CekState>;
        /**
         * @type {Site}
         */
        get site(): Site;
    }
    /**
     * @internal
     */
    export class ForceFrame extends UplcFrame {
        /**
         * @param {UplcForce} term
         * @param {CekEnv} env
         */
        constructor(term: UplcForce, env: CekEnv);
        /**
         * @readonly
         * @type {UplcForce}
         */
        readonly term: UplcForce;
        /**
         * @readonly
         * @type {CekEnv}
         */
        readonly env: CekEnv;
    }
    /**
     * @internal
     */
    export class PreCallFrame extends UplcFrame {
        /**
         * @param {UplcCall} term
         * @param {CekEnv} env
         */
        constructor(term: UplcCall, env: CekEnv);
        /**
         * @readonly
         * @type {UplcCall}
         */
        readonly term: UplcCall;
        /**
         * @readonly
         * @type {CekEnv}
         */
        readonly env: CekEnv;
    }
    /**
     * @internal
     */
    export class CallFrame extends UplcFrame {
        /**
         * @param {UplcCall} term
         * @param {UplcLambdaWithEnv | AppliedUplcBuiltin} fn
         * @param {CekEnv} env
         */
        constructor(term: UplcCall, fn: UplcLambdaWithEnv | AppliedUplcBuiltin, env: CekEnv);
        /**
         * @readonly
         * @type {UplcCall}
         */
        readonly term: UplcCall;
        /**
         * @readonly
         * @type {UplcLambdaWithEnv | AppliedUplcBuiltin}
         */
        readonly fn: UplcLambdaWithEnv | AppliedUplcBuiltin;
        /**
         * @readonly
         * @type {CekEnv}
         */
        readonly env: CekEnv;
    }
    /**
     * TODO: purpose as enum type
     * @typedef {{
     *   purpose: null | ScriptPurpose
     *   callsTxTimeRange: boolean
     *   name?: string
     * }} ProgramProperties
     */
    /**
     * The constructor returns 'any' because it is an instance of TransferableUplcProgram, and the instance methods don't need to be defined here
     * @template TInstance
     * @typedef {{
     *   transferUplcProgram: (expr: any, properties: ProgramProperties, version: any[]) => TInstance,
     *   transferUplcAst: TransferUplcAst
     * }} TransferableUplcProgram
     */
    /**
     * @typedef {{
    *   mem: bigint,
    *   cpu: bigint,
    *   size?: number,
    *   builtins?: {[name: string]: Cost},
    *   terms?: {[name: string]: Cost},
    *   result?: RuntimeError | UplcValue,
    *   messages?: string[]
    * }} Profile
    *
    *
    * mem:  in 8 byte words (i.e. 1 mem unit is 64 bits)
    * cpu:  in reference cpu microseconds
    * size: in bytes
    * builtins: breakdown per builtin
    * terms: breakdown per termtype
    * result: result of evaluation
    * messages: printed messages (can be helpful when debugging)
    */
    /**
     * Result of `program.compile()`. Contains the Untyped Plutus-Core AST, along with a code-mapping to the original source.
     */
    export class UplcProgram {
        /**
         * @internal
         * @param {number[] | string} bytes
         * @param {ProgramProperties} properties
         * @param {Source[]} files
         * @returns {UplcProgram}
         */
        static fromCborWithMapping(bytes: number[] | string, files: Source[], properties?: ProgramProperties): UplcProgram;
        /**
         * @param {number[] | string} bytes
         * @param {ProgramProperties} properties
         * @returns {UplcProgram}
         */
        static fromCbor(bytes: number[] | string, properties?: ProgramProperties): UplcProgram;
        /**
         * @param {number[]} bytes
         * @param {ProgramProperties} properties
         * @returns {UplcProgram}
         */
        static fromFlat(bytes: number[], properties?: ProgramProperties): UplcProgram;
        /**
         * @internal
         * @param {number[]} bytes
         * @param {ProgramProperties} properties
         * @param {Source[]} files
         * @returns {UplcProgram}
         */
        static fromFlatWithMapping(bytes: number[], files: Source[], properties?: ProgramProperties): UplcProgram;
        /**
         * Intended for transfer only
         * @param {any} expr
         * @param {ProgramProperties} properties
         * @param {any[]} version
         * @returns {UplcProgram}
         */
        static transferUplcProgram(expr: any, properties: ProgramProperties, version: any[]): UplcProgram;
        /**
         * @type {TransferUplcAst}
         */
        static get transferUplcAst(): TransferUplcAst;
        /**
         * @param {UplcTerm} expr
         * @param {ProgramProperties} properties
         * @param {UplcInt[]} version
         */
        constructor(expr: UplcTerm, properties?: ProgramProperties, version?: UplcInt[]);
        /**
         * @type {UplcTerm}
         */
        get expr(): UplcTerm;
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * Returns the IR source
         * @type {string}
         */
        get src(): string;
        /**
         * @type {ProgramProperties}
         */
        get properties(): ProgramProperties;
        /**
         * Transfers a `UplcProgram` from an old version of Helios to a new version of Helios, keeping the script hash the same.
         *
         * The main benefit for calling this method instead of serializing/deserializing is that the code mapping is maintained.
         * @template TInstance
         * @param {TransferableUplcProgram<TInstance>} other
         * @returns {TInstance}
         */
        transfer<TInstance>(other: TransferableUplcProgram<TInstance>): TInstance;
        /**
         * Returns version of Plutus-core (!== Plutus script version!)
         * @type {string}
         */
        get versionString(): string;
        /**
         * @returns {string}
         */
        plutusScriptVersion(): string;
        /**
         * Returns 1 for PlutusScriptV1, 2 for PlutusScriptV2
         * @returns {number}
         */
        versionTag(): number;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * Flat encodes the entire Plutus-core program.
         * Note that final padding isn't added now but is handled by bitWriter upon finalization.
         * @internal
         * @param {BitWriter} bitWriter
         */
        toFlat(bitWriter: BitWriter): void;
        /**
         * @internal
         * @param {BitWriter} bitWriter
         * @param {null | Map<string, number>} codeMapFileIndices
         */
        toFlatWithMapping(bitWriter: BitWriter, codeMapFileIndices: null | Map<string, number>): void;
        /**
         * Evaluates the term contained in UplcProgram (assuming it is a lambda term)
         * @internal
         * @param {null | UplcValue[]} args
         * @param {UplcRTECallbacksInternal} callbacks
         * @param {null | NetworkParams} networkParams
         * @returns {Promise<UplcValue>}
         */
        runInternal(args: null | UplcValue[], callbacks?: UplcRTECallbacksInternal, networkParams?: null | NetworkParams): Promise<UplcValue>;
        /**
         * Wrap the top-level term with consecutive UplcCall (not exported) terms.
         *
         * Returns a new UplcProgram instance, leaving the original untouched.
         *
         * Throws an error if you are trying to apply with an anon func.
         * @param {(UplcValue | HeliosData)[]} args
         * @returns {UplcProgram} - a new UplcProgram instance
         */
        apply(args: (UplcValue | HeliosData)[]): UplcProgram;
        /**
         * @param {null | UplcValue[]} args - if null the top-level term is returned as a value
         * @param {UplcRTECallbacks} callbacks
         * @param {null | NetworkParams} networkParams
         * @returns {Promise<UplcValue | RuntimeError>}
         */
        run(args: null | UplcValue[], callbacks?: UplcRTECallbacks, networkParams?: null | NetworkParams): Promise<UplcValue | RuntimeError>;
        /**
         * Run a `UplcProgram`. The printed messages are part of the return value.
         * @param {null | UplcValue[]} args
         * @returns {Promise<[(UplcValue | RuntimeError), string[]]>}
         */
        runWithPrint(args: null | UplcValue[]): Promise<[(UplcValue | RuntimeError), string[]]>;
        /**
         * Runs and profiles a `UplcProgram`. Needs the `NetworkParams` in order to calculate the execution budget.
         * @param {UplcValue[]} args
         * @param {NetworkParams} networkParams
         * @returns {Promise<Profile>} The returned profile contains a breakdown of the execution cost per Uplc term type and per Uplc builtin function type.
         */
        profile(args: UplcValue[], networkParams: NetworkParams): Promise<Profile>;
        /**
         * Returns flat bytes of serialized script
         * @returns {number[]}
         */
        serializeBytes(): number[];
        /**
         * Calculates the on chain size of the program (number of bytes).
         * @returns {number}
         */
        calcSize(): number;
        /**
         * Returns the Cbor encoding of a script (flat bytes wrapped twice in Cbor bytearray).
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * @internal
         * @param {Map<string, number>} codeMapFileIndices
         */
        toCborWithMapping(codeMapFileIndices: Map<string, number>): number[];
        /**
         * Returns the JSON representation of the serialized program (needed by cardano-cli).
         * @returns {string}
         */
        serialize(): string;
        /**
         * @returns {number[]} - 28 byte hash
         */
        hash(): number[];
        /**
         * Returns the `ValidatorHash` of the script. Throws an error if this isn't a spending validator script.
         * @type {ValidatorHash}
         */
        get validatorHash(): ValidatorHash;
        /**
         * Returns the `MintingPolicyHash` of the script. Throws an error if this isn't a minting policy.
         * @type {MintingPolicyHash}
         */
        get mintingPolicyHash(): MintingPolicyHash;
        /**
         * Returns the `StakingValidatorHash` of the script. Throws an error if this isn't a staking validator script.
         * @type {StakingValidatorHash}
         */
        get stakingValidatorHash(): StakingValidatorHash;
        #private;
    }
    /**
     * @internal
     */
    export class Tokenizer {
        /**
         * @param {Site} site
         * @param {string[]} chars
         * @param {boolean} reverse
         * @returns {string[]}
         */
        static assertCorrectDecimalUnderscores(site: Site, chars: string[], reverse?: boolean): string[];
        /**
         * Separates tokens in fields (separted by commas)
         * @param {Token[]} ts
         * @returns {Group | null}
         */
        static buildGroup(ts: Token[]): Group | null;
        /**
         * @param {Source} src
         * @param {?CodeMap} codeMap
         * @param {boolean} irMode - if true '@' is treated as a regular character
         */
        constructor(src: Source, codeMap?: CodeMap | null, irMode?: boolean);
        incrPos(): void;
        decrPos(): void;
        get currentSite(): Site;
        /**
         * @param {Token} t
         */
        pushToken(t: Token): void;
        /**
         * Reads a single char from the source and advances #pos by one
         * @returns {string}
         */
        readChar(): string;
        /**
         * @returns {string}
         */
        peekChar(): string;
        /**
         * Decreases #pos by one
         */
        unreadChar(): void;
        /**
         * Start reading precisely one token
         * @param {Site} site
         * @param {string} c
         */
        readToken(site: Site, c: string): void;
        /**
         * Tokenize the complete source.
         * Nests groups before returning a list of tokens
         * @returns {Token[] | null}
         */
        tokenize(): Token[] | null;
        /**
         * Returns a generator
         * Use gen.next().value to access to the next Token
         * Doesn't perform any grouping
         * Used for quickly parsing the ScriptPurpose header of a script
         * @returns {Generator<Token>}
         */
        streamTokens(): Generator<Token>;
        /**
         * Reads one word token.
         * Immediately turns "true" or "false" into a BoolLiteral instead of keeping it as Word
         * @param {Site} site
         * @param {string} c0 - first character
         */
        readWord(site: Site, c0: string): void;
        /**
         * Reads and discards a comment if current '/' char is followed by '/' or '*'.
         * Otherwise pushes Symbol('/') onto #ts
         * @param {Site} site
         */
        readMaybeComment(site: Site): void;
        /**
         * Reads and discards a single line comment (from '//' to end-of-line)
         */
        readSingleLineComment(): void;
        /**
         * Reads and discards a multi-line comment (from '/' '*' to '*' '/')
         * @param {Site} site
         */
        readMultiLineComment(site: Site): void;
        /**
         * REads a literal integer
         * @param {Site} site
         */
        readSpecialInteger(site: Site): void;
        /**
         * @param {Site} site
         */
        readBinaryInteger(site: Site): void;
        /**
         * @param {Site} site
         */
        readOctalInteger(site: Site): void;
        /**
         * @param {Site} site
         */
        readHexInteger(site: Site): void;
        /**
         * @param {Site} site
         * @param {string} c0 - first character
         */
        readDecimal(site: Site, c0: string): void;
        /**
         * @param {Site} site
         * @param {string} prefix
         * @param {(c: string) => boolean} valid - checks if character is valid as part of the radix
         */
        readRadixInteger(site: Site, prefix: string, valid: (c: string) => boolean): void;
        /**
         * @param {Site} site
         * @param {string[]} leading
         */
        readFixedPoint(site: Site, leading: string[]): void;
        /**
         * Reads literal hexadecimal representation of ByteArray
         * @param {Site} site
         */
        readByteArray(site: Site): void;
        /**
         * Reads literal Utf8 string and immediately encodes it as a ByteArray
         * @param {Site} site
         */
        readMaybeUtf8ByteArray(site: Site): void;
        /**
         * Doesn't push a token, instead returning the string itself
         * @internal
         * @param {Site} site
         * @returns {string}
         */
        readStringInternal(site: Site): string;
        /**
         * Reads literal string delimited by double quotes.
         * Allows for three escape character: '\\', '\n' and '\t'
         * @param {Site} site
         */
        readString(site: Site): void;
        /**
         * Reads single or double character symbols
         * @param {Site} site
         * @param {string} c0 - first character
         */
        readSymbol(site: Site, c0: string): void;
        /**
         * Match group open with group close symbols in order to form groups.
         * This is recursively applied to nested groups.
         * @param {Token[]} ts
         * @returns {Token[] | null}
         */
        nestGroups(ts: Token[]): Token[] | null;
        #private;
    }
    /**
     * @internal
     */
    export class Common {
        /**
         * @param {Typed} i
         * @param {Type} t
         * @returns {boolean}
         */
        static instanceOf(i: Typed, t: Type): boolean;
        /**
         * @param {Type | Type[]} type
         * @returns {Typed | Multi}
         */
        static toTyped(type: Type | Type[]): Typed | Multi;
        /**
         * Compares two types. Throws an error if neither is a Type.
         * @example
         * Common.typesEq(IntType, IntType) == true
         * @param {Type} a
         * @param {Type} b
         * @returns {boolean}
         */
        static typesEq(a: Type, b: Type): boolean;
        /**
         * @param {Type} type
         */
        static isEnum(type: Type): boolean;
        /**
         * @param {Type} type
         */
        static countEnumMembers(type: Type): number;
        /**
         * @param {TypeClass} tc
         * @returns {string[]}
         */
        static typeClassMembers(tc: TypeClass): string[];
        /**
         * @param {Type} type
         * @param {TypeClass} tc
         * @returns {boolean}
         */
        static typeImplements(type: Type, tc: TypeClass): boolean;
        /**
         * @returns {boolean}
         */
        isParametric(): boolean;
        /**
         * @type {null | DataType}
         */
        get asDataType(): DataType | null;
        /**
         * @type {null | EnumMemberType}
         */
        get asEnumMemberType(): EnumMemberType | null;
        /**
         * @type {null | Func}
         */
        get asFunc(): Func | null;
        /**
         * @type {null | Instance}
         */
        get asInstance(): Instance | null;
        /**
         * @type {null | Multi}
         */
        get asMulti(): Multi | null;
        /**
         * @type {null | Named}
         */
        get asNamed(): Named | null;
        /**
         * @type {null | Namespace}
         */
        get asNamespace(): Namespace | null;
        /**
         * @type {null | Parametric}
         */
        get asParametric(): Parametric | null;
        /**
         * @type {null | Type}
         */
        get asType(): Type | null;
        /**
         * @type {null | Typed}
         */
        get asTyped(): Typed | null;
        /**
         * @type {null | TypeClass}
         */
        get asTypeClass(): TypeClass | null;
        /**
         * @type {boolean}
         */
        get ready(): boolean;
        /**
         * @param {any} obj
         * @param {JsToUplcHelpers} helpers
         * @returns {Promise<UplcData>}
         */
        jsToUplc(obj: any, helpers: JsToUplcHelpers): Promise<UplcData>;
        /**
         * @param {UplcData} data
         * @param {UplcToJsHelpers} helpers
         * @returns {Promise<any>}
         */
        uplcToJs(data: UplcData, helpers: UplcToJsHelpers): Promise<any>;
        /**
         * @returns {string}
         */
        toString(): string;
    }
    /**
     * @internal
     * @implements {DataType}
     */
    export class AllType extends Common implements DataType {
        /**
         * @type {DataType}
         */
        get asDataType(): DataType;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * @type {HeliosDataClass<HeliosData> | null}
         */
        get offChainType(): HeliosDataClass<HeliosData> | null;
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * @internal
     * @implements {DataType}
     */
    export class AnyType extends Common implements DataType {
        get fieldNames(): never[];
        get offChainType(): null;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {DataType}
         */
        get asDataType(): DataType;
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * Type of special case of no-return value where execution can't continue.
     * @internal
     * @implements {Type}
     */
    export class ErrorType extends Common implements Type {
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isBaseOf(type: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * @internal
     */
    export class ArgType {
        /**
         *
         * @param {null | Word} name
         * @param {Type} type
         * @param {boolean} optional
         */
        constructor(name: null | Word, type: Type, optional?: boolean);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * @internal
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {ArgType}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): ArgType;
        /**
         * @param {ArgType} other
         * @returns {boolean}
         */
        isBaseOf(other: ArgType): boolean;
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        /**
         * @returns {boolean}
         */
        isOptional(): boolean;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * Function type with arg types and a return type
     * @internal
     * @implements {Type}
     */
    export class FuncType extends Common implements Type {
        /**
         * @param {Type[] | ArgType[]} argTypes
         * @param {Type | Type[]} retTypes
         */
        constructor(argTypes: Type[] | ArgType[], retTypes: Type | Type[]);
        /**
         * @type {Type[]}
         */
        get argTypes(): Type[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {number}
         */
        get nArgs(): number;
        /**
         * @type {number}
         */
        get nNonOptArgs(): number;
        /**
         * @type {number}
         */
        get nOptArgs(): number;
        /**
         * @type {Type[]}
         */
        get retTypes(): Type[];
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * Checks if arg types are valid.
         * Throws errors if not valid. Returns the return type if valid.
         * @param {Site} site
         * @param {Typed[]} posArgs
         * @param {{[name: string]: Typed}} namedArgs
         * @returns {null | Type[]}
         */
        checkCall(site: Site, posArgs: Typed[], namedArgs?: {
            [name: string]: Typed;
        }): null | Type[];
        /**
         * @internal
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @internal
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {Type[]} argTypes
         * @returns {FuncType}
         */
        inferArgs(site: Site, map: InferenceMap, argTypes: Type[]): FuncType;
        /**
         * Checks if any of 'this' argTypes or retType is same as Type.
         * Only if this checks return true is the association allowed.
         * @param {Site} site
         * @param {Type} type
         * @returns {boolean}
         */
        isAssociated(site: Site, type: Type): boolean;
        /**
         * Checks if 'this' is a base type of another FuncType.
         * The number of args needs to be the same.
         * Each argType of the FuncType we are checking against needs to be the same or less specific (i.e. isBaseOf(this.#argTypes[i]))
         * The retType of 'this' needs to be the same or more specific
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * Checks if the type of the first arg is the same as 'type'
         * Also returns false if there are no args.
         * For a method to be a valid instance member its first argument must also be named 'self', but that is checked elsewhere
         * @param {Site} site
         * @param {Type} type
         * @returns {boolean}
         */
        isMaybeMethod(site: Site, type: Type): boolean;
        /**
         * Throws an error if name isn't found
         * @param {Site} site
         * @param {string} name
         * @returns {number}
         */
        getNamedIndex(site: Site, name: string): number;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
        #private;
    }
    /**
     * @internal
     * @template {HeliosData} T
     * @typedef {{
     *   name: string,
     *   path?: string,
     *   offChainType?: HeliosDataClass<T> | null,
     *   genOffChainType?: (() => HeliosDataClass<T>) | null
     *   fieldNames?: string[],
     *   genInstanceMembers: (self: Type) => InstanceMembers,
     *   genTypeMembers: (self: Type) => TypeMembers
     *   genTypeDetails?: (self: Type) => TypeDetails,
     *   jsToUplc?: JsToUplcConverter
     *   uplcToJs?: UplcToJsConverter
     * }} GenericTypeProps
     */
    /**
     * Created by statements
     * @internal
     * @template {HeliosData} T
     * @implements {DataType}
     */
    export class GenericType<T extends HeliosData> extends Common implements DataType {
        /**
         * @param {GenericTypeProps<T>} props
         */
        constructor({ name, path, offChainType, genOffChainType, fieldNames, genInstanceMembers, genTypeMembers, genTypeDetails, jsToUplc, uplcToJs }: GenericTypeProps<T>);
        /**
         * @type {DataType}
         */
        get asDataType(): DataType;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {null | HeliosDataClass<T>}
         */
        get offChainType(): HeliosDataClass<T> | null;
        /**
         * @type {TypeDetails}
         */
        get typeDetails(): TypeDetails;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         */
        applyInternal(site: Site, map: InferenceMap): {
            name: string;
            path: string;
            fieldNames: string[];
            genInstanceMembers: (self: any) => InstanceMembers;
            genTypeMembers: (self: any) => TypeMembers;
        };
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {string} name
         * @param {string} path
         * @returns {GenericType}
         */
        changeNameAndPath(name: string, path: string): GenericType<any>;
        /**
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
        #private;
    }
    /**
     * @internal
     * @template {HeliosData} T
     * @typedef {{
     *   name: string,
     *   path?: string,
     *   constrIndex: number,
     *   parentType: DataType,
     *   offChainType?: HeliosDataClass<T>,
     *   genOffChainType?: () => HeliosDataClass<T>,
     *   fieldNames?: string[],
     *   genInstanceMembers: (self: Type) => InstanceMembers,
     *   genTypeMembers?: (self: Type) => TypeMembers
     *   genTypeDetails?: (self: Type) => TypeDetails
     *   jsToUplc?: JsToUplcConverter
     *   uplcToJs?: UplcToJsConverter
     * }} GenericEnumMemberTypeProps
     */
    /**
     * Created by statements
     * @internal
     * @template {HeliosData} T
     * @implements {EnumMemberType}
     * @extends {GenericType<T>}
     */
    export class GenericEnumMemberType<T extends HeliosData> extends GenericType<T> implements EnumMemberType {
        /**
         * @param {GenericEnumMemberTypeProps<T>} props
         */
        constructor({ name, path, constrIndex, parentType, offChainType, genOffChainType, fieldNames, genInstanceMembers, genTypeMembers, genTypeDetails, jsToUplc, uplcToJs }: GenericEnumMemberTypeProps<T>);
        /**
         * @type {number}
         */
        get constrIndex(): number;
        /**
         * @type {DataType}
         */
        get parentType(): DataType;
        /**
         * @type {EnumMemberType}
         */
        get asEnumMemberType(): EnumMemberType;
        #private;
    }
    /**
     * Type of return-value of functions that don't return anything (eg. assert, print, error)
     * @internal
     * @implements {Type}
     */
    export class VoidType extends Common implements Type {
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         *
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isBaseOf(type: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * A regular non-Func Instance. DataValues can always be compared, serialized, used in containers.
     * @internal
     * @implements {Instance}
     */
    export class DataEntity extends Common implements Instance {
        /**
         * @param {DataType} type
         */
        constructor(type: DataType);
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * @type {Instance}
         */
        get asInstance(): Instance;
        /**
         * @type {Typed}
         */
        get asTyped(): Typed;
        #private;
    }
    /**
     * Returned by an error()
     * Special case of no-return-value that indicates that execution can't proceed.
     * @internal
     */
    export class ErrorEntity extends Common {
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * @type {Instance}
         */
        get asInstance(): Instance;
        /**
         * @type {Typed}
         */
        get asTyped(): Typed;
    }
    /**
     * @internal
     * @implements {Named}
     */
    export class NamedEntity implements Named {
        /**
         * @param {string} name
         * @param {string} path
         * @param {EvalEntity} entity
         */
        constructor(name: string, path: string, entity: EvalEntity);
        /**
         * @type {null | DataType}
         */
        get asDataType(): DataType | null;
        /**
         * @type {null | EnumMemberType}
         */
        get asEnumMemberType(): EnumMemberType | null;
        /**
         * @type {null | Func}
         */
        get asFunc(): Func | null;
        /**
         * @type {null | Instance}
         */
        get asInstance(): Instance | null;
        /**
         * @type {null | Multi}
         */
        get asMulti(): Multi | null;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {null | Namespace}
         */
        get asNamespace(): Namespace | null;
        /**
         * @type {null | Parametric}
         */
        get asParametric(): Parametric | null;
        /**
         * @type {null | Type}
         */
        get asType(): Type | null;
        /**
         * @type {null | Typed}
         */
        get asTyped(): Typed | null;
        /**
         * @type {null | TypeClass}
         */
        get asTypeClass(): TypeClass | null;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * A callable Instance.
     * @internal
     * @implements {Func}
     */
    export class FuncEntity extends Common implements Func {
        /**
         * @param {FuncType} type
         */
        constructor(type: FuncType);
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * Returns the underlying FuncType directly.
         * @type {FuncType}
         */
        get funcType(): FuncType;
        /**
         * @type {Func}
         */
        get asFunc(): Func;
        /**
         * @type {Typed}
         */
        get asTyped(): Typed;
        /**
         * @param {Site} site
         * @param {Typed[]} args
         * @param {{[name: string]: Typed}} namedArgs
         * @returns {null | Typed | Multi}
         */
        call(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }): null | Typed | Multi;
        #private;
    }
    /**
     * Wraps multiple return values
     * @internal
     * @implements {Multi}
     */
    export class MultiEntity extends Common implements Multi {
        /**
         * @param {(Typed | Multi)[]} vals
         * @returns {Typed[]}
         */
        static flatten(vals: (Typed | Multi)[]): Typed[];
        /**
         * @param {Typed[]} values
         */
        constructor(values: Typed[]);
        /**
         * @type {Typed[]}
         */
        get values(): Typed[];
        /**
         * @type {Multi}
         */
        get asMulti(): Multi;
        #private;
    }
    /**
     * @internal
     * @implements {Typed}
     */
    export class TypedEntity extends Common implements Typed {
        /**
         * @param {Type} type
         */
        constructor(type: Type);
        /**
         * @returns {Typed}
         */
        get asTyped(): Typed;
        /**
         * @type {Type}
         */
        get type(): Type;
        #private;
    }
    /**
     * Returned by functions that don't return anything (eg. assert, error, print)
     * @internal
     * @implements {Instance}
     */
    export class VoidEntity extends Common implements Instance {
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * @type {Instance}
         */
        get asInstance(): Instance;
        /**
         * @type {Typed}
         */
        get asTyped(): Typed;
    }
    /**
     * @internal
     * @implements {Namespace}
     */
    export class ModuleNamespace extends Common implements Namespace {
        /**
         * @param {NamespaceMembers} members
         */
        constructor(members: NamespaceMembers);
        /**
         * @type {NamespaceMembers}
         */
        get namespaceMembers(): NamespaceMembers;
        /**
         * @type {Namespace}
         */
        get asNamespace(): Namespace;
        #private;
    }
    /**
     * Builtin bool type
     * @internal
     * @type {DataType}
     */
    export const BoolType: DataType;
    /**
     * Builtin bytearray type
     * @internal
     * @type {DataType}
     */
    export const ByteArrayType: DataType;
    /**
     * @internal
     * @type {DataType}
     */
    export const IntType: DataType;
    /**
     * Type of external data that must be cast/type-checked before using
     * Not named 'Data' in Js because it's too generic
     * @internal
     * @type {DataType}
     */
    export const RawDataType: DataType;
    /**
     * Builtin Real fixed point number type
     * @internal
     * @type {DataType}
     */
    export const RealType: DataType;
    /**
     * Builtin string type
     * @internal
     * @type {DataType}
     */
    export const StringType: DataType;
    /**
     * Created by statements
     * @internal
     * @template {HeliosData} T
     * @implements {DataType}
     */
    export class GenericParametricType<T extends HeliosData> extends GenericType<any> implements DataType {
    }
    /**
     * Created by statements
     * @internal
     * @template {HeliosData} T
     * @implements {EnumMemberType}
     * @extends {GenericEnumMemberType<T>}
     */
    export class GenericParametricEnumMemberType<T extends HeliosData> extends GenericEnumMemberType<T> implements EnumMemberType {
    }
    /**
     * @internal
     * @implements {Type}
     */
    export class TypeClassImpl extends Common implements Type {
        /**
         * @param {TypeClass} typeClass
         * @param {string} name
         * @param {null | ParameterI} parameter - reference to original parameter, which is more unique than name
         */
        constructor(typeClass: TypeClass, name: string, parameter: null | ParameterI);
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * @internal
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * Returns 'true' if 'this' is a base-type of 'type'. Throws an error if 'this' isn't a Type.
         * @param {Type} type
         * @returns {boolean}
         */
        isBaseOf(type: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
        #private;
    }
    /**
     * @internal
     * @implements {DataType}
     */
    export class DataTypeClassImpl extends TypeClassImpl implements DataType {
        /**
         * @param {TypeClass} typeClass
         * @param {string} name
         * @param {string} path
         * @param {null | ParameterI} parameter
         */
        constructor(typeClass: TypeClass, name: string, path: string, parameter: null | ParameterI);
        /**
         * @type {DataType}
         */
        get asDataType(): DataType;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {null | HeliosDataClass<HeliosData>}
         */
        get offChainType(): HeliosDataClass<HeliosData> | null;
        /**
         * @type {string}
         */
        get path(): string;
        #private;
    }
    /**
     * @internal
     * @implements {TypeClass}
     */
    export class AnyTypeClass extends Common implements TypeClass {
        /**
         * @type {TypeClass}
         */
        get asTypeClass(): TypeClass;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genInstanceMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genTypeMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isImplementedBy(type: Type): boolean;
        /**
         * @param {string} name
         * @param {string} path
         * @param {null | ParameterI} parameter
         * @returns {Type}
         */
        toType(name: string, path: string, parameter?: null | ParameterI): Type;
    }
    /**
     * @internal
     * @implements {TypeClass}
     */
    export class DefaultTypeClass extends Common implements TypeClass {
        /**
         * @type {TypeClass}
         */
        get asTypeClass(): TypeClass;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genTypeMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genInstanceMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isImplementedBy(type: Type): boolean;
        /**
         * @param {string} name
         * @param {string} path
         * @param {null | ParameterI} parameter
         * @returns {DataType}
         */
        toType(name: string, path: string, parameter?: null | ParameterI): DataType;
    }
    /**
     * @internal
     * @implements {TypeClass}
     */
    export class SummableTypeClass extends Common implements TypeClass {
        /**
         * @type {TypeClass}
         */
        get asTypeClass(): TypeClass;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genTypeMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} impl
         * @returns {TypeClassMembers}
         */
        genInstanceMembers(impl: Type): TypeClassMembers;
        /**
         * @param {Type} type
         * @returns {boolean}
         */
        isImplementedBy(type: Type): boolean;
        /**
         * @param {string} name
         * @param {string} path
         * @param {null | ParameterI} parameter
         * @returns {DataType}
         */
        toType(name: string, path: string, parameter?: null | ParameterI): DataType;
    }
    /**
     * @internal
     * @implements {ParameterI}
     */
    export class Parameter implements ParameterI {
        /**
         * @param {string} name - typically "a" or "b"
         * @param {string} path - typicall "__T0" or "__F0"
         * @param {TypeClass} typeClass
         */
        constructor(name: string, path: string, typeClass: TypeClass);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {Type}
         */
        get ref(): Type;
        /**
         * A null TypeClass matches any type
         * @type {TypeClass}
         */
        get typeClass(): TypeClass;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * Only func instances can be parametrics instances,
     *  there are no other kinds of parametric instances
     * @internal
     * @implements {Parametric}
     */
    export class ParametricFunc extends Common implements Parametric {
        /**
         * @param {Parameter[]} params
         * @param {FuncType} fnType
         */
        constructor(params: Parameter[], fnType: FuncType);
        /**
         * @type {null | ((...any) => HeliosDataClass<HeliosData>)}
         */
        get offChainType(): ((...any: any[]) => HeliosDataClass<HeliosData>) | null;
        get params(): Parameter[];
        get fnType(): FuncType;
        /**
         * null TypeClasses aren't included
         * @type {TypeClass[]}
         */
        get typeClasses(): TypeClass[];
        /**
         * @param {Type[]} types
         * @param {Site} site
         * @returns {EvalEntity}
         */
        apply(types: Type[], site?: Site): EvalEntity;
        /**
         * @type {Parametric}
         */
        get asParametric(): Parametric;
        /**
         * Must infer before calling
         * @param {Site} site
         * @param {Typed[]} args
         * @param {{[name: string]: Typed}} namedArgs
         * @param {Type[]} paramTypes - so that paramTypes can be accessed by caller
         * @returns {Func}
         */
        inferCall(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }, paramTypes?: Type[]): Func;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @returns {Parametric}
         */
        infer(site: Site, map: InferenceMap): Parametric;
        #private;
    }
    /**
     * @internal
     * @implements {Parametric}
     */
    export class ParametricType extends Common implements Parametric {
        /**
         * @param {{
         * 	 name: string,
         *   offChainType?: ((...any) => HeliosDataClass<HeliosData>)
         *   parameters: Parameter[]
         *   apply: (types: Type[]) => DataType
         * }} props
         */
        constructor({ name, offChainType, parameters, apply }: {
            name: string;
            offChainType?: ((...any: any[]) => HeliosDataClass<HeliosData>) | undefined;
            parameters: Parameter[];
            apply: (types: Type[]) => DataType;
        });
        /**
         * @type {Parametric}
         */
        get asParametric(): Parametric;
        /**
         * @type {null | ((...any) => HeliosDataClass<HeliosData>)}
         */
        get offChainType(): ((...any: any[]) => HeliosDataClass<HeliosData>) | null;
        /**
         * @type {TypeClass[]}
         */
        get typeClasses(): TypeClass[];
        /**
         * @param {Type[]} types
         * @param {Site} site
         * @returns {EvalEntity}
         */
        apply(types: Type[], site?: Site): EvalEntity;
        /**
        * Must infer before calling
        * @param {Site} site
        * @param {Typed[]} args
        * @param {{[name: string]: Typed}} namedArgs
        * @param {Type[]} paramTypes - so that paramTypes can be accessed by caller
        * @returns {Func}
        */
        inferCall(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }, paramTypes?: Type[]): Func;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @returns {Parametric}
         */
        infer(site: Site, map: InferenceMap): Parametric;
        #private;
    }
    /**
     * Used by print, error, and assert
     * @internal
     * @implements {Func}
     * @implements {Named}
     */
    export class BuiltinFunc extends Common implements Func, Named {
        /**
         *
         * @param {{
         *   name: string,
         *   type: FuncType
         * }} props
         */
        constructor({ name, type }: {
            name: string;
            type: FuncType;
        });
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {Type}
         */
        get type(): Type;
        /**
         * @type {FuncType}
         */
        get funcType(): FuncType;
        /**
         * @type {Func}
         */
        get asFunc(): Func;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {Typed}
         */
        get asTyped(): Typed;
        /**
         * @param {Site} site
         * @param {Typed[]} args
         * @param {{[name: string]: Typed}} namedArgs
         * @returns {null | Typed | Multi}
         */
        call(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        }): null | Typed | Multi;
        #private;
    }
    /**
     * Special builtin function that throws an error if condition is false and returns Void
     * @internal
     */
    export const AssertFunc: BuiltinFunc;
    /**
     * Special builtin function that throws an error and returns ErrorInstance (special case of Void)
     * @internal
     */
    export const ErrorFunc: BuiltinFunc;
    /**
     * Special builtin function that prints a message and returns void
     * @internal
     */
    export const PrintFunc: BuiltinFunc;
    /**
     * Builtin list type
     * @internal
     * @type {Parametric}
     */
    export const ListType: Parametric;
    /**
     * Builtin map type (in reality list of key-value pairs)
     * @internal
     * @type {Parametric}
     */
    export const MapType: Parametric;
    /**
     * Builtin option type
     * @internal
     * @type {Parametric}
     */
    export const OptionType: Parametric;
    /**
     * Builtin Duration type
     * @internal
     * @type {DataType}
     */
    export const DurationType: DataType;
    /**
     * Builtin Time type. Opaque alias of Int representing milliseconds since 1970
     * @internal
     * @type {DataType}
     */
    export const TimeType: DataType;
    /**
     * Builtin TimeRange type
     * @internal
     * @type {DataType}
     */
    export const TimeRangeType: DataType;
    /**
     * @internal
     * @implements {DataType}
     */
    export class ScriptHashType extends GenericType<any> implements DataType {
        /**
         *
         * @param {null | string } name
         * @param {null | HeliosDataClass<HeliosData>} offChainType
         */
        constructor(name?: null | string, offChainType?: null | HeliosDataClass<HeliosData>);
    }
    /**
     * @internal
     * @type {DataType}
     */
    export const scriptHashType: DataType;
    /**
     * @internal
     * @type {DataType}
     */
    export const DatumHashType: DataType;
    /**
     * @internal
     * @type {ScriptHashType}
     */
    export const MintingPolicyHashType: ScriptHashType;
    /**
     * Builtin PubKey type
     * @internal
     * @type {DataType}
     */
    export const PubKeyType: DataType;
    /**
     * Builtin PubKeyHash type
     * @internal
     * @type {DataType}
     */
    export const PubKeyHashType: DataType;
    /**
     * Builtin StakingHash type
     * @internal
     * @type {DataType}
     */
    export const StakingHashType: DataType;
    /**
     * @internal
     * @type {EnumMemberType}
     */
    export const StakingHashStakeKeyType: EnumMemberType;
    /**
     * @internal
     * @type {EnumMemberType}
     */
    export const StakingHashValidatorType: EnumMemberType;
    /**
     * @internal
     * @type {ScriptHashType}
     */
    export const StakingValidatorHashType: ScriptHashType;
    /**
     * @internal
     * @type {ScriptHashType}
     */
    export const ValidatorHashType: ScriptHashType;
    /**
     * Builtin AssetClass type
     * @internal
     * @type {DataType}
     */
    export const AssetClassType: DataType;
    /**
     * Builtin money Value type
     * @internal
     * @type {DataType}
     */
    export const ValueType: DataType;
    /**
     * @internal
     * @implements {TypeClass}
     */
    export class ValuableTypeClass extends DefaultTypeClass implements TypeClass {
    }
    /**
     * Buitin Address type
     * @internal
     * @type {DataType}
     */
    export const AddressType: DataType;
    /**
     * @internal
     * @type {DataType}
     */
    export const DCertType: DataType;
    /**
     * Builtin Credential type
     * @internal
     * @type {DataType}
     */
    export const CredentialType: DataType;
    /**
     * @internal
     * @type {DataType}
     */
    export const OutputDatumType: DataType;
    /**
     * Base class for ScriptContext, ContractContext, Scripts and other "macro"-types
     * @internal
     */
    export class MacroType extends Common {
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @type {InstanceMembers}
         */
        get instanceMembers(): InstanceMembers;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {null | HeliosDataClass<HeliosData>}
         */
        get offChainType(): HeliosDataClass<HeliosData> | null;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @type {TypeMembers}
         */
        get typeMembers(): TypeMembers;
        /**
         * @type {DataType}
         */
        get asDataType(): DataType;
        /**
         * @type {Named}
         */
        get asNamed(): Named;
        /**
         * @type {Type}
         */
        get asType(): Type;
        /**
         * @param {Site} site
         * @param {InferenceMap} map
         * @param {null | Type} type
         * @returns {Type}
         */
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        /**
         * @param {Type} other
         * @returns {boolean}
         */
        isBaseOf(other: Type): boolean;
        /**
         * @returns {Typed}
         */
        toTyped(): Typed;
    }
    /**
     * @internal
     * @typedef {{[name: string]: ScriptHashType}} ScriptTypes
     */
    /**
     * @internal
     * @implements {DataType}
     */
    export class ScriptsType extends MacroType implements DataType {
        /**
         * @param {ScriptTypes} scripts
         */
        constructor(scripts: ScriptTypes);
        /**
         * @returns {boolean}
         */
        isEmpty(): boolean;
        #private;
    }
    /**
     * Builtin ScriptContext type
     * @internal
     * @implements {DataType}
     */
    export class ScriptContextType extends MacroType implements DataType {
    }
    /**
     * Builtin ScriptContext type
     * @internal
     * @implements {DataType}
     */
    export class ContractContextType extends MacroType implements DataType {
    }
    /**
     * @internal
     */
    export const WalletType: GenericType<HeliosData>;
    /**
     * Does this really need to be a class? (i.e. will it be instantiated with some properties)
     * @internal
     */
    export const NetworkType: GenericType<HeliosData>;
    /**
     * Builtin ScriptPurpose type (Minting| Spending| Rewarding | Certifying)
     * @internal
     * @type {DataType}
     */
    export const ScriptPurposeType: DataType;
    /**
     * Builtin StakingCredential type
     * @internal
     * @type {DataType}
     */
    export const StakingCredentialType: DataType;
    /**
     * Builtin StakingPurpose type (Rewarding or Certifying)
     * @internal
     * @type {DataType}
     */
    export const StakingPurposeType: DataType;
    /**
     * @internal
     */
    export const TxBuilderType: GenericType<HeliosData>;
    /**
     * Builtin Tx type
     * @internal
     * @type {DataType}
     */
    export const TxType: DataType;
    /**
     * Builtin TxId type
     * @internal
     * @type {DataType}
     */
    export const TxIdType: DataType;
    /**
     * Builtin TxInput type
     * @internal
     * @type {DataType}
     */
    export const TxInputType: DataType;
    /**
     * Builtin TxOutput type
     * @internal
     * @type {DataType}
     */
    export const TxOutputType: DataType;
    /**
     * Builtin TxOutputId type
     * @internal
     * @type {DataType}
     */
    export const TxOutputIdType: DataType;
    /**
     * @internal
     * @type {{[name: string]: DataType}}
     */
    export const builtinTypes: {
        [name: string]: DataType;
    };
    /**
     * GlobalScope sits above the top-level scope and contains references to all the builtin Values and Types
     * @internal
     */
    export class GlobalScope {
        /**
         * Initialize the GlobalScope with all the builtins
         * @param {ScriptTypes} scriptTypes - types of all the scripts in a contract/ensemble
         * @returns {GlobalScope}
         */
        static new(scriptTypes?: ScriptTypes): GlobalScope;
        /**
         * Checks if scope contains a name
         * @param {Word} name
         * @returns {boolean}
         */
        has(name: Word): boolean;
        /**
         * Sets a global name, doesn't check for uniqueness
         * Called when initializing GlobalScope
         * @param {string | Word} name
         * @param {EvalEntity} value
         */
        set(name: string | Word, value: EvalEntity): void;
        /**
         * Gets a named value from the scope.
         * Throws an error if not found.
         * @param {Word} name
         * @returns {null | EvalEntity}
         */
        get(name: Word): null | EvalEntity;
        /**
         * @returns {boolean}
         */
        isStrict(): boolean;
        /**
         * @param {(name: string, type: Type) => void} callback
         */
        loopTypes(callback: (name: string, type: Type) => void): void;
        #private;
    }
    /**
     * User scope
     * @internal
     * @implements {EvalEntity}
     */
    export class Scope extends Common implements EvalEntity {
        /**
         * @param {GlobalScope | Scope} parent
         * @param {boolean} allowShadowing
         */
        constructor(parent: GlobalScope | Scope, allowShadowing?: boolean);
        /**
         * @type {boolean}
         */
        get allowShadowing(): boolean;
        /**
         * Used by top-scope to loop over all the statements
         */
        get values(): [Word, EvalEntity | Scope, boolean][];
        /**
         * Checks if scope contains a name
         * @param {Word} name
         * @returns {boolean}
         */
        has(name: Word): boolean;
        /**
         * Sets a named value. Throws an error if not unique
         * @param {Word} name
         * @param {EvalEntity | Scope} value
         */
        setInternal(name: Word, value: EvalEntity | Scope, allowShadowing?: boolean): void;
        /**
         * Sets a named value. Throws an error if not unique
         * @param {Word} name
         * @param {EvalEntity | Scope} value
         */
        set(name: Word, value: EvalEntity | Scope): void;
        /**
         * @param {Word} name
         */
        remove(name: Word): void;
        /**
         * @param {Word} name
         * @returns {null | Scope}
         */
        getScope(name: Word): null | Scope;
        /**
         * Gets a named value from the scope. Throws an error if not found
         * @param {Word} name
         * @param {boolean} dryRun - if false -> don't set used flag
         * @returns {null | EvalEntity | Scope}
         */
        get(name: Word, dryRun?: boolean): null | EvalEntity | Scope;
        /**
         * @returns {boolean}
         */
        isStrict(): boolean;
        /**
         * Asserts that all named values are user.
         * Throws an error if some are unused.
         * Check is only run if we are in strict mode
         * @param {boolean} onlyIfStrict
         */
        assertAllUsed(onlyIfStrict?: boolean): void;
        /**
         * @param {Word} name
         * @returns {boolean}
         */
        isUsed(name: Word): boolean;
        dump(): void;
        /**
         * @param {(name: string, type: Type) => void} callback
         */
        loopTypes(callback: (name: string, type: Type) => void): void;
        #private;
    }
    /**
     * TopScope is a special scope that can contain UserTypes
     * @internal
     */
    export class TopScope extends Scope {
        /**
         * @param {GlobalScope} parent
         * @param {boolean} strict
         */
        constructor(parent: GlobalScope, strict?: boolean);
        /**
         * Prepends "__scope__" to name before actually setting scope
         * @param {Word} name
         * @param {Scope} value
         */
        setScope(name: Word, value: Scope): void;
        /**
         * @param {boolean} s
         */
        setStrict(s: boolean): void;
        /**
         * @param {Word} name
         * @returns {ModuleScope}
         */
        getModuleScope(name: Word): ModuleScope;
        #private;
    }
    /**
     * @internal
     */
    export class ModuleScope extends Scope {
    }
    /**
     * @internal
     */
    export class ToIRContext {
        /**
         * @param {boolean} simplify
         * @param {string} indent
         * @param {Map<string, RawFunc>} db
         */
        constructor(simplify: boolean, indent?: string, db?: Map<string, RawFunc>);
        /**
         * @readonly
         * @type {boolean}
         */
        readonly simplify: boolean;
        /**
         * @readonly
         * @type {string}
         */
        readonly indent: string;
        /**
         * @returns {ToIRContext}
         */
        tab(): ToIRContext;
        /**
         * @type {Map<string, RawFunc>}
         */
        get db(): Map<string, RawFunc>;
        #private;
    }
    /**
     * Base class of every Type and Instance expression.
     * @internal
     */
    export class Expr extends Token {
        /**
         * Used in switch cases where initial typeExpr is used as memberName instead
         * @param {null | EvalEntity} c
         */
        set cache(arg: EvalEntity | null);
        /**
         * @type {null | EvalEntity}
         */
        get cache(): EvalEntity | null;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: Scope): null | EvalEntity;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        eval(scope: Scope): null | EvalEntity;
        /**
         * @param {Scope} scope
         * @returns {null | DataType}
         */
        evalAsDataType(scope: Scope): null | DataType;
        /**
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalAsType(scope: Scope): null | Type;
        /**
         * @param {Scope} scope
         * @returns {null | Typed}
         */
        evalAsTyped(scope: Scope): null | Typed;
        /**
         * @param {Scope} scope
         * @returns {null | Typed | Multi}
         */
        evalAsTypedOrMulti(scope: Scope): null | Typed | Multi;
        /**
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIR(ctx: ToIRContext): IR;
        #private;
    }
    /**
     * Simple reference class (i.e. using a Word)
     * @internal
     */
    export class RefExpr extends Expr {
        /**
         * @param {Word} name
         */
        constructor(name: Word);
        #private;
    }
    /**
     * Name::Member expression
     * @internal
     */
    export class PathExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} baseExpr
         * @param {Word} memberName
         */
        constructor(site: Site, baseExpr: Expr, memberName: Word);
        /**
         * @type {Expr}
         */
        get baseExpr(): Expr;
        #private;
    }
    /**
     * Name::Member expression which can instantiate zero field structs and enum members
     * @internal
     */
    export class ValuePathExpr extends PathExpr {
    }
    /**
     * []ItemType
     * @internal
     */
    export class ListTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} itemTypeExpr
         */
        constructor(site: Site, itemTypeExpr: Expr);
        /**
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalInternal(scope: Scope): null | Type;
        #private;
    }
    /**
     * Map[KeyType]ValueType expression
     * @internal
     */
    export class MapTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} keyTypeExpr
         * @param {Expr} valueTypeExpr
         */
        constructor(site: Site, keyTypeExpr: Expr, valueTypeExpr: Expr);
        #private;
    }
    /**
     * Iterator[Type1, ...] expr
     * @internal
     */
    export class IteratorTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr[]} itemTypeExprs
         */
        constructor(site: Site, itemTypeExprs: Expr[]);
        #private;
    }
    /**
     * Option[SomeType] expression
     * @internal
     */
    export class OptionTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} someTypeExpr
         */
        constructor(site: Site, someTypeExpr: Expr);
        /**
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalInternal(scope: Scope): null | Type;
        #private;
    }
    /**
     * '()' which can only be used as return type of func
     * @internal
     */
    export class VoidTypeExpr extends Expr {
        /**
         * @param {Scope} scope
         * @returns {EvalEntity}
         */
        evalInternal(scope: Scope): EvalEntity;
    }
    /**
     * @internal
     */
    export class FuncArgTypeExpr extends Token {
        /**
         * @param {Site} site
         * @param {null | Word} name
         * @param {Expr} typeExpr
         * @param {boolean} optional
         */
        constructor(site: Site, name: null | Word, typeExpr: Expr, optional: boolean);
        optional: boolean;
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        /**
         * @returns {boolean}
         */
        isOptional(): boolean;
        /**
         * @param {Scope} scope
         * @returns {null | ArgType}
         */
        eval(scope: Scope): null | ArgType;
        #private;
    }
    /**
     * (ArgType1, ...) -> RetType expression
     * @internal
     */
    export class FuncTypeExpr extends Expr {
        /**
         * @param {Site} site
         * @param {FuncArgTypeExpr[]} argTypeExprs
         * @param {Expr[]} retTypeExprs
         */
        constructor(site: Site, argTypeExprs: FuncArgTypeExpr[], retTypeExprs: Expr[]);
        /**
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalInternal(scope: Scope): null | Type;
        #private;
    }
    /**
     * expr(...); ...
     * @internal
     */
    export class ChainExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} upstreamExpr
         * @param {Expr} downstreamExpr
         */
        constructor(site: Site, upstreamExpr: Expr, downstreamExpr: Expr);
        /**
         * @readonly
         * @type {Expr}
         */
        readonly upstreamExpr: Expr;
        /**
         * @readonly
         * @type {Expr}
         */
        readonly downstreamExpr: Expr;
    }
    /**
     * '... = ... ; ...' expression
     * @internal
     */
    export class AssignExpr extends ChainExpr {
        /**
         * @param {Site} site
         * @param {DestructExpr[]} nameTypes
         * @param {Expr} upstreamExpr
         * @param {Expr} downstreamExpr
         */
        constructor(site: Site, nameTypes: DestructExpr[], upstreamExpr: Expr, downstreamExpr: Expr);
        #private;
    }
    /**
     * Helios equivalent of unit
     * @internal
     */
    export class VoidExpr extends Expr {
        /**
         * @param {Scope} scope
         * @returns {Instance}
         */
        evalInternal(scope: Scope): Instance;
    }
    /**
     * Literal expression class (wraps literal tokens)
     * @internal
     */
    export class PrimitiveLiteralExpr extends Expr {
        /**
         * @param {PrimitiveLiteral} primitive
         */
        constructor(primitive: PrimitiveLiteral);
        /**
         * @type {DataType}
         */
        get type(): DataType;
        /**
         * @param {Scope} scope
         * @returns {EvalEntity}
         */
        evalInternal(scope: Scope): EvalEntity;
        #private;
    }
    /**
     * Literal UplcData which is the result of parameter substitutions.
     * @internal
     */
    export class LiteralDataExpr extends Expr {
        /**
         * @param {Site} site
         * @param {DataType} type
         * @param {UplcData} data
         */
        constructor(site: Site, type: DataType, data: UplcData);
        /**
         * @internal
         * @type {DataType}
         */
        get type(): DataType;
        /**
         * @param {Scope} scope
         * @returns {EvalEntity}
         */
        evalInternal(scope: Scope): EvalEntity;
        /**
         * @type {EvalEntity}
         */
        get cache(): EvalEntity;
        #private;
    }
    /**
     * Struct field (part of a literal struct constructor)
     * @internal
     */
    export class StructLiteralField {
        /**
         * @param {null | Word} name
         * @param {Expr} value
         */
        constructor(name: null | Word, value: Expr);
        /**
         * @type {Word}
         */
        get name(): Word;
        get site(): Site;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        eval(scope: Scope): null | EvalEntity;
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        /**
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIR(ctx: ToIRContext): IR;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * Struct literal constructor
     * @internal
     */
    export class StructLiteralExpr extends Expr {
        /**
         * @param {ToIRContext} ctx
         * @param {Site} site
         * @param {string} path
         * @param {IR[]} fields
         */
        static toIRInternal(ctx: ToIRContext, site: Site, path: string, fields: IR[]): IR;
        /**
         * @param {Expr} typeExpr
         * @param {StructLiteralField[]} fields
         */
        constructor(typeExpr: Expr, fields: StructLiteralField[]);
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        #private;
    }
    /**
     * []{...} expression
     * @internal
     */
    export class ListLiteralExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} itemTypeExpr
         * @param {Expr[]} itemExprs
         */
        constructor(site: Site, itemTypeExpr: Expr, itemExprs: Expr[]);
        /**
         * @type {DataType}
         */
        get itemType(): DataType;
        #private;
    }
    /**
     * Map[...]...{... : ...} expression
     * @internal
     */
    export class MapLiteralExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} keyTypeExpr
         * @param {Expr} valueTypeExpr
         * @param {[Expr, Expr][]} pairExprs
         */
        constructor(site: Site, keyTypeExpr: Expr, valueTypeExpr: Expr, pairExprs: [Expr, Expr][]);
        /**
         * @type {DataType}
         */
        get keyType(): DataType;
        /**
         * @type {DataType}
         */
        get valueType(): DataType;
        #private;
    }
    /**
     * NameTypePair is base class of FuncArg and DataField (differs from StructLiteralField)
     * @internal
     */
    export class NameTypePair {
        /**
         * @param {Word} name
         * @param {null | Expr} typeExpr
         */
        constructor(name: Word, typeExpr: null | Expr);
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * Throws an error if called before evalType()
         * @type {Type}
         */
        get type(): Type;
        /**
         * @type {null | Expr}
         */
        get typeExpr(): Expr | null;
        /**
         * @type {string}
         */
        get typeName(): string;
        /**
         * @returns {boolean}
         */
        isIgnored(): boolean;
        /**
         * @returns {boolean}
         */
        hasType(): boolean;
        /**
         * Evaluates the type, used by FuncLiteralExpr and DataDefinition
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalType(scope: Scope): null | Type;
        /**
         * @returns {IR}
         */
        toIR(): IR;
        /**
         *
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * Function argument class
     * @internal
     */
    export class FuncArg extends NameTypePair {
        /**
         * @param {IR} bodyIR
         * @param {string} name
         * @param {IR} defaultIR
         * @returns {IR}
         */
        static wrapWithDefaultInternal(bodyIR: IR, name: string, defaultIR: IR): IR;
        /**
         * @param {Word} name
         * @param {null | Expr} typeExpr
         * @param {null | Expr} defaultValueExpr
         */
        constructor(name: Word, typeExpr: null | Expr, defaultValueExpr?: null | Expr);
        /**
         * @param {Scope} scope
         */
        evalDefault(scope: Scope): void;
        /**
         * @param {Scope} scope
         * @returns {null | ArgType}
         */
        evalArgType(scope: Scope): null | ArgType;
        /**
         * (argName) -> {
         *   <bodyIR>
         * }(
         *   ifThenElse(
         * 		__useoptarg__argName,
         *  	() -> {
         *        argName
         *      },
         *      () -> {
         *        <defaultValueExpr>
         *      }
         *   )()
         * )
         * TODO: indentation
         * @param {ToIRContext} ctx
         * @param {IR} bodyIR
         * @returns {IR}
         */
        wrapWithDefault(ctx: ToIRContext, bodyIR: IR): IR;
        #private;
    }
    /**
     * (..) -> RetTypeExpr {...} expression
     * @internal
     */
    export class FuncLiteralExpr extends Expr {
        /**
         * @param {Site} site
         * @param {FuncArg[]} args
         * @param {(null | Expr)[]} retTypeExprs
         * @param {Expr} bodyExpr
         */
        constructor(site: Site, args: FuncArg[], retTypeExprs: (null | Expr)[], bodyExpr: Expr);
        /**
         * @type {number}
         */
        get nArgs(): number;
        /**
         * @type {string[]}
         */
        get argNames(): string[];
        /**
         * @type {Type[]}
         */
        get argTypes(): Type[];
        /**
         * @type {string[]}
         */
        get argTypeNames(): string[];
        /**
         * @type {Expr}
         */
        get retExpr(): Expr;
        /**
         * @type {Type[]}
         */
        get retTypes(): Type[];
        /**
         * @param {Scope} scope
         * @returns {null | FuncType}
         */
        evalType(scope: Scope): null | FuncType;
        isMethod(): boolean;
        /**
         * @returns {IR}
         */
        argsToIR(): IR;
        /**
         * In reverse order, because later opt args might depend on earlier args
         * @param {ToIRContext} ctx
         * @param {IR} innerIR
         * @returns {IR}
         */
        wrapWithDefaultArgs(ctx: ToIRContext, innerIR: IR): IR;
        /**
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIRInternal(ctx: ToIRContext): IR;
        #private;
    }
    /**
     * value[...] expression
     * @internal
     */
    export class ParametricExpr extends Expr {
        /**
         * Reused by CallExpr
         * @param {Type[]} paramTypes
         * @returns {string}
         */
        static toApplicationIR(paramTypes: Type[]): string;
        /**
         * @param {Site} site - site of brackets
         * @param {Expr} baseExpr
         * @param {Expr[]} parameters
         */
        constructor(site: Site, baseExpr: Expr, parameters: Expr[]);
        /**
         * @type {Type[]}
         */
        get paramTypes(): Type[];
        #private;
    }
    /**
     * Unary operator expression
     * Note: there are no post-unary operators, only pre
     * @internal
     */
    export class UnaryExpr extends Expr {
        /**
         * @param {SymbolToken} op
         * @param {Expr} a
         */
        constructor(op: SymbolToken, a: Expr);
        /**
         * Turns an op symbol into an internal name
         * @returns {Word}
         */
        translateOp(): Word;
        #private;
    }
    /**
     * @internal
     * @type {{[name: string]: string}}
     */
    export const BINARY_SYMBOLS_MAP: {
        [name: string]: string;
    };
    /**
     * Binary operator expression
     * @internal
     */
    export class BinaryExpr extends Expr {
        /**
         * @param {SymbolToken} op
         * @param {Expr} a
         * @param {Expr} b
         */
        constructor(op: SymbolToken, a: Expr, b: Expr);
        /**
         * @type {Expr}
         */
        get first(): Expr;
        /**
         * @type {Expr}
         */
        get second(): Expr;
        /**
         * Turns op symbol into internal name
         * @param {number} alt
         * @returns {Word}
         */
        translateOp(alt?: number): Word;
        /**
         * @returns {boolean}
         */
        isCommutative(): boolean;
        #private;
    }
    /**
     * Parentheses expression
     * @internal
     */
    export class ParensExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr[]} exprs
         */
        constructor(site: Site, exprs: Expr[]);
        #private;
    }
    /**
     * @internal
     */
    export class CallArgExpr extends Token {
        /**
         * @param {Site} site
         * @param {null | Word} name
         * @param {Expr} valueExpr
         */
        constructor(site: Site, name: null | Word, valueExpr: Expr);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {Expr}
         */
        get valueExpr(): Expr;
        /**
         * @type {EvalEntity}
         */
        get value(): EvalEntity;
        /**
         * @returns {boolean}
         */
        isNamed(): boolean;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        eval(scope: Scope): null | EvalEntity;
        #private;
    }
    /**
     * ...(...) expression
     * @internal
     */
    export class CallExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} fnExpr
         * @param {CallArgExpr[]} argExprs
         */
        constructor(site: Site, fnExpr: Expr, argExprs: CallArgExpr[]);
        get fnExpr(): Expr;
        /**
         * Don't call this inside eval() because param types won't yet be complete.
         * @type {FuncType}
         */
        get fn(): FuncType;
        /**
         * @param {ToIRContext} ctx
         * @returns {[Expr[], IR[]]} - first list are positional args, second list named args and remaining opt args
         */
        expandArgs(ctx: ToIRContext): [Expr[], IR[]];
        /**
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toFnExprIR(ctx: ToIRContext): IR;
        #private;
    }
    /**
     *  ... . ... expression
     * @internal
     */
    export class MemberExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} objExpr
         * @param {Word} memberName
         */
        constructor(site: Site, objExpr: Expr, memberName: Word);
        /**
         * @param {ToIRContext} ctx
         * @param {string} params - applied type parameters must be inserted Before the call to self
         * @returns {IR}
         */
        toIR(ctx: ToIRContext, params?: string): IR;
        #private;
    }
    /**
     * if-then-else expression
     * @internal
     */
    export class IfElseExpr extends Expr {
        /**
         * @param {Site} site
         * @param {null | Type} prevType
         * @param {Type} newType
         * @returns {null | Type}
         */
        static reduceBranchType(site: Site, prevType: null | Type, newType: Type): null | Type;
        /**
         * @param {Site} site
         * @param {null | Type[]} prevTypes
         * @param {Typed | Multi} newValue
         * @returns {null | Type[]}
         */
        static reduceBranchMultiType(site: Site, prevTypes: null | Type[], newValue: Typed | Multi): null | Type[];
        /**
         * @param {Site} site
         * @param {Expr[]} conditions
         * @param {Expr[]} branches
         */
        constructor(site: Site, conditions: Expr[], branches: Expr[]);
        #private;
    }
    /**
     * DestructExpr is for the lhs-side of assignments and for switch cases
     * @internal
     */
    export class DestructExpr {
        /**
         * @param {Word} name - use an underscore as a sink
         * @param {null | Expr} typeExpr
         * @param {DestructExpr[]} destructExprs
         */
        constructor(name: Word, typeExpr: null | Expr, destructExprs?: DestructExpr[]);
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @returns {boolean}
         */
        hasDestructExprs(): boolean;
        isIgnored(): boolean;
        /**
         * @returns {boolean}
         */
        hasType(): boolean;
        /**
         * Throws an error if called before evalType()
         * @type {null | Type}
         */
        get type(): Type | null;
        /**
         * @type {Word}
         */
        get typeName(): Word;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * Evaluates the type, used by FuncLiteralExpr and DataDefinition
         * @param {Scope} scope
         * @returns {null | Type}
         */
        evalType(scope: Scope): null | Type;
        /**
         * @param {Scope} scope
         * @param {Type} upstreamType
         */
        evalDestructExprs(scope: Scope, upstreamType: Type): void;
        /**
         * @param {Scope} scope
         * @param {Type} upstreamType
         * @param {number} i
         */
        evalInternal(scope: Scope, upstreamType: Type, i: number): null | undefined;
        /**
         * @param {Scope} scope
         * @param {DataType} caseType
         */
        evalInSwitchCase(scope: Scope, caseType: DataType): void;
        /**
         * @param {Scope} scope
         * @param {null | Type} upstreamType
         * @param {number} i
         */
        evalInAssignExpr(scope: Scope, upstreamType: null | Type, i: number): null | undefined;
        /**
         * @param {number} argIndex
         * @returns {IR}
         */
        toNameIR(argIndex: number): IR;
        /**
         * @param {number} fieldIndex
         * @returns {string}
         */
        getFieldFn(fieldIndex: number): string;
        /**
         * @param {ToIRContext} ctx
         * @param {IR} inner
         * @param {string} objName
         * @param {number} fieldIndex
         * @param {string} fieldFn
         * @returns {IR}
         */
        wrapDestructIRInternal(ctx: ToIRContext, inner: IR, objName: string, fieldIndex: number, fieldFn: string): IR;
        /**
         * @param {ToIRContext} ctx
         * @param {IR} inner
         * @param {number} argIndex
         * @returns {IR}
         */
        wrapDestructIR(ctx: ToIRContext, inner: IR, argIndex: number): IR;
        /**
         * @returns {IR}
         */
        toIR(): IR;
        #private;
    }
    /**
     * Switch case for a switch expression
     * @internal
     */
    export class SwitchCase extends Token {
        /**
         * @param {Site} site
         * @param {DestructExpr} lhs
         * @param {Expr} bodyExpr
         */
        constructor(site: Site, lhs: DestructExpr, bodyExpr: Expr);
        /**
         * @type {Expr}
         */
        get body(): Expr;
        /**
         * Used by parser to check if typeExpr reference the same base enum
         * @type {Word} - word representation of type
         */
        get memberName(): Word;
        isDataMember(): boolean;
        /**
         * @type {number}
         */
        get constrIndex(): number;
        /**
         * Evaluates the switch type and body value of a case.
         * @param {Scope} scope
         * @param {DataType} enumType
         * @returns {null | Multi | Typed}
         */
        evalEnumMember(scope: Scope, enumType: DataType): null | Multi | Typed;
        /**
         * Evaluates the switch type and body value of a case.
         * @param {Scope} scope
         * @returns {null | Typed | Multi}
         */
        evalDataMember(scope: Scope): null | Typed | Multi;
        /**
         * Accept an arg because will be called with the result of the controlexpr
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIR(ctx: ToIRContext): IR;
        #private;
    }
    /**
     * @internal
     */
    export class UnconstrDataSwitchCase extends SwitchCase {
        /**
         * @param {Site} site
         * @param {?Word} intVarName
         * @param {?Word} lstVarName
         * @param {Expr} bodyExpr
         */
        constructor(site: Site, intVarName: Word | null, lstVarName: Word | null, bodyExpr: Expr);
        /**
         * @param {Scope} scope
         * @param {Type} enumType
         * @returns {Instance}
         */
        evalEnumMember(scope: Scope, enumType: Type): Instance;
        #private;
    }
    /**
     * Default switch case
     * @internal
     */
    export class SwitchDefault extends Token {
        /**
         * @param {Site} site
         * @param {Expr} bodyExpr
         */
        constructor(site: Site, bodyExpr: Expr);
        /**
         * @param {Scope} scope
         * @returns {null | Typed | Multi}
         */
        eval(scope: Scope): null | Typed | Multi;
        /**
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIR(ctx: ToIRContext): IR;
        #private;
    }
    /**
     * Switch expression for Enum, with SwitchCases and SwitchDefault as children
     * @internal
     */
    export class EnumSwitchExpr extends SwitchExpr {
    }
    /**
     * Switch expression for Data
     * @internal
     */
    export class DataSwitchExpr extends SwitchExpr {
    }
    /**
     * Base class for all statements
     * Doesn't return a value upon calling eval(scope)
     * @internal
     */
    export class Statement extends Token {
        /**
         * @param {Site} site
         * @param {Word} name
         */
        constructor(site: Site, name: Word);
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @type {string}
         */
        get path(): string;
        /**
         * @param {ModuleScope} scope
         */
        eval(scope: ModuleScope): void;
        /**
         * @param {string} namespace
         * @param {(name: string, cs: ConstStatement) => void} callback
         */
        loopConstStatements(namespace: string, callback: (name: string, cs: ConstStatement) => void): void;
        /**
         * @param {string} basePath
         */
        setBasePath(basePath: string): void;
        /**
         * Returns IR of statement.
         * No need to specify indent here, because all statements are top-level
         * @param {ToIRContext} ctx
         * @param {IRDefinitions} map
         */
        toIR(ctx: ToIRContext, map: IRDefinitions): void;
        #private;
    }
    /**
     * Each field in `import {...} from <ModuleName>` is given a separate ImportFromStatement
     * @internal
     */
    export class ImportFromStatement extends Statement {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {Word} origName
         * @param {Word} moduleName
         */
        constructor(site: Site, name: Word, origName: Word, moduleName: Word);
        /**
         * @type {Word}
         */
        get moduleName(): Word;
        /**
         * @param {ModuleScope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: ModuleScope): null | EvalEntity;
        #private;
    }
    /**
     * `import <ModuleName>`
     * @internal
     */
    export class ImportModuleStatement extends Statement {
        /**
         * @type {Word}
         */
        get moduleName(): Word;
        /**
         * @param {ModuleScope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: ModuleScope): null | EvalEntity;
        #private;
    }
    /**
     * Const value statement
     * @internal
     */
    export class ConstStatement extends Statement {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {Expr} typeExpr - can be null in case of type inference
         * @param {null | Expr} valueExpr
         */
        constructor(site: Site, name: Word, typeExpr: Expr, valueExpr: null | Expr);
        /**
         * @type {DataType}
         */
        get type(): DataType;
        /**
         * @returns {boolean}
         */
        isSet(): boolean;
        /**
         * Use this to change a value of something that is already typechecked.
         * @param {UplcData} data
         */
        changeValueSafe(data: UplcData): void;
        /**
         * @param {Scope} scope
         * @returns {null | DataType}
         */
        evalType(scope: Scope): null | DataType;
        /**
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: Scope): null | EvalEntity;
        /**
         * Evaluates rhs and adds to scope
         * @param {TopScope} scope
         */
        eval(scope: TopScope): void;
        /**
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIRInternal(ctx: ToIRContext): IR;
        #private;
    }
    /**
     * @internal
     */
    export class TypeParameter {
        /**
         * @param {Word} name
         * @param {null | Expr} typeClassExpr
         */
        constructor(name: Word, typeClassExpr: null | Expr);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @type {TypeClass}
         */
        get typeClass(): TypeClass;
        /**
         * @param {Scope} scope
         * @param {string} path
         * @returns {null | Parameter}
         */
        eval(scope: Scope, path: string): null | Parameter;
        /**
         * @returns {string}
         */
        toString(): string;
        #private;
    }
    /**
     * @internal
     */
    export class TypeParameters {
        /**
         * @param {TypeParameter[]} parameterExprs
         * @param {boolean} isForFunc
         */
        constructor(parameterExprs: TypeParameter[], isForFunc: boolean);
        /**
         * @returns {boolean}
         */
        hasParameters(): boolean;
        /**
         * @type {string[]}
         */
        get parameterNames(): string[];
        /**
         * @returns {Parameter[]}
         */
        getParameters(): Parameter[];
        /**
         * Always include the braces, even if there aren't any type parameters, so that the mutual recursion injection function has an easier time figuring out what can depend on what
         * @param {string} base
         * @returns {string}
         */
        genTypePath(base: string): string;
        /**
         * Always include the braces, even if there aren't any type parameters, so that the mutual recursion injection function has an easier time figuring out what can depend on what
         * @param {string} base
         * @returns {string}
         */
        genFuncPath(base: string): string;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @param {Scope} scope
         * @returns {Scope}
         */
        evalParams(scope: Scope): Scope;
        /**
         * @param {Scope} scope
         * @param {(scope: Scope) => (null | FuncType)} evalConcrete
         * @returns {null | ParametricFunc | FuncType}
         */
        evalParametricFuncType(scope: Scope, evalConcrete: (scope: Scope) => (null | FuncType), impl?: null): null | ParametricFunc | FuncType;
        /**
         * @param {Scope} scope
         * @param {(scope: Scope) => (null | FuncType)} evalConcrete
         * @returns {null | EvalEntity}
         */
        evalParametricFunc(scope: Scope, evalConcrete: (scope: Scope) => (null | FuncType)): null | EvalEntity;
        /**
         * @param {Scope} scope
         * @param {Site} site
         * @param {(scope: Scope) => DataType} evalConcrete
         * @returns {[DataType | ParametricType, Scope]}
         */
        createParametricType(scope: Scope, site: Site, evalConcrete: (scope: Scope) => DataType): [DataType | ParametricType, Scope];
        #private;
    }
    /**
     * Single field in struct or enum member
     * @internal
     */
    export class DataField extends NameTypePair {
        /**
         * @param {Word} name
         * @param {Expr} typeExpr
         * @param {null | StringLiteral} tag
         */
        constructor(name: Word, typeExpr: Expr, tag?: null | StringLiteral);
        /**
         * Throws an error if called before evalType()
         * @type {DataType}
         */
        get type(): DataType;
        /**
         * @returns {boolean}
         */
        hasTag(): boolean;
        /**
         * @type {string}
         */
        get tag(): string;
        /**
         * Evaluates the type, used by FuncLiteralExpr and DataDefinition
         * @param {Scope} scope
         * @returns {null | DataType}
         */
        eval(scope: Scope): null | DataType;
        #private;
    }
    /**
     * Base class for struct and enum member
     * @internal
     */
    export class DataDefinition {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {DataField[]} fields
         */
        constructor(site: Site, name: Word, fields: DataField[]);
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @type {DataField[]}
         */
        get fields(): DataField[];
        hasTags(): boolean;
        /**
         * Returns index of a field.
         * Returns -1 if not found.
         * @param {Word} name
         * @returns {number}
         */
        findField(name: Word): number;
        /**
         * @type {string[]}
         */
        get fieldNames(): string[];
        /**
         * @param {Word} name
         * @returns {boolean}
         */
        hasField(name: Word): boolean;
        /**
         * @param {Word} name
         * @returns {boolean}
         */
        hasMember(name: Word): boolean;
        /**
         * @returns {string}
         */
        toStringFields(): string;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @param {Scope} scope
         * @returns {InstanceMembers}
         */
        evalFieldTypes(scope: Scope): InstanceMembers;
        /**
         * @param {Type} self
         * @returns {Type}
         */
        genCopyType(self: Type): Type;
        /**
         * @type {number}
         */
        get nFields(): number;
        /**
         * @param {number} i
         * @returns {DataType}
         */
        getFieldType(i: number): DataType;
        /**
         * @param {string} name
         * @returns {number}
         */
        getFieldIndex(name: string): number;
        /**
         * @param {number} i
         * @returns {string}
         */
        getFieldName(i: number): string;
        /**
         * Gets insance member value.
         * @param {Type} self
         * @returns {InstanceMembers}
         */
        genInstanceMembers(self: Type): InstanceMembers;
        /**
         * @param {Type} self
         * @returns {TypeMembers}
         */
        genTypeMembers(self: Type): TypeMembers;
        /**
         * @returns {[string, string, NamedTypeSchema[]]}
         */
        genTypeDetails(): [string, string, NamedTypeSchema[]];
        /**
         * @param {any} obj
         * @param {JsToUplcHelpers} helpers
         * @return {Promise<UplcData[]>}
         */
        jsFieldsToUplc(obj: any, helpers: JsToUplcHelpers): Promise<UplcData[]>;
        /**
         * Uses field names as keys, not tags
         * @param {any} obj
         * @param {JsToUplcHelpers} helpers
         * @return {Promise<[UplcData, UplcData][]>}
         */
        jsMapToUplc(obj: any, helpers: JsToUplcHelpers): Promise<[UplcData, UplcData][]>;
        /**
         * @param {UplcData[]} fields
         * @param {UplcToJsHelpers} helpers
         * @returns {Promise<any>}
         */
        uplcFieldsToJs(fields: UplcData[], helpers: UplcToJsHelpers): Promise<any>;
        /**
         * For Cip68-tagged structs
         * @param {[UplcData, UplcData][]} fields
         * @param {UplcToJsHelpers} helpers
         * @returns {Promise<any>}
         */
        uplcMapToJs(fields: [UplcData, UplcData][], helpers: UplcToJsHelpers): Promise<any>;
        /**
         * @param {ToIRContext} ctx
         * @param {string} path
         * @param {IRDefinitions} map
         * @param {number} constrIndex
         */
        newToIR(ctx: ToIRContext, path: string, map: IRDefinitions, constrIndex: number): void;
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @param {string} path
         * @param {IRDefinitions} map
         * @param {string[]} getterNames
         * @param {number} constrIndex
         */
        copyToIR(ctx: ToIRContext, path: string, map: IRDefinitions, getterNames: string[], constrIndex?: number): void;
        /**
         * @internal
         * @returns {IR}
         */
        fromDataFieldsCheckToIR(): IR;
        /**
         * Doesn't return anything, but sets its IRdef in the map
         * @param {ToIRContext} ctx
         * @param {string} path
         * @param {IRDefinitions} map
         * @param {number} constrIndex
         */
        toIR(ctx: ToIRContext, path: string, map: IRDefinitions, constrIndex: number): void;
        #private;
    }
    /**
     * Struct statement
     * @internal
     */
    export class StructStatement extends Statement {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {TypeParameters} parameters
         * @param {DataField[]} fields
         * @param {ImplDefinition} impl
         */
        constructor(site: Site, name: Word, parameters: TypeParameters, fields: DataField[], impl: ImplDefinition);
        /**
         * @returns {HeliosDataClass<HeliosData>}
         */
        genOffChainType(): HeliosDataClass<HeliosData>;
        /**
         * Evaluates own type and adds to scope
         * @param {TopScope} scope
         */
        eval(scope: TopScope): void;
        #private;
    }
    /**
     * Function statement
     * (basically just a named FuncLiteralExpr)
     * @internal
     */
    export class FuncStatement extends Statement {
        /**
         * @param {Statement} s
         * @returns {boolean}
         */
        static isMethod(s: Statement): boolean;
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {TypeParameters} parameters
         * @param {FuncLiteralExpr} funcExpr
         */
        constructor(site: Site, name: Word, parameters: TypeParameters, funcExpr: FuncLiteralExpr);
        /**
         * @type {number}
         */
        get nArgs(): number;
        /**
         * @type {string[]}
         */
        get argNames(): string[];
        /**
         * @type {Type[]}
         */
        get argTypes(): Type[];
        /**
         * @type {string[]}
         */
        get argTypeNames(): string[];
        /**
         * @type {Type[]}
         */
        get retTypes(): Type[];
        /**
         * @type {Site}
         */
        get retSite(): Site;
        /**
         * Evaluates a function and returns a func value
         * @param {Scope} scope
         * @returns {null | EvalEntity}
         */
        evalInternal(scope: Scope): null | EvalEntity;
        /**
         * Evaluates type of a funtion.
         * Separate from evalInternal so we can use this function recursively inside evalInternal
         * @param {Scope} scope
         * @returns {null | ParametricFunc | FuncType}
         */
        evalType(scope: Scope): null | ParametricFunc | FuncType;
        /**
         * Returns IR of function
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIRInternal(ctx: ToIRContext): IR;
        #private;
    }
    /**
     * EnumMember defintion is similar to a struct definition
     * @internal
     */
    export class EnumMember {
        /**
         * @param {Word} name
         * @param {DataField[]} fields
         */
        constructor(name: Word, fields: DataField[]);
        /**
         * @returns {number}
         */
        get constrIndex(): number;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @param {EnumStatement} parent
         * @param {number} i
        */
        registerParent(parent: EnumStatement, i: number): void;
        /**
         * @type {EnumStatement}
         */
        get parent(): EnumStatement;
        /**
         * @returns {HeliosDataClass<HeliosData>}
         */
        genOffChainType(): HeliosDataClass<HeliosData>;
        /**
         * @type {DataDefinition}
         */
        get dataDefinition(): DataDefinition;
        /**
         * @param {Scope} scope
         */
        evalDataFields(scope: Scope): void;
        /**
         * @param {Scope} scope
         * @returns {(parent: DataType) => EnumMemberType}
         */
        evalType(scope: Scope): (parent: DataType) => EnumMemberType;
        get path(): string;
        /**
         * @param {ToIRContext} ctx
         * @param {IRDefinitions} map
         */
        toIR(ctx: ToIRContext, map: IRDefinitions): void;
        #private;
    }
    /**
     * Enum statement, containing at least one member
     * @internal
     */
    export class EnumStatement extends Statement {
        /**
         * @param {Site} site
         * @param {Word} name
         * @param {TypeParameters} parameters
         * @param {EnumMember[]} members
         * @param {ImplDefinition} impl
         */
        constructor(site: Site, name: Word, parameters: TypeParameters, members: EnumMember[], impl: ImplDefinition);
        /**
         * @returns {boolean}
         */
        hasParameters(): boolean;
        /**
         * @internal
         * @returns {HeliosDataClass<HeliosData>}
         */
        genOffChainType(): HeliosDataClass<HeliosData>;
        /**
         * Returns index of enum member.
         * Returns -1 if not found
         * @param {Word} name
         * @returns {number}
         */
        findEnumMember(name: Word): number;
        /**
         * @param {number} i
         * @returns {EnumMember}
         */
        getEnumMember(i: number): EnumMember;
        /**
         * @param {Word} name
         * @returns {boolean}
         */
        hasEnumMember(name: Word): boolean;
        /**
         * @returns {number}
         */
        get nEnumMembers(): number;
        #private;
    }
    /**
     * Impl statements, which add functions and constants to registry of user types (Struct, Enum Member and Enums)
     * @internal
     */
    export class ImplDefinition {
        /**
         * @param {Expr} selfTypeExpr;
         * @param {(FuncStatement | ConstStatement)[]} statements
         */
        constructor(selfTypeExpr: Expr, statements: (FuncStatement | ConstStatement)[]);
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @param {string} basePath
         */
        setBasePath(basePath: string): void;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @param {Scope} scope
         * @returns {TypeMembers}
         */
        genTypeMembers(scope: Scope): TypeMembers;
        /**
         * Doesn't add the common types
         * @param {Scope} scope
         * @returns {InstanceMembers}
         */
        genInstanceMembers(scope: Scope): InstanceMembers;
        /**
         * @param {Scope} scope
         */
        eval(scope: Scope): void;
        /**
         * @param {string} namespace
         * @param {(name: string, cs: ConstStatement) => void} callback
         */
        loopConstStatements(namespace: string, callback: (name: string, cs: ConstStatement) => void): void;
        /**
         * Returns IR of all impl members
         * @param {ToIRContext} ctx
         * @param {IRDefinitions} map
         */
        toIR(ctx: ToIRContext, map: IRDefinitions): void;
        #private;
    }
    /**
     * Scope for IR names.
     * Works like a stack of named values from which a Debruijn index can be derived
     * @internal
     */
    export class IRScope {
        /**
         * Checks if a named builtin exists
         * @param {string} name
         * @param {boolean} strict - if true then throws an error if builtin doesn't exist
         * @returns {boolean}
         */
        static isBuiltin(name: string, strict?: boolean): boolean;
        /**
         * Returns index of a named builtin
         * Throws an error if builtin doesn't exist
         * @param {string} name
         * @returns {number}
         */
        static findBuiltin(name: string): number;
        /**
         * @param {null | IRScope} parent
         * @param {null | IRVariable} variable
         */
        constructor(parent: null | IRScope, variable: null | IRVariable);
        /**
         * Calculates the Debruijn index of a named value. Internal method
         * @param {Word | IRVariable} name
         * @param {number} index
         * @returns {[number, IRVariable]}
         */
        getInternal(name: Word | IRVariable, index: number): [number, IRVariable];
        /**
         * Calculates the Debruijn index.
         * @param {Word | IRVariable} name
         * @returns {[number, IRVariable]}
         */
        get(name: Word | IRVariable): [number, IRVariable];
        #private;
    }
    /**
     * IR class that represents function arguments
     * @internal
     */
    export class IRVariable extends Token {
        /**
         * @param {Word} name
         */
        constructor(name: Word);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @param {Map<IRVariable, IRVariable>} newVars
         * @returns {IRVariable}
         */
        copy(newVars: Map<IRVariable, IRVariable>): IRVariable;
        /**
         * @returns {boolean}
         */
        isAlwaysInlineable(): boolean;
        #private;
    }
    /**
     * @internal
     */
    export class IRValue {
        /**
         * @param {IRValue[]} args
         * @returns {?IRValue}
         */
        call(args: IRValue[]): IRValue | null;
        /**
         * @type {null | UplcValue}
         */
        get value(): UplcValue | null;
    }
    /**
     * @internal
     */
    export class IRFuncValue extends IRValue {
        /**
         * @param {(args: IRValue[]) => ?IRValue} callback
         */
        constructor(callback: (args: IRValue[]) => IRValue | null);
        #private;
    }
    /**
     * @internal
     */
    export class IRLiteralValue extends IRValue {
        /**
         * @param {UplcValue} value
         */
        constructor(value: UplcValue);
        /**
         * @type {UplcValue}
         */
        get value(): UplcValue;
        #private;
    }
    /**
     * @internal
     */
    export class IRDeferredValue extends IRValue {
        /**
         * @param {() => ?IRValue} deferred
         */
        constructor(deferred: () => IRValue | null);
        #private;
    }
    /**
     * @internal
     */
    export class IRCallStack {
        /**
         * @param {boolean} throwRTErrors
         * @param {?IRCallStack} parent
         * @param {?IRVariable} variable
         * @param {?IRValue} value
         */
        constructor(throwRTErrors: boolean, parent?: IRCallStack | null, variable?: IRVariable | null, value?: IRValue | null);
        get throwRTErrors(): boolean;
        /**
         * @param {IRVariable} variable
         * @returns {?IRValue}
         */
        get(variable: IRVariable): IRValue | null;
        /**
         * @param {IRVariable} variable
         * @param {IRValue} value
         * @returns {IRCallStack}
         */
        set(variable: IRVariable, value: IRValue): IRCallStack;
        /**
         * @returns {string[]}
         */
        dump(): string[];
        #private;
    }
    /**
     * @internal
     * @typedef {Map<IRVariable, IRLiteralExpr>} IRLiteralRegistry
     */
    /**
     * A map from variables to variable references
     * Scope-based
     * @internal
     */
    export class IRNameExprRegistry {
        /**
         * @param {Map<IRVariable, Set<IRNameExpr>>} map
         */
        constructor(map?: Map<IRVariable, Set<IRNameExpr>>, maybeInsideLoop?: Set<any>);
        /**
         * @param {IRNameExpr} nameExpr
         */
        register(nameExpr: IRNameExpr): void;
        /**
         * Used to prevent inlining upon recursion
         * @param {IRVariable} variable
         */
        registerVariable(variable: IRVariable): void;
        /**
         * @param {IRVariable} variable
         * @returns {number}
         */
        countReferences(variable: IRVariable): number;
        /**
         * @param {IRVariable} variable
         * @returns {boolean}
         */
        maybeInsideLoop(variable: IRVariable): boolean;
        /**
         * Called whenever recursion is detected
         * @returns {IRNameExprRegistry}
         */
        resetVariables(): IRNameExprRegistry;
        #private;
    }
    /**
     * @internal
     */
    export class IRExprRegistry {
        /**
         * @param {IRNameExprRegistry} nameExprs
         */
        constructor(nameExprs: IRNameExprRegistry);
        /**
         * @param {IRVariable} variable
         * @returns {number}
         */
        countReferences(variable: IRVariable): number;
        /**
         * @param {IRVariable} variable
         * @returns {boolean}
         */
        maybeInsideLoop(variable: IRVariable): boolean;
        /**
         * @param {IRVariable} variable
         * @returns {boolean}
         */
        isInlineable(variable: IRVariable): boolean;
        /**
         * @param {IRVariable} variable
         * @returns {IRExpr}
         */
        getInlineable(variable: IRVariable): IRExpr;
        /**
         * @param {IRVariable} variable
         * @param {IRExpr} expr
         */
        addInlineable(variable: IRVariable, expr: IRExpr): void;
        #private;
    }
    /**
     * Base class of all Intermediate Representation expressions
     * @internal
     */
    export class IRExpr extends Token {
        /**
         * For pretty printing the IR
         * @param {string} indent
         * @returns {string}
         */
        toString(indent?: string): string;
        /**
         * Link IRNameExprs to variables
         * @param {IRScope} scope
         */
        resolveNames(scope: IRScope): void;
        /**
         * Turns all IRConstExpr instances into IRLiteralExpr instances
         * @param {IRCallStack} stack
         * @returns {IRExpr}
         */
        evalConstants(stack: IRCallStack): IRExpr;
        /**
         * Evaluates an expression to something (hopefully) literal
         * Returns null if it the result would be worse than the current expression
         * Doesn't return an IRLiteral because the resulting expression might still be an improvement, even if it isn't a literal
         * @param {IRCallStack} stack
         * @returns {null | IRValue}
         */
        eval(stack: IRCallStack): null | IRValue;
        /**
         * Used to inline literals and to evaluate IRCoreCallExpr instances with only literal args.
         * @param {IRLiteralRegistry} literals
         * @returns {IRExpr}
         */
        simplifyLiterals(literals: IRLiteralRegistry): IRExpr;
        /**
         * Used before simplifyTopology
         * @param {IRNameExprRegistry} nameExprs
         */
        registerNameExprs(nameExprs: IRNameExprRegistry): void;
        /**
         * Used during inlining/expansion to make sure multiple inlines of IRNameExpr don't interfere when setting the Debruijn index
         * @param {Map<IRVariable, IRVariable>} newVars
         * @returns {IRExpr}
         */
        copy(newVars: Map<IRVariable, IRVariable>): IRExpr;
        /**
         * @param {IRExprRegistry} registry
         * @returns {IRExpr}
         */
        simplifyTopology(registry: IRExprRegistry): IRExpr;
        /**
         * @param {IRVariable} fnVar
         * @param {number[]} remaining
         * @returns {IRExpr}
         */
        simplifyUnusedRecursionArgs(fnVar: IRVariable, remaining: number[]): IRExpr;
        /**
         * @returns {UplcTerm}
         */
        toUplc(): UplcTerm;
    }
    /**
     * Intermediate Representation variable reference expression
     * @internal
     */
    export class IRNameExpr extends IRExpr {
        /**
         * @param {Word} name
         * @param {?IRVariable} variable
         * @param {?IRValue} value
         */
        constructor(name: Word, variable?: IRVariable | null, value?: IRValue | null);
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * isVariable() should be used to check if a IRNameExpr.variable is equal to a IRVariable (includes special handling of "__core*")
         * @type {IRVariable}
         */
        get variable(): IRVariable;
        /**
         * @internal
         * @returns {boolean}
         */
        isCore(): boolean;
        /**
         * @param {IRVariable} ref
         * @returns {boolean}
         */
        isVariable(ref: IRVariable): boolean;
        /**
         * @param {IRVariable} fnVar
         * @param {number[]} remaining
         * @returns {IRExpr}
         */
        removeUnusedCallArgs(fnVar: IRVariable, remaining: number[]): IRExpr;
        #private;
    }
    /**
     * IR wrapper for UplcValues, representing literals
     * @internal
     */
    export class IRLiteralExpr extends IRExpr {
        /**
         * @param {UplcValue} value
         */
        constructor(value: UplcValue);
        /**
         * @type {UplcValue}
         */
        get value(): UplcValue;
        /**
         * @param {IRCallStack} stack
         */
        evalConstants(stack: IRCallStack): IRLiteralExpr;
        /**
         * @param {IRVariable} fnVar
         * @param {number[]} remaining
         * @returns {IRExpr}
         */
        removeUnusedCallArgs(fnVar: IRVariable, remaining: number[]): IRExpr;
        /**
         * @returns {UplcConst}
         */
        toUplc(): UplcConst;
        #private;
    }
    /**
     * The IRExpr simplify methods aren't implemented because any IRConstExpr instances should've been eliminated during evalConstants.
     * @internal
     */
    export class IRConstExpr extends IRExpr {
        /**
         * @param {Site} site
         * @param {IRExpr} expr
         */
        constructor(site: Site, expr: IRExpr);
        /**
         * @param {IRVariable} fnVar
         * @param {number[]} remaining
         */
        simplifyUnusedRecursionArgs(fnVar: IRVariable, remaining: number[]): IRConstExpr;
        #private;
    }
    /**
     * IR function expression with some args, that act as the header, and a body expression
     * @internal
     */
    export class IRFuncExpr extends IRExpr {
        /**
         * @param {Site} site
         * @param {IRVariable[]} args
         * @param {IRExpr} body
         */
        constructor(site: Site, args: IRVariable[], body: IRExpr);
        get args(): IRVariable[];
        get body(): IRExpr;
        /**
         * @returns {boolean}
         */
        hasOptArgs(): boolean;
        /**
         * @param {IRCallStack} stack
         */
        evalConstants(stack: IRCallStack): IRFuncExpr;
        #private;
    }
    /**
     * Base class of IRUserCallExpr and IRCoreCallExpr
     * @internal
     */
    export class IRCallExpr extends IRExpr {
        /**
         * @param {Site} site
         * @param {IRExpr[]} argExprs
         * @param {Site} parensSite
         */
        constructor(site: Site, argExprs: IRExpr[], parensSite: Site);
        get argExprs(): IRExpr[];
        get parensSite(): Site;
        /**
         * @param {string} indent
         * @returns {string}
         */
        argsToString(indent?: string): string;
        /**
         * @param {IRScope} scope
         */
        resolveNamesInArgs(scope: IRScope): void;
        /**
         * @param {IRCallStack} stack
         * @returns {IRExpr[]}
         */
        evalConstantsInArgs(stack: IRCallStack): IRExpr[];
        /**
         * @param {IRCallStack} stack
         * @returns {?IRValue[]}
         */
        evalArgs(stack: IRCallStack): IRValue[] | null;
        /**
         * @param {IRLiteralRegistry} literals
         * @returns {IRExpr[]}
         */
        simplifyLiteralsInArgs(literals: IRLiteralRegistry): IRExpr[];
        /**
         * @param {IRNameExprRegistry} nameExprs
         */
        registerNameExprsInArgs(nameExprs: IRNameExprRegistry): void;
        /**
         * @param {IRExprRegistry} registry
         * @returns {IRExpr[]}
         */
        simplifyTopologyInArgs(registry: IRExprRegistry): IRExpr[];
        /**
         * @param {UplcTerm} term
         * @returns {UplcTerm}
         */
        toUplcCall(term: UplcTerm): UplcTerm;
        #private;
    }
    /**
     * IR function call of core functions
     * @internal
     */
    export class IRCoreCallExpr extends IRCallExpr {
        /**
         * @param {Site} site
         * @param {boolean} throwRTErrors
         * @param {string} builtinName
         * @param {IRValue[]} args
         * @returns {?IRValue}
         */
        static evalValues(site: Site, throwRTErrors: boolean, builtinName: string, args: IRValue[]): IRValue | null;
        /**
         * @param {Site} site
         * @param {string} name - full name of builtin, including prefix
         * @returns {UplcTerm}
         */
        static newUplcBuiltin(site: Site, name: string): UplcTerm;
        /**
         * @param {Word} name
         * @param {IRExpr[]} argExprs
         * @param {Site} parensSite
         */
        constructor(name: Word, argExprs: IRExpr[], parensSite: Site);
        get builtinName(): string;
        /**
         * @returns {boolean}
         */
        isCast(): boolean;
        /**
         * @param {IRVariable} fnVar
         * @param {number[]} remaining
         */
        simplifyUnusedRecursionArgs(fnVar: IRVariable, remaining: number[]): IRCoreCallExpr;
        #private;
    }
    /**
     * IR function call of non-core function
     * @internal
     */
    export class IRUserCallExpr extends IRCallExpr {
        /**
         * Handles upgrade to more complicated IRExpr types
         * @param {IRExpr} fnExpr
         * @param {IRExpr[]} argExprs
         * @param {Site} parensSite
         * @returns {IRNestedAnonCallExpr | IRAnonCallExpr | IRFuncDefExpr | IRUserCallExpr}
         */
        static new(fnExpr: IRExpr, argExprs: IRExpr[], parensSite: Site): IRNestedAnonCallExpr | IRAnonCallExpr | IRFuncDefExpr | IRUserCallExpr;
        /**
         * @param {IRExpr} fnExpr
         * @param {IRExpr[]} argExprs
         * @param {Site} parensSite
         */
        constructor(fnExpr: IRExpr, argExprs: IRExpr[], parensSite: Site);
        /**
         * @readonly
         * @type {IRExpr}
         */
        readonly fnExpr: IRExpr;
        /**
         * @param {IRLiteralRegistry} literals
         * @returns {(IRExpr[] | IRLiteralExpr)}
         */
        simplifyLiteralsInArgsAndTryEval(literals: IRLiteralRegistry): (IRExpr[] | IRLiteralExpr);
    }
    /**
     * @internal
     */
    export class IRAnonCallExpr extends IRUserCallExpr {
        /**
         * Handles upgrade to IRFuncDefExpr, which is very important to avoid inlining expensive expressions into potentially recursive scopes
         * @param {IRFuncExpr} fnExpr
         * @param {IRExpr[]} argExprs
         * @param {Site} parensSite
         * @returns {IRAnonCallExpr | IRFuncDefExpr}
         */
        static new(fnExpr: IRFuncExpr, argExprs: IRExpr[], parensSite: Site): IRAnonCallExpr | IRFuncDefExpr;
        /**
         * @param {IRFuncExpr} fnExpr
         * @param {IRExpr[]} argExprs
         * @param {Site} parensSite
         */
        constructor(fnExpr: IRFuncExpr, argExprs: IRExpr[], parensSite: Site);
        /**
         * Internal function
         * @type {IRFuncExpr}
         */
        get anon(): IRFuncExpr;
        /**
         * @type {IRVariable[]}
         */
        get argVariables(): IRVariable[];
        /**
         * Add args to the stack as IRDeferredValue instances
         * @param {IRCallStack} stack
         */
        evalConstants(stack: IRCallStack): any;
        #private;
    }
    /**
     * @internal
     */
    export class IRNestedAnonCallExpr extends IRUserCallExpr {
        /**
         * @param {IRAnonCallExpr} anon
         * @param {IRExpr[]} outerArgExprs
         * @param {Site} parensSite
         */
        constructor(anon: IRAnonCallExpr, outerArgExprs: IRExpr[], parensSite: Site);
        #private;
    }
    /**
     * @internal
     */
    export class IRFuncDefExpr extends IRAnonCallExpr {
        /**
         * @param {IRFuncExpr} anon
         * @param {IRFuncExpr} defExpr
         * @param {Site} parensSite
         */
        constructor(anon: IRFuncExpr, defExpr: IRFuncExpr, parensSite: Site);
        /**
         * @param {IRExprRegistry} registry
         * @returns {[IRFuncExpr, IRExpr]}
         */
        simplifyRecursionArgs(registry: IRExprRegistry): [IRFuncExpr, IRExpr];
        #private;
    }
    /**
     * Intermediate Representation error call (with optional literal error message)
     * @internal
     */
    export class IRErrorCallExpr extends IRExpr {
        /**
         * @param {Site} site
         * @param {string} msg
         */
        constructor(site: Site, msg?: string);
        #private;
    }
    /**
     * Wrapper for IRFuncExpr, IRCallExpr or IRLiteralExpr
     * @internal
     */
    export class IRProgram {
        /**
         * @param {IRExpr} expr
         * @returns {IRFuncExpr | IRCallExpr | IRLiteralExpr}
         */
        static assertValidRoot(expr: IRExpr): IRFuncExpr | IRCallExpr | IRLiteralExpr;
        /**
         * @internal
         * @param {IR} ir
         * @param {null | ScriptPurpose} purpose
         * @param {boolean} simplify
         * @param {IRScope} scope
         * @returns {IRProgram}
         */
        static new(ir: IR, purpose: null | ScriptPurpose, simplify?: boolean, scope?: IRScope): IRProgram;
        /**
         * @param {IRExpr} expr
         * @returns {IRExpr}
         */
        static simplify(expr: IRExpr): IRExpr;
        /**
         * @param {IRExpr} expr
         * @returns {IRExpr}
         */
        static simplifyLiterals(expr: IRExpr): IRExpr;
        /**
         * @param {IRExpr} expr
         * @returns {IRExpr}
         */
        static simplifyTopology(expr: IRExpr): IRExpr;
        /**
         * @param {IRFuncExpr | IRCallExpr | IRLiteralExpr} expr
         * @param {ProgramProperties} properties
         */
        constructor(expr: IRFuncExpr | IRCallExpr | IRLiteralExpr, properties: ProgramProperties);
        /**
         * @internal
         * @type {IRFuncExpr | IRCallExpr | IRLiteralExpr}
         */
        get expr(): IRLiteralExpr | IRCallExpr | IRFuncExpr;
        /**
         * @internal
         * @type {ProgramProperties}
         */
        get properties(): ProgramProperties;
        /**
         * @internal
         * @type {Site}
         */
        get site(): Site;
        /**
         * @type {UplcData}
         */
        get data(): UplcData;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @returns {UplcProgram}
         */
        toUplc(): UplcProgram;
        /**
         * @returns {number}
         */
        calcSize(): number;
        #private;
    }
    /**
     * @internal
     */
    export class IRParametricProgram {
        /**
         * @internal
         * @param {IR} ir
         * @param {null | ScriptPurpose} purpose
         * @param {number} nParams
         * @param {boolean} simplify
         * @returns {IRParametricProgram}
         */
        static new(ir: IR, purpose: null | ScriptPurpose, nParams: number, simplify?: boolean): IRParametricProgram;
        /**
         * @param {IRProgram} irProgram
         * @param {number} nParams
         */
        constructor(irProgram: IRProgram, nParams: number);
        /**
         * @type {IRProgram}
         */
        get program(): IRProgram;
        /**
         * @returns {UplcProgram}
         */
        toUplc(): UplcProgram;
        #private;
    }
    /**
     * Helios root object
     */
    export class Program {
        /**
         * @internal
         * @param {string} rawSrc
         * @returns {[purpose, Module[]]}
         */
        static parseMainInternal(rawSrc: string): [ScriptPurpose | null, Module[]];
        /**
         * @internal
         * @param {string} mainName
         * @param {string[]} moduleSrcs
         * @returns {Module[]}
         */
        static parseImports(mainName: string, moduleSrcs?: string[]): Module[];
        /**
         * @internal
         * @param {string} mainSrc
         * @param {string[]} moduleSrcs
         * @returns {[null | ScriptPurpose, Module[]]}
         */
        static parseMain(mainSrc: string, moduleSrcs: string[]): [null | ScriptPurpose, Module[]];
        /**
         * Creates  a new program.
         * @param {string} mainSrc
         * @param {string[]} moduleSrcs - optional sources of modules, which can be used for imports
         * @param {ProgramConfig} config
         * @returns {Program}
         */
        static new(mainSrc: string, moduleSrcs?: string[], validatorTypes?: {}, config?: ProgramConfig): Program;
        /**
         * Creates  a new program.
         * @internal
         * @param {string} mainSrc
         * @param {string[]} moduleSrcs - optional sources of modules, which can be used for imports
         * @param {{[name: string]: Type}} validatorTypes
         * @param {ProgramConfig} config
         * @returns {Program}
         */
        static newInternal(mainSrc: string, moduleSrcs?: string[], validatorTypes?: {
            [name: string]: Type;
        }, config?: ProgramConfig): Program;
        /**
         * For top-level statements
         * @internal
         * @param {IR} mainIR
         * @param {IRDefinitions} map
         * @returns {IR}
         */
        static injectMutualRecursions(mainIR: IR, map: IRDefinitions): IR;
        /**
         * Also merges builtins and map
         * @internal
         * @param {ToIRContext} ctx
         * @param {IR} mainIR
         * @param {IRDefinitions} map
         * @returns {IRDefinitions}
         */
        static applyTypeParameters(ctx: ToIRContext, mainIR: IR, map: IRDefinitions): IRDefinitions;
        /**
         * @internal
         * @param {ScriptPurpose} purpose
         * @param {Module[]} modules
         * @param {ProgramConfig} config
         */
        constructor(purpose: ScriptPurpose, modules: Module[], config: ProgramConfig);
        /**
         * @internal
         */
        throwErrors(): void;
        /**
         * @type {ProgramConfig}
         */
        get config(): ProgramConfig;
        /**
         * @internal
         * @type {number}
         */
        get nPosParams(): number;
        /**
         * @internal
         * @type {Type[]}
         */
        get posParams(): Type[];
        /**
         * @internal
         * @type {Module[]}
         */
        get mainImportedModules(): Module[];
        /**
         * @internal
         * @type {MainModule}
         */
        get mainModule(): MainModule;
        /**
         * @internal
         * @type {null | Module}
         */
        get postModule(): Module | null;
        /**
         * @type {ScriptPurpose}
         */
        get purpose(): ScriptPurpose;
        /**
         * @type {string}
         */
        get name(): string;
        /**
         * @internal
         * @type {FuncStatement}
         */
        get mainFunc(): FuncStatement;
        /**
         * @internal
         * @type {Site}
         */
        get mainRetExprSite(): Site;
        /**
         * @internal
         * @type {string[]}
         */
        get mainArgNames(): string[];
        /**
         * @internal
         * @type {DataType[]}
         */
        get mainArgTypes(): DataType[];
        /**
         * @internal
         * @type {string}
         */
        get mainPath(): string;
        /**
         * @internal
         * @type {Statement[]}
         */
        get mainStatements(): Statement[];
        /**
         * Needed to list the paramTypes, and to call changeParam
         * @internal
         * @type {Statement[]}
         */
        get mainAndPostStatements(): Statement[];
        /**
         * @internal
         * @type {[Statement, boolean][]} - boolean value marks if statement is import or not
         */
        get allStatements(): [Statement, boolean][];
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @internal
         * @param {GlobalScope} globalScope
         * @returns {TopScope}
         */
        evalTypesInternal(globalScope: GlobalScope): TopScope;
        /**
         * @internal
         * @param {{[name: string]: Type}} validatorTypes
         * @returns {TopScope}
         */
        evalTypes(validatorTypes?: {
            [name: string]: Type;
        }): TopScope;
        /**
         * @type {UserTypes}
         */
        get types(): UserTypes;
        /**
         * Fill #types with convenient javascript equivalents of Int, ByteArray etc.
         * @internal
         * @param {TopScope} topScope
         */
        fillTypes(topScope: TopScope): void;
        /**
         * @internal
         * @param {(name: string, cs: ConstStatement) => void} callback
         */
        loopConstStatements(callback: (name: string, cs: ConstStatement) => void): void;
        /**
         * @internal
         * @type {{[name: string]: DataType}}
         */
        get paramTypes(): {
            [name: string]: DataType;
        };
        /**
         * Change the literal value of a const statements
         * @internal
         * @param {string} name
         * @param {UplcData} data
         */
        changeParamSafe(name: string, data: UplcData): void;
        /**
         * @internal
         * @param {string} name
         * @returns {ConstStatement | null}
         */
        findConstStatement(name: string): ConstStatement | null;
        /**
         * @internal
         * @param {ConstStatement} constStatement
         * @returns {UplcValue}
         */
        evalConst(constStatement: ConstStatement): UplcValue;
        /**
         * Doesn't use wrapEntryPoint
         * @param {string} name - can be namespace: "Type::ConstName" or "Module::ConstName" or "Module::Type::ConstName"
         * @returns {UplcValue}
         */
        evalParam(name: string): UplcValue;
        /**
         * Use proxy for setting
         * @param {{[name: string]: HeliosData | any}} values
         */
        set parameters(arg: {
            [name: string]: any;
        });
        /**
         * Alternative way to get the parameters as HeliosData instances
         * @returns {{[name: string]: HeliosData | any}}
         */
        get parameters(): {
            [name: string]: any;
        };
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @param {(s: Statement, isImport: boolean) => boolean} endCond
         * @returns {IRDefinitions}
         */
        statementsToIR(ctx: ToIRContext, endCond: (s: Statement, isImport: boolean) => boolean): IRDefinitions;
        /**
         * @internal
         * @param {IR} ir
         * @param {IRDefinitions} definitions
         * @returns {Set<string>}
         */
        collectAllUsed(ir: IR, definitions: IRDefinitions): Set<string>;
        /**
         * @internal
         * @param {IR} ir
         * @param {IRDefinitions} definitions
         * @returns {IRDefinitions}
         */
        eliminateUnused(ir: IR, definitions: IRDefinitions): IRDefinitions;
        /**
         * Loops over all statements, until endCond == true (includes the matches statement)
         * Then applies type parameters
         * @internal
         * @param {ToIRContext} ctx
         * @param {IR} ir
         * @param {(s: Statement) => boolean} endCond
         * @returns {IRDefinitions}
         */
        fetchDefinitions(ctx: ToIRContext, ir: IR, endCond: (s: Statement) => boolean): IRDefinitions;
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @param {IR} ir
         * @param {IRDefinitions} definitions
         * @returns {IR}
         */
        wrapInner(ctx: ToIRContext, ir: IR, definitions: IRDefinitions): IR;
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @param {IR} ir
         * @param {null | IRDefinitions} extra
         * @returns {IR}
         */
        wrapEntryPoint(ctx: ToIRContext, ir: IR, extra?: null | IRDefinitions): IR;
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        toIRInternal(ctx: ToIRContext): IR;
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @param {null | IRDefinitions} extra
         * @returns {IR}
         */
        toIR(ctx: ToIRContext, extra?: null | IRDefinitions): IR;
        /**
         * Non-positional named parameters
         * @internal
         * @type {[string, Type][]}
         */
        get requiredParameters(): [string, Type][];
        /**
         * @returns {string}
         */
        prettyIR(simplify?: boolean): string;
        /**
         * @param {boolean} simplify
         * @returns {UplcProgram}
         */
        compile(simplify?: boolean): UplcProgram;
        #private;
    }
    /**
     * Used by CLI
     * @internal
     */
    export class DatumRedeemerProgram extends Program {
        /**
         * @type {DataType}
         */
        get datumType(): DataType;
        /**
         * @type {string}
         */
        get datumTypeName(): string;
        /**
         * @internal
         * @param {ScriptTypes} scriptTypes
         * @returns {TopScope}
         */
        evalTypes(scriptTypes: ScriptTypes): TopScope;
        /**
         * @internal
         * @param {ToIRContext} ctx
         * @returns {IR}
         */
        datumCheckToIR(ctx: ToIRContext): IR;
        /**
         * Used by cli
         * @internal
         * @returns {UplcProgram}
         */
        compileDatumCheck(): UplcProgram;
    }
    /**
     * @internal
     */
    export class NativeContext {
        /**
         *
         * @param {bigint | null} firstValidSlot
         * @param {bigint | null} lastValidSlot
         * @param {PubKeyHash[]} keys
         */
        constructor(firstValidSlot: bigint | null, lastValidSlot: bigint | null, keys: PubKeyHash[]);
        /**
         * Used by NativeAfter
         * @param {bigint} slot
         * @returns {boolean}
         */
        isAfter(slot: bigint): boolean;
        /**
         *
         * @param {bigint} slot
         * @returns {boolean}
         */
        isBefore(slot: bigint): boolean;
        /**
         *
         * @param {PubKeyHash} key
         * @returns {boolean}
         */
        isSignedBy(key: PubKeyHash): boolean;
        #private;
    }
    /**
     * Helios supports Cardano [native scripts](https://cips.cardano.org/cips/cip29/).
     * See `Tx.attachScript()` for how `NativeScript` can be used when building a transaction.
     *
     * NativeScript allows creating basic multi-signature and time-based validators.
     * This is a legacy technology, but can be cheaper than using Plutus.
     */
    export class NativeScript extends CborData {
        /**
         * @param {string | number[]} raw
         * @returns {NativeScript}
         */
        static fromCbor(raw: string | number[]): NativeScript;
        /**
         * @param {string | Object} json
         * @returns {NativeScript}
         */
        static fromJson(json: string | any): NativeScript;
        /**
         * @param {number} type
         */
        constructor(type: number);
        /**
         * @returns {number[]}
         */
        typeToCbor(): number[];
        /**
         * @returns {Object}
         */
        toJson(): any;
        /**
         * @internal
         * @param {NativeContext} context
         * @returns {boolean}
         */
        eval(context: NativeContext): boolean;
        /**
         * Calculates the blake2b-224 (28 bytes) hash of the NativeScript.
         *
         * **Note**: a 0 byte is prepended before to the serialized CBOR representation, before calculating the hash.
         * @returns {number[]}
         */
        hash(): number[];
        /**
         * A `NativeScript` can be used both as a Validator and as a MintingPolicy
         * @type {ValidatorHash}
         */
        get validatorHash(): ValidatorHash;
        /**
         * A `NativeScript` can be used both as a Validator and as a MintingPolicy
         * @type {MintingPolicyHash}
         */
        get mintingPolicyHash(): MintingPolicyHash;
        #private;
    }
    /**
     * Represents a Cardano transaction. Can also be used as a transaction builder.
     */
    export class Tx extends CborData {
        /**
         * Create a new Tx builder.
         * @returns {Tx}
         */
        static new(): Tx;
        /**
         * Deserialize a CBOR encoded Cardano transaction (input is either an array of bytes, or a hex string).
         * @param {number[] | string} raw
         * @returns {Tx}
         */
        static fromCbor(raw: number[] | string): Tx;
        /**
         * Used by bundler for macro finalization
         * @param {UplcData} data
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @param {TxInput[]} spareUtxos
         * @param {{[name: string]: (UplcProgram | (() => UplcProgram))}} scripts UplcPrograms can be lazy
         * @returns {Promise<Tx>}
         */
        static finalizeUplcData(data: UplcData, networkParams: NetworkParams, changeAddress: Address, spareUtxos: TxInput[], scripts: {
            [name: string]: UplcProgram | (() => UplcProgram);
        }): Promise<Tx>;
        /**
         * Use `Tx.new()` instead of this constructor for creating a new Tx builder.
         * @param {TxBody} body
         * @param {TxWitnesses} witnesses
         * @param {boolean} valid
         * @param {null | TxMetadata} metadata
         * @param {null | bigint | Date} validTo
         * @param {null | bigint | Date} validFrom
         */
        constructor(body?: TxBody, witnesses?: TxWitnesses, valid?: boolean, metadata?: null | TxMetadata, validTo?: null | bigint | Date, validFrom?: null | bigint | Date);
        /**
         * @type {TxBody}
         */
        get body(): TxBody;
        /**
         * @type {number[]}
         */
        get bodyHash(): number[];
        /**
         * @type {TxWitnesses}
         */
        get witnesses(): TxWitnesses;
        /**
         * Used by emulator to check if tx is valid.
         * @param {bigint} slot
         * @returns {boolean}
         */
        isValid(slot: bigint): boolean;
        /**
         * Creates a new Tx without the metadata for client-side signing where the client can't know the metadata before tx-submission.
         * @returns {Tx}
         */
        withoutMetadata(): Tx;
        /**
         * @param {NetworkParams} networkParams
         * @returns {UplcData}
         */
        toTxData(networkParams: NetworkParams): UplcData;
        /**
         * A serialized tx throws away input information
         * This must be refetched from the network if the tx needs to be analyzed
         * @param {(id: TxOutputId) => Promise<TxOutput>} fn
         */
        completeInputData(fn: (id: TxOutputId) => Promise<TxOutput>): Promise<void>;
        /**
         * @param {null | NetworkParams} params If specified: dump all the runtime details of each redeemer (datum, redeemer, scriptContext)
         * @returns {Object}
         */
        dump(params?: null | NetworkParams): any;
        /**
         * Set the start of the valid time range by specifying either a Date or a slot.
         *
         * Mutates the transaction.
         * Only available during building the transaction.
         * Returns the transaction instance so build methods can be chained.
         *
         * > **Note**: since Helios v0.13.29 this is set automatically if any of the Helios validator scripts call `tx.time_range`.
         * @param {bigint | Date } slotOrTime
         * @returns {Tx}
         */
        validFrom(slotOrTime: bigint | Date): Tx;
        /**
         * Set the end of the valid time range by specifying either a Date or a slot.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         *
         * > **Note**: since Helios v0.13.29 this is set automatically if any of the Helios validator scripts call `tx.time_range`.
         * @param {bigint | Date } slotOrTime
         * @returns {Tx}
         */
        validTo(slotOrTime: bigint | Date): Tx;
        /**
         * Mint a list of tokens associated with a given `MintingPolicyHash`.
         * Throws an error if the given `MintingPolicyHash` was already used in a previous call to `mintTokens()`.
         * The token names can either by a list of bytes or a hexadecimal string.
         *
         * Mutates the transaction.
         * Only available during transaction building the transaction.
         * Returns the transaction instance so build methods can be chained.
         *
         * Also throws an error if the redeemer is `null`, and the minting policy isn't a known `NativeScript`.
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph
         * @param {[ByteArray | ByteArrayProps, HInt | HIntProps][]} tokens - list of pairs of [tokenName, quantity], tokenName can be list of bytes or hex-string
         * @param {UplcDataValue | UplcData | null} redeemer
         * @returns {Tx}
         */
        mintTokens(mph: MintingPolicyHash | MintingPolicyHashProps, tokens: [ByteArray | ByteArrayProps, HInt | HIntProps][], redeemer: UplcDataValue | UplcData | null): Tx;
        /**
         * Add a UTxO instance as an input to the transaction being built.
         * Throws an error if the UTxO is locked at a script address but a redeemer isn't specified (unless the script is a known `NativeScript`).
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {TxInput} input
         * @param {null | UplcDataValue | UplcData | HeliosData} rawRedeemer
         * @returns {Tx}
         */
        addInput(input: TxInput, rawRedeemer?: null | UplcDataValue | UplcData | HeliosData): Tx;
        /**
         * Add multiple UTxO instances as inputs to the transaction being built.
         * Throws an error if the UTxOs are locked at a script address but a redeemer isn't specified (unless the script is a known `NativeScript`).
         *
         * Mutates the transaction.
         * Only available during transaction building. Returns the transaction instance so build methods can be chained.
         * @param {TxInput[]} inputs
         * @param {?(UplcDataValue | UplcData | HeliosData)} redeemer
         * @returns {Tx}
         */
        addInputs(inputs: TxInput[], redeemer?: (UplcDataValue | UplcData | HeliosData) | null): Tx;
        /**
         * Add a `TxInput` instance as a reference input to the transaction being built.
         * Any associated reference script, as a `UplcProgram` instance, must also be included in the transaction at this point (so the that the execution budget can be calculated correctly).
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {TxInput} input
         * @param {null | UplcProgram} refScript
         * @returns {Tx}
         */
        addRefInput(input: TxInput, refScript?: null | UplcProgram): Tx;
        /**
         * Add multiple `TxInput` instances as reference inputs to the transaction being built.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {TxInput[]} inputs
         * @returns {Tx}
         */
        addRefInputs(inputs: TxInput[]): Tx;
        /**
         * Add a `TxOutput` instance to the transaction being built.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {TxOutput} output
         * @returns {Tx}
         */
        addOutput(output: TxOutput): Tx;
        /**
         * Add multiple `TxOutput` instances at once.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {TxOutput[]} outputs
         * @returns {Tx}
         */
        addOutputs(outputs: TxOutput[]): Tx;
        /**
         * Add a signatory `PubKeyHash` to the transaction being built.
         * The added entry becomes available in the `tx.signatories` field in the Helios script.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {PubKeyHash} hash
         * @returns {Tx}
         */
        addSigner(hash: PubKeyHash): Tx;
        /**
         * Add a `DCert` to the transactions being built. `DCert` contains information about a staking-related action.
         *
         * TODO: implement all DCert (de)serialization methods.
         *
         * Returns the transaction instance so build methods can be chained.
         * @internal
         * @param {DCert} dcert
         */
        addDCert(dcert: DCert): Tx;
        /**
         * Attaches a script witness to the transaction being built.
         * The script witness can be either a `UplcProgram` or a legacy `NativeScript`.
         * A `UplcProgram` instance can be created by compiling a Helios `Program`.
         * A legacy `NativeScript` instance can be created by deserializing its original CBOR representation.
         *
         * Throws an error if script has already been added.
         * Throws an error if the script isn't used upon finalization.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         *
         * > **Note**: a `NativeScript` must be attached before associated inputs are added or tokens are minted.
         * @param {UplcProgram | NativeScript} program
         * @returns {Tx}
         */
        attachScript(program: UplcProgram | NativeScript): Tx;
        /**
         * Add a UTxO instance as collateral to the transaction being built.
         * Usually adding only one collateral input is enough.
         * The number of collateral inputs must be greater than 0 if script witnesses are used in the transaction,
         * and must be less than the limit defined in the `NetworkParams`.
         *
         * Mutates the transaction.
         * Only available during transaction building.
         * Returns the transaction instance so build methods can be chained.
         * @param {TxInput} input
         * @returns {Tx}
         */
        addCollateral(input: TxInput): Tx;
        /**
         * Calculates tx fee (including script execution)
         * Shouldn't be used directly
         * @internal
         * @param {NetworkParams} networkParams
         * @returns {bigint}
         */
        estimateFee(networkParams: NetworkParams): bigint;
        /**
         * Iterates until fee is exact
         * Shouldn't be used directly
         * @internal
         * @param {NetworkParams} networkParams
         * @param {bigint} fee
         * @returns {bigint}
         */
        setFee(networkParams: NetworkParams, fee: bigint): bigint;
        /**
         * Checks that all necessary scripts are included, and that all included scripts are used
         * Shouldn't be used directly
         * @internal
         */
        checkScripts(): void;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @returns {Promise<void>}
         */
        executeRedeemers(networkParams: NetworkParams, changeAddress: Address): Promise<void>;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @returns {Promise<void>}
         */
        checkExecutionBudgets(networkParams: NetworkParams): Promise<void>;
        /**
         * @internal
         * @param {Address} changeAddress
         */
        balanceAssets(changeAddress: Address): void;
        /**
         * Calculate the base fee which will be multiplied by the required min collateral percentage
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @param {TxInput[]} spareUtxos
         */
        estimateCollateralBaseFee(networkParams: NetworkParams, changeAddress: Address, spareUtxos: TxInput[]): bigint;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @param {TxInput[]} spareUtxos
         */
        balanceCollateral(networkParams: NetworkParams, changeAddress: Address, spareUtxos: TxInput[]): void;
        /**
         * Calculates fee and balances transaction by sending an output back to changeAddress
         * First assumes that change output isn't needed, and if that assumption doesn't result in a balanced transaction the change output is created.
         * Iteratively increments the fee because the fee increase the tx size which in turn increases the fee (always converges within two steps though).
         * Throws error if transaction can't be balanced.
         * Shouldn't be used directly
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Address} changeAddress
         * @param {TxInput[]} spareUtxos - used when there are yet enough inputs to cover everything (eg. due to min output lovelace requirements, or fees)
         * @returns {TxOutput} - changeOutput so the fee can be mutated furthers
         */
        balanceLovelace(networkParams: NetworkParams, changeAddress: Address, spareUtxos: TxInput[]): TxOutput;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxOutput} changeOutput
         */
        correctChangeOutput(networkParams: NetworkParams, changeOutput: TxOutput): void;
        /**
         * @internal
         */
        checkBalanced(): void;
        /**
         * Shouldn't be used directly
         * @internal
         * @param {NetworkParams} networkParams
         */
        syncScriptDataHash(networkParams: NetworkParams): void;
        /**
         * @internal
         * @returns {boolean}
         */
        isSmart(): boolean;
        /**
         * Throws an error if there isn't enough collateral
         * Also throws an error if the script doesn't require collateral, but collateral was actually included
         * Shouldn't be used directly
         * @internal
         * @param {NetworkParams} networkParams
         */
        checkCollateral(networkParams: NetworkParams): void;
        /**
         * Throws error if tx is too big
         * Shouldn't be used directly
         * @internal
         * @param {NetworkParams} networkParams
         */
        checkSize(networkParams: NetworkParams): void;
        /**
         * Final check that fee is big enough
         * @internal
         * @param {NetworkParams} networkParams
         */
        checkFee(networkParams: NetworkParams): void;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         */
        finalizeValidityTimeRange(networkParams: NetworkParams): void;
        /**
         * Executes all the attached scripts with appropriate redeemers and calculates execution budgets.
         * Balances the transaction, and optionally uses some spare UTxOs if the current inputs don't contain enough lovelace to cover the fees and min output deposits.
         *
         * Inputs, minted assets, and withdrawals are sorted.
         *
         * Sets the validatity range automatically if a call to `tx.time_range` is detected in any of the attached Helios scripts.
         * @param {NetworkParams} networkParams
         * @param {Address}       changeAddress
         * @param {TxInput[]}        spareUtxos - might be used during balancing if there currently aren't enough inputs
         * @returns {Promise<Tx>}
         */
        finalize(networkParams: NetworkParams, changeAddress: Address, spareUtxos?: TxInput[]): Promise<Tx>;
        /**
         * @type {string}
         */
        get profileReport(): string;
        /**
         * Adds a signature created by a wallet. Only available after the transaction has been finalized.
         * Optionally verifies that the signature is correct.
         * @param {Signature} signature
         * @param {boolean} verify Defaults to `true`
         * @returns {Tx}
         */
        addSignature(signature: Signature, verify?: boolean): Tx;
        /**
         * Adds multiple signatures at once. Only available after the transaction has been finalized.
         * Optionally verifies each signature is correct.
         * @param {Signature[]} signatures
         * @param {boolean} verify
         * @returns {Tx}
         */
        addSignatures(signatures: Signature[], verify?: boolean): Tx;
        /**
         * Add metadata to a transaction.
         * Metadata can be used to store data on-chain,
         * but can't be consumed by validator scripts.
         * Metadata can for example be used for [CIP 25](https://cips.cardano.org/cips/cip25/).
         * @param {number} tag
         * @param {Metadata} data
         * @returns {Tx}
         */
        addMetadata(tag: number, data: Metadata): Tx;
        /**
         * @returns {TxId}
         */
        id(): TxId;
        #private;
    }
    /**
     * inputs, minted assets, and withdrawals need to be sorted in order to form a valid transaction
     */
    export class TxBody extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {TxBody}
         */
        static fromCbor(bytes: number[]): TxBody;
        /**
         * @type {TxInput[]}
         */
        get inputs(): TxInput[];
        /**
         * @type {TxInput[]}
         */
        get refInputs(): TxInput[];
        /**
         * @type {TxOutput[]}
         */
        get outputs(): TxOutput[];
        /**
         * @type {bigint}
         */
        get fee(): bigint;
        /**
         * @internal
         * @param {bigint} fee
         */
        setFee(fee: bigint): void;
        /**
         * @type {Assets}
         */
        get minted(): Assets;
        /**
         * @type {TxInput[]}
         */
        get collateral(): TxInput[];
        /**
         * @type {bigint | null}
         */
        get firstValidSlot(): bigint | null;
        /**
         * @type {bigint | null}
         */
        get lastValidSlot(): bigint | null;
        /**
         * @type {PubKeyHash[]}
         */
        get signers(): PubKeyHash[];
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * For now simply returns minus infinity to plus infinity (WiP)
         * @internal
         * @param {NetworkParams} networkParams
         * @returns {ConstrData}
         */
        toValidTimeRangeData(networkParams: NetworkParams): ConstrData;
        /**
         * A serialized tx throws away input information
         * This must be refetched from the network if the tx needs to be analyzed
         * @internal
         * @param {(id: TxOutputId) => Promise<TxOutput>} fn
         * @param {TxWitnesses} witnesses
         */
        completeInputData(fn: (id: TxOutputId) => Promise<TxOutput>, witnesses: TxWitnesses): Promise<void>;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Redeemer[]} redeemers
         * @param {ListData} datums
         * @param {TxId} txId
         * @returns {ConstrData}
         */
        toTxData(networkParams: NetworkParams, redeemers: Redeemer[], datums: ListData, txId: TxId): ConstrData;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {Redeemer[]} redeemers
         * @param {ListData} datums
         * @param {number} redeemerIdx
         * @param {TxId} txId
         * @returns {UplcData}
         */
        toScriptContextData(networkParams: NetworkParams, redeemers: Redeemer[], datums: ListData, redeemerIdx: number, txId?: TxId): UplcData;
        /**
         * @returns {Value}
         */
        sumInputValue(): Value;
        /**
         * Throws error if any part of the sum is negative (i.e. more is burned than input)
         * @returns {Value}
         */
        sumInputAndMintedValue(): Value;
        /**
         * @returns {Assets}
         */
        sumInputAndMintedAssets(): Assets;
        /**
         * @returns {Value}
         */
        sumOutputValue(): Value;
        /**
         * @returns {Assets}
         */
        sumOutputAssets(): Assets;
        /**
         * @internal
         * @param {bigint} slot
         */
        validFrom(slot: bigint): void;
        /**
         * @internal
         * @param {bigint} slot
         */
        validTo(slot: bigint): void;
        /**
         * Throws error if this.#minted already contains mph
         * @internal
         * @param {MintingPolicyHash | MintingPolicyHashProps} mph - minting policy hash
         * @param {[ByteArray | ByteArrayProps, HInt | HIntProps][]} tokens
         */
        addMint(mph: MintingPolicyHash | MintingPolicyHashProps, tokens: [ByteArray | ByteArrayProps, HInt | HIntProps][]): void;
        /**
         * @internal
         * @param {TxInput} input
         * @param {boolean} checkUniqueness
         */
        addInput(input: TxInput, checkUniqueness?: boolean): void;
        /**
         * Used to remove dummy inputs
         * Dummy inputs are needed to be able to correctly estimate fees
         * Throws an error if input doesn't exist in list of inputs
         * @internal
         * @param {TxInput} input
         */
        removeInput(input: TxInput): void;
        /**
         * @internal
         * @param {TxInput} input
         * @param {boolean} checkUniqueness
         */
        addRefInput(input: TxInput, checkUniqueness?: boolean): void;
        /**
         * @internal
         * @param {TxOutput} output
         */
        addOutput(output: TxOutput): void;
        /**
         * Used to remove dummy outputs
         * Dummy outputs are needed to be able to correctly estimate fees
         * Throws an error if the output doesn't exist in list of outputs
         * @internal
         * @param {TxOutput} output
         */
        removeOutput(output: TxOutput): void;
        /**
         * @internal
         * @param {PubKeyHash} hash
         * @param {boolean} checkUniqueness
         */
        addSigner(hash: PubKeyHash, checkUniqueness?: boolean): void;
        /**
         * @internal
         * @param {DCert} dcert
         */
        addDCert(dcert: DCert): void;
        /**
         * @internal
         * @param {TxInput} input
         */
        addCollateral(input: TxInput): void;
        /**
         * @internal
         * @param {Hash | null} scriptDataHash
         */
        setScriptDataHash(scriptDataHash: Hash | null): void;
        /**
         * @internal
         * @param {Hash} metadataHash
         */
        setMetadataHash(metadataHash: Hash): void;
        /**
         * @internal
         * @param {TxOutput | null} output
         */
        setCollateralReturn(output: TxOutput | null): void;
        /**
         * Calculates the number of dummy signatures needed to get precisely the right tx size.
         * @internal
         * @returns {number}
         */
        countUniqueSigners(): number;
        /**
         * Script hashes are found in addresses of TxInputs and hashes of the minted MultiAsset.
         * @internal
         * @param {Map<string, number>} set - hashes in hex format
         */
        collectScriptHashes(set: Map<string, number>): void;
        /**
         * Makes sure each output contains the necessary min lovelace.
         * @internal
         * @param {NetworkParams} networkParams
         */
        correctOutputs(networkParams: NetworkParams): void;
        /**
         * Checks that each output contains enough lovelace
         * @internal
         * @param {NetworkParams} networkParams
         */
        checkOutputs(networkParams: NetworkParams): void;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {null | bigint} minCollateral
         */
        checkCollateral(networkParams: NetworkParams, minCollateral: null | bigint): void;
        /**
         * Makes sore inputs, withdrawals, and minted assets are in correct order, this is needed for the redeemer indices
         * Mutates
         * @internal
         */
        sortInputs(): void;
        /**
         * Not done in the same routine as sortInputs(), because balancing of assets happens after redeemer indices are set
         * @internal
         */
        sortOutputs(): void;
        /**
         * Used by (indirectly) by emulator to check if slot range is valid.
         * Note: firstValidSlot == lastValidSlot is allowed
         * @internal
         * @param {bigint} slot
         */
        isValid(slot: bigint): boolean;
        /**
         * @internal
         * @returns {number[]}
         */
        hash(): number[];
        #private;
    }
    /**
     * Represents the pubkey signatures, and datums/redeemers/scripts that are witnessing a transaction.
     */
    export class TxWitnesses extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {TxWitnesses}
         */
        static fromCbor(bytes: number[]): TxWitnesses;
        /**
         * Gets the list of `Signature` instances contained in this witness set.
         * @type {Signature[]}
         */
        get signatures(): Signature[];
        /**
         * Returns all the scripts, including the reference scripts
         * @type {(UplcProgram | NativeScript)[]}
         */
        get scripts(): (UplcProgram | NativeScript)[];
        /**
         * @type {Redeemer[]}
         */
        get redeemers(): Redeemer[];
        /**
         * @type {ListData}
         */
        get datums(): ListData;
        /**
         * @param {ValidatorHash | MintingPolicyHash} h
         * @returns {boolean}
         */
        isNativeScript(h: ValidatorHash | MintingPolicyHash): boolean;
        /**
         * @internal
         * @returns {boolean}
         */
        anyScriptCallsTxTimeRange(): boolean;
        /**
         * Throws error if signatures are incorrect
         * @internal
         * @param {number[]} bodyBytes
         */
        verifySignatures(bodyBytes: number[]): void;
        /**
         * @param {null | NetworkParams} params
         * @param {null | TxBody} body
         * @returns {Object}
         */
        dump(params?: null | NetworkParams, body?: null | TxBody): any;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @returns {bigint}
         */
        estimateFee(networkParams: NetworkParams): bigint;
        /**
         * @internal
         * @param {Signature} signature
         */
        addSignature(signature: Signature): void;
        /**
         * @internal
         * @param {number} n
         */
        addDummySignatures(n: number): void;
        /**
         * @internal
         */
        removeDummySignatures(): void;
        /**
         * Index is calculated later
         * @internal
         * @param {TxInput} input
         * @param {UplcData} redeemerData
         */
        addSpendingRedeemer(input: TxInput, redeemerData: UplcData): void;
        /**
         * @internal
         * @param {MintingPolicyHash} mph
         * @param {UplcData} redeemerData
         */
        addMintingRedeemer(mph: MintingPolicyHash, redeemerData: UplcData): void;
        /**
         * @internal
         * @param {UplcData} data
         */
        addDatumData(data: UplcData): void;
        /**
         * @internal
         * @param {NativeScript} script
         */
        attachNativeScript(script: NativeScript): void;
        /**
         * @internal
         * @param {UplcProgram} script
         */
        attachRefScript(script: UplcProgram): void;
        /**
         * Throws error if script was already added before.
         * @internal
         * @param {UplcProgram} program
         * @param {boolean} isRef
         */
        attachPlutusScript(program: UplcProgram, isRef?: boolean): void;
        /**
         * Retrieves either a regular script or a reference script.
         * @internal
         * @param {Hash} scriptHash - can be ValidatorHash or MintingPolicyHash
         * @returns {UplcProgram}
         */
        getUplcProgram(scriptHash: Hash): UplcProgram;
        /**
         * @internal
         * @param {TxBody} body
         */
        updateRedeemerIndices(body: TxBody): void;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @returns {Hash | null} - returns null if there are no redeemers
         */
        calcScriptDataHash(networkParams: NetworkParams): Hash | null;
        /**
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxBody} body
         * @param {Redeemer} redeemer
         * @param {UplcData} scriptContext
         * @returns {Promise<Profile>}
         */
        executeRedeemer(networkParams: NetworkParams, body: TxBody, redeemer: Redeemer, scriptContext: UplcData): Promise<Profile>;
        /**
         * Executes the redeemers in order to calculate the necessary ex units
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxBody} body - needed in order to create correct ScriptContexts
         * @param {Address} changeAddress - needed for dummy input and dummy output
         * @returns {Promise<void>}
         */
        executeScripts(networkParams: NetworkParams, body: TxBody, changeAddress: Address): Promise<void>;
        /**
         * @internal
         * @param {TxBody} body
         */
        executeNativeScripts(body: TxBody): void;
        /**
         * Executes the redeemers in order to calculate the necessary ex units
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxBody} body - needed in order to create correct ScriptContexts
         * @param {Address} changeAddress - needed for dummy input and dummy output
         * @returns {Promise<void>}
         */
        executeRedeemers(networkParams: NetworkParams, body: TxBody, changeAddress: Address): Promise<void>;
        /**
         * Reruns all the redeemers to make sure the ex budgets are still correct (can change due to outputs added during rebalancing)
         * @internal
         * @param {NetworkParams} networkParams
         * @param {TxBody} body
         */
        checkExecutionBudgets(networkParams: NetworkParams, body: TxBody): Promise<void>;
        /**
         * Throws error if execution budget is exceeded
         * @internal
         * @param {NetworkParams} networkParams
         */
        checkExecutionBudgetLimits(networkParams: NetworkParams): void;
        /**
         * Compiles a report of each redeemer execution.
         * Only works after the tx has been finalized.
         * @type {string}
         */
        get profileReport(): string;
        #private;
    }
    /**
     * TxInput base-type
     */
    export class TxInput extends CborData {
        /**
         * @internal
         * @param {UplcData} data
         * @returns {TxInput}
         */
        static fromUplcData(data: UplcData): TxInput;
        /**
         * Deserializes TxOutput format used by wallet connector
         * @param {string | number[]} rawBytes
         * @returns {TxInput}
         */
        static fromFullCbor(rawBytes: string | number[]): TxInput;
        /**
         * @param {string | number[]} rawBytes
         * @returns {TxInput}
         */
        static fromCbor(rawBytes: string | number[]): TxInput;
        /**
         * Tx inputs must be ordered.
         * The following function can be used directly by a js array sort
         * @internal
         * @param {TxInput} a
         * @param {TxInput} b
         * @returns {number}
         */
        static comp(a: TxInput, b: TxInput): number;
        /**
         * @param {TxInput[]} inputs
         * @returns {Value}
         */
        static sumValue(inputs: TxInput[]): Value;
        /**
         * @param {TxOutputId} outputId
         * @param {null | TxOutput} output - used during building, not part of serialization
         */
        constructor(outputId: TxOutputId, output?: null | TxOutput);
        /**
         * @readonly
         * @type {TxOutputId}
         */
        readonly outputId: TxOutputId;
        /**
         * @deprecated
         * @type {TxId}
         */
        get txId(): TxId;
        /**
         * @deprecated
         * @type {number}
         */
        get utxoIdx(): number;
        /**
         *
         * @param {TxInput} other
         * @returns {boolean}
         */
        eq(other: TxInput): boolean;
        /**
         * @internal
         * @returns {boolean}
         */
        hasOrigOutput(): boolean;
        /**
         * @internal
         * @param {TxOutput} output
         */
        setOrigOutput(output: TxOutput): void;
        /**
         *
         * @type {TxOutput}
         */
        get output(): TxOutput;
        /**
         * Backward compatible alias for `TxInput.output`
         * @type {TxOutput}
         */
        get origOutput(): TxOutput;
        /**
         * Shortcut
         * @type {Value}
         */
        get value(): Value;
        /**
         * Shortcut
         * @type {Address}
         */
        get address(): Address;
        /**
         * @internal
         * @returns {ConstrData}
         */
        toOutputIdData(): ConstrData;
        /**
         * @internal
         * @returns {ConstrData}
         */
        toData(): ConstrData;
        /**
         * @returns {number[]}
         */
        toFullCbor(): number[];
        /**
         * @returns {Object}
         */
        dump(): any;
        #private;
    }
    /**
     * Use TxInput instead
     * @deprecated
     */
    export class UTxO extends TxInput {
    }
    /**
     * Use TxInput instead
     * @deprecated
     */
    export class TxRefInput extends TxInput {
    }
    /**
     * Represents a transaction output that is used when building a transaction.
     */
    export class TxOutput extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {TxOutput}
         */
        static fromCbor(bytes: number[]): TxOutput;
        /**
         * @param {UplcData} data
         * @returns {TxOutput}
         */
        static fromUplcData(data: UplcData): TxOutput;
        /**
         * Constructs a `TxOutput` instance using an `Address`, a `Value`, an optional `Datum`, and optional `UplcProgram` reference script.
         * @param {Address} address
         * @param {Value} value
         * @param {null | Datum} datum
         * @param {null | UplcProgram} refScript
         */
        constructor(address: Address, value: Value, datum?: null | Datum, refScript?: null | UplcProgram);
        /**
         * Get the `Address` to which the `TxOutput` will be sent.
         * @type {Address}
         */
        get address(): Address;
        /**
         * Mutation is handy when correctin the quantity of lovelace in a utxo
         * @param {Address} addr
         */
        setAddress(addr: Address): void;
        /**
         * Get the `Value` contained in the `TxOutput`.
         * @type {Value}
         */
        get value(): Value;
        /**
         * Mutation is handy when correcting the quantity of lovelace in a utxo
         * @param {Value} val
         */
        setValue(val: Value): void;
        /**
         * Get the optional `Datum` associated with the `TxOutput`.
         * @type {null | Datum}
         */
        get datum(): Datum | null;
        /**
         * Mutation is handy when correctin the quantity of lovelace in a utxo
         * @param {Datum} datum
         */
        setDatum(datum: Datum): void;
        /**
         * @returns {UplcData}
         */
        getDatumData(): UplcData;
        /**
         * @type {null | UplcProgram}
         */
        get refScript(): UplcProgram | null;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @returns {ConstrData}
         */
        toData(): ConstrData;
        /**
         * Each UTxO must contain some minimum quantity of lovelace to avoid that the blockchain is used for data storage.
         * @param {NetworkParams} networkParams
         * @returns {bigint}
         */
        calcMinLovelace(networkParams: NetworkParams): bigint;
        /**
         * Makes sure the `TxOutput` contains the minimum quantity of lovelace.
         * The network requires this to avoid the creation of unusable dust UTxOs.
         *
         * Optionally an update function can be specified that allows mutating the datum of the `TxOutput` to account for an increase of the lovelace quantity contained in the value.
         * @param {NetworkParams} networkParams
         * @param {null | ((output: TxOutput) => void)} updater
         */
        correctLovelace(networkParams: NetworkParams, updater?: ((output: TxOutput) => void) | null): void;
        #private;
    }
    /**
     * A `DCert` represents a staking action (eg. withdrawing rewards, delegating to another pool).
     * @internal
     */
    export class DCert extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {DCert}
         */
        static fromCbor(bytes: number[]): DCert;
        /**
         * @param {UplcData} data
         * @returns {DCert}
         */
        static fromUplcData(data: UplcData): DCert;
        /**
         * @returns {ConstrData}
         */
        toData(): ConstrData;
    }
    /**
     * @internal
     */
    export class DCertDelegate extends DCert {
    }
    /**
     * @internal
     */
    export class DCertDeregister extends DCert {
    }
    /**
     * @internal
     */
    export class DCertRegister extends DCert {
    }
    /**
     * @internal
     */
    export class DCertRegisterPool extends DCert {
    }
    /**
     * @internal
     */
    export class DCertRetire extends DCert {
    }
    /**
     * Wrapper for Cardano stake address bytes. An StakeAddress consists of two parts internally:
     *   - Header (1 byte, see CIP 8)
     *   - Staking witness hash (28 bytes that represent the `PubKeyHash` or `StakingValidatorHash`)
     *
     * Stake addresses are used to query the assets held by given staking credentials.
     */
    export class StakeAddress {
        /**
         * Returns `true` if the given `StakeAddress` is a testnet address.
         * @param {StakeAddress} sa
         * @returns {boolean}
         */
        static isForTestnet(sa: StakeAddress): boolean;
        /**
         * Convert a regular `Address` into a `StakeAddress`.
         * Throws an error if the Address doesn't have a staking credential.
         * @param {Address} addr
         * @returns {StakeAddress}
         */
        static fromAddress(addr: Address): StakeAddress;
        /**
         * @param {number[]} bytes
         * @returns {StakeAddress}
         */
        static fromCbor(bytes: number[]): StakeAddress;
        /**
         * @param {string} str
         * @returns {StakeAddress}
         */
        static fromBech32(str: string): StakeAddress;
        /**
         * Doesn't check validity
         * @param {string} hex
         * @returns {StakeAddress}
         */
        static fromHex(hex: string): StakeAddress;
        /**
         * Address with only staking part (regular PubKeyHash)
         * @internal
         * @param {boolean} isTestnet
         * @param {PubKeyHash} hash
         * @returns {StakeAddress}
         */
        static fromPubKeyHash(isTestnet: boolean, hash: PubKeyHash): StakeAddress;
        /**
         * Address with only staking part (script StakingValidatorHash)
         * @internal
         * @param {boolean} isTestnet
         * @param {StakingValidatorHash} hash
         * @returns {StakeAddress}
         */
        static fromStakingValidatorHash(isTestnet: boolean, hash: StakingValidatorHash): StakeAddress;
        /**
         * Converts a `PubKeyHash` or `StakingValidatorHash` into `StakeAddress`.
         * @param {boolean} isTestnet
         * @param {PubKeyHash | StakingValidatorHash} hash
         * @returns {StakeAddress}
         */
        static fromHash(isTestnet: boolean, hash: PubKeyHash | StakingValidatorHash): StakeAddress;
        /**
         * @param {number[]} bytes
         */
        constructor(bytes: number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * Converts a `StakeAddress` into its CBOR representation.
         * @returns {number[]}
         */
        toCbor(): number[];
        /**
         * Converts a `StakeAddress` into its Bech32 representation.
         * @returns {string}
         */
        toBech32(): string;
        /**
         * Converts a `StakeAddress` into its hexadecimal representation.
         * @returns {string}
         */
        toHex(): string;
        /**
         * Converts a `StakeAddress` into its hexadecimal representation.
         * @type {string}
         */
        get hex(): string;
        /**
         * Returns the underlying `PubKeyHash` or `StakingValidatorHash`.
         * @returns {PubKeyHash | StakingValidatorHash}
         */
        get stakingHash(): PubKeyHash | StakingValidatorHash;
        #private;
    }
    /**
     * Represents a Ed25519 signature.
     *
     * Also contains a reference to the PubKey that did the signing.
     */
    export class Signature extends CborData {
        /**
         * @returns {Signature}
         */
        static dummy(): Signature;
        /**
         * @param {number[]} bytes
         * @returns {Signature}
         */
        static fromCbor(bytes: number[]): Signature;
        /**
         * @param {number[] | PubKey} pubKey
         * @param {number[]} signature
         */
        constructor(pubKey: number[] | PubKey, signature: number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {PubKey}
         */
        get pubKey(): PubKey;
        /**
         * @type {PubKeyHash}
         */
        get pubKeyHash(): PubKeyHash;
        /**
         * @returns {boolean}
         */
        isDummy(): boolean;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * Throws error if incorrect
         * @param {number[]} msg
         */
        verify(msg: number[]): void;
        #private;
    }
    /**
     * @interface
     * @typedef {object} PrivateKey
     * @property {() => PubKey} derivePubKey Generates the corresponding public key.
     * @property {(msg: number[]) => Signature} sign Signs a byte-array payload, returning the signature.
     */
    /**
     * @implements {PrivateKey}
     */
    export class Ed25519PrivateKey extends HeliosData implements PrivateKey {
        /**
         * Generate a private key from a random number generator.
         * This is not cryptographically secure, only use this for testing purpose
         * @param {NumberGenerator} random
         * @returns {Ed25519PrivateKey} - Ed25519 private key is 32 bytes long
         */
        static random(random: NumberGenerator): Ed25519PrivateKey;
        /**
         * @param {string | number[]} bytes
         */
        constructor(bytes: string | number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {string}
         */
        get hex(): string;
        /**
         * NOT the Ed25519-Bip32 hierarchial extension algorithm (see ExtendedPrivateKey below)
         * @returns {Ed25519PrivateKey}
         */
        extend(): Ed25519PrivateKey;
        /**
         * @returns {PubKey}
         */
        derivePubKey(): PubKey;
        /**
         * @param {number[]} message
         * @returns {Signature}
         */
        sign(message: number[]): Signature;
        #private;
    }
    /**
     * Used during `Bip32PrivateKey` derivation, to create a new `Bip32PrivateKey` instance with a non-publicly deriveable `PubKey`.
     */
    export const BIP32_HARDEN: 2147483648;
    /**
     * Ed25519-Bip32 extendable `PrivateKey`.
     * @implements {PrivateKey}
     */
    export class Bip32PrivateKey implements PrivateKey {
        /**
         * Generate a Bip32PrivateKey from a random number generator.
         * This is not cryptographically secure, only use this for testing purpose
         * @param {NumberGenerator} random
         * @returns {Bip32PrivateKey}
         */
        static random(random?: NumberGenerator): Bip32PrivateKey;
        /**
         * @param {number[]} entropy
         * @param {boolean} force
         */
        static fromBip39Entropy(entropy: number[], force?: boolean): Bip32PrivateKey;
        /**
         * @param {number[]} bytes
         */
        constructor(bytes: number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @private
         * @type {number[]}
         */
        private get k();
        /**
         * @private
         * @type {number[]}
         */
        private get kl();
        /**
         * @private
         * @type {number[]}
         */
        private get kr();
        /**
         * @private
         * @type {number[]}
         */
        private get c();
        /**
         * @private
         * @param {number} i - child index
         */
        private calcChildZ;
        /**
         * @private
         * @param {number} i
         */
        private calcChildC;
        /**
         * @param {number} i
         * @returns {Bip32PrivateKey}
         */
        derive(i: number): Bip32PrivateKey;
        /**
         * @param {number[]} path
         * @returns {Bip32PrivateKey}
         */
        derivePath(path: number[]): Bip32PrivateKey;
        /**
         * @returns {PubKey}
         */
        derivePubKey(): PubKey;
        /**
         * @example
         * (new Bip32PrivateKey([0x60, 0xd3, 0x99, 0xda, 0x83, 0xef, 0x80, 0xd8, 0xd4, 0xf8, 0xd2, 0x23, 0x23, 0x9e, 0xfd, 0xc2, 0xb8, 0xfe, 0xf3, 0x87, 0xe1, 0xb5, 0x21, 0x91, 0x37, 0xff, 0xb4, 0xe8, 0xfb, 0xde, 0xa1, 0x5a, 0xdc, 0x93, 0x66, 0xb7, 0xd0, 0x03, 0xaf, 0x37, 0xc1, 0x13, 0x96, 0xde, 0x9a, 0x83, 0x73, 0x4e, 0x30, 0xe0, 0x5e, 0x85, 0x1e, 0xfa, 0x32, 0x74, 0x5c, 0x9c, 0xd7, 0xb4, 0x27, 0x12, 0xc8, 0x90, 0x60, 0x87, 0x63, 0x77, 0x0e, 0xdd, 0xf7, 0x72, 0x48, 0xab, 0x65, 0x29, 0x84, 0xb2, 0x1b, 0x84, 0x97, 0x60, 0xd1, 0xda, 0x74, 0xa6, 0xf5, 0xbd, 0x63, 0x3c, 0xe4, 0x1a, 0xdc, 0xee, 0xf0, 0x7a])).sign(textToBytes("Hello World")).bytes == [0x90, 0x19, 0x4d, 0x57, 0xcd, 0xe4, 0xfd, 0xad, 0xd0, 0x1e, 0xb7, 0xcf, 0x16, 0x17, 0x80, 0xc2, 0x77, 0xe1, 0x29, 0xfc, 0x71, 0x35, 0xb9, 0x77, 0x79, 0xa3, 0x26, 0x88, 0x37, 0xe4, 0xcd, 0x2e, 0x94, 0x44, 0xb9, 0xbb, 0x91, 0xc0, 0xe8, 0x4d, 0x23, 0xbb, 0xa8, 0x70, 0xdf, 0x3c, 0x4b, 0xda, 0x91, 0xa1, 0x10, 0xef, 0x73, 0x56, 0x38, 0xfa, 0x7a, 0x34, 0xea, 0x20, 0x46, 0xd4, 0xbe, 0x04]
         * @param {number[]} message
         * @returns {Signature}
         */
        sign(message: number[]): Signature;
        #private;
    }
    /**
     * @implements {PrivateKey}
     */
    export class RootPrivateKey implements PrivateKey {
        /**
         * @param {string[]} phrase
         * @param {string[]} dict
         * @returns {boolean}
         */
        static isValidPhrase(phrase: string[], dict?: string[]): boolean;
        /**
         * @param {string[]} phrase
         * @param {string[]} dict
         * @returns {RootPrivateKey}
         */
        static fromPhrase(phrase: string[], dict?: string[]): RootPrivateKey;
        /**
         * @param {number[]} entropy
         */
        constructor(entropy: number[]);
        /**
         * @type {number[]}
         */
        get bytes(): number[];
        /**
         * @type {number[]}
         */
        get entropy(): number[];
        /**
         * @param {string[]} dict
         * @returns {string[]}
         */
        toPhrase(dict?: string[]): string[];
        /**
         * @param {number} i - childIndex
         * @returns {Bip32PrivateKey}
         */
        derive(i: number): Bip32PrivateKey;
        /**
         * @param {number[]} path
         * @returns {Bip32PrivateKey}
         */
        derivePath(path: number[]): Bip32PrivateKey;
        /**
         * @param {number} accountIndex
         * @returns {Bip32PrivateKey}
         */
        deriveSpendingRootKey(accountIndex?: number): Bip32PrivateKey;
        /**
         * @param {number} accountIndex
         * @returns {Bip32PrivateKey}
         */
        deriveStakingRootKey(accountIndex: number): Bip32PrivateKey;
        /**
         * @param {number} accountIndex
         * @param {number} i
         * @returns {Bip32PrivateKey}
         */
        deriveSpendingKey(accountIndex?: number, i?: number): Bip32PrivateKey;
        /**
         * @param {number} accountIndex
         * @param {number} i
         * @returns {Bip32PrivateKey}
         */
        deriveStakingKey(accountIndex?: number, i?: number): Bip32PrivateKey;
        /**
         * @returns {PubKey}
         */
        derivePubKey(): PubKey;
        /**
         * @param {number[]} message
         * @returns {Signature}
         */
        sign(message: number[]): Signature;
        #private;
    }
    /**
     * Base-type of SpendingRedeemer and MintingRedeemer
     */
    export class Redeemer extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {Redeemer}
         */
        static fromCbor(bytes: number[]): Redeemer;
        /**
         * @param {UplcData} data
         * @param {Profile} profile
         */
        constructor(data: UplcData, profile?: Profile);
        /**
         * @type {UplcData}
         */
        get data(): UplcData;
        /**
         * @type {bigint}
         */
        get memCost(): bigint;
        /**
         * @type {bigint}
         */
        get cpuCost(): bigint;
        /**
         * @param {string} name
         */
        setProgramName(name: string): void;
        /**
         * @type {null | string}
         */
        get programName(): string | null;
        /**
         * type:
         *   0 -> spending
         *   1 -> minting
         *   2 -> certifying
         *   3 -> rewarding
         * @param {number} type
         * @param {number} index
         * @returns {number[]}
         */
        toCborInternal(type: number, index: number): number[];
        /**
         * @returns {Object}
         */
        dumpInternal(): any;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @param {TxBody} body
         * @returns {ConstrData}
         */
        toScriptPurposeData(body: TxBody): ConstrData;
        /**
         * @param {TxBody} body
         */
        updateIndex(body: TxBody): void;
        /**
         * @param {Profile} profile
         */
        setProfile(profile: Profile): void;
        /**
         * @type {Profile}
         */
        get profile(): Profile;
        /**
         * @param {NetworkParams} networkParams
         * @returns {bigint}
         */
        estimateFee(networkParams: NetworkParams): bigint;
        #private;
    }
    export class SpendingRedeemer extends Redeemer {
        /**
         * @param {null | TxInput} input
         * @param {number} inputIndex
         * @param {UplcData} data
         * @param {Cost} exUnits
         */
        constructor(input: null | TxInput, inputIndex: number, data: UplcData, exUnits?: Cost);
        /**
         * @type {number}
         */
        get inputIndex(): number;
        #private;
    }
    export class MintingRedeemer extends Redeemer {
        /**
         * @param {?MintingPolicyHash} mph
         * @param {number} mphIndex
         * @param {UplcData} data
         * @param {Cost} exUnits
         */
        constructor(mph: MintingPolicyHash | null, mphIndex: number, data: UplcData, exUnits?: Cost);
        /**
         * @type {number}
         */
        get mphIndex(): number;
        #private;
    }
    /**
     * Represents either an inline datum, or a hashed datum.
     *
     * Inside the Helios language this type is named `OutputDatum` in order to distinguish it from user defined Datums,
     * But outside helios scripts there isn't much sense to keep using the name 'OutputDatum' instead of Datum.
     */
    export class Datum extends CborData {
        /**
         * @param {number[]} bytes
         * @returns {Datum}
         */
        static fromCbor(bytes: number[]): Datum;
        /**
         * @param {UplcData} data
         * @returns {null | Datum}
         */
        static fromUplcData(data: UplcData): null | Datum;
        /**
         * Constructs a `HashedDatum`. The input data is hashed internally.
         * @param {UplcDataValue | UplcData | HeliosData} data
         * @returns {Datum}
         */
        static hashed(data: UplcDataValue | UplcData | HeliosData): Datum;
        /**
         * @param {UplcDataValue | UplcData | HeliosData} data
         * @returns {Datum}
         */
        static inline(data: UplcDataValue | UplcData | HeliosData): Datum;
        /**
         * @returns {boolean}
         */
        isInline(): boolean;
        /**
         * @returns {boolean}
         */
        isHashed(): boolean;
        /**
         * @type {DatumHash}
         */
        get hash(): DatumHash;
        /**
         * @type {?UplcData}
         */
        get data(): UplcData | null;
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @returns {ConstrData}
         */
        toData(): ConstrData;
    }
    /**
     * Inside helios this type is named OutputDatum::Hash in order to distinguish it from the user defined Datum,
     * but outside helios scripts there isn't much sense to keep using the name 'OutputDatum' instead of Datum
     */
    export class HashedDatum extends Datum {
        /**
         * Constructs a `HashedDatum`. The input data is hashed internally.
         * @param {UplcData} data
         * @returns {HashedDatum}
         */
        static fromData(data: UplcData): HashedDatum;
        /**
         * @param {DatumHash} hash
         * @param {null | UplcData} origData
         */
        constructor(hash: DatumHash, origData?: null | UplcData);
        #private;
    }
    export class TxMetadata {
        /**
        * Decodes a TxMetadata instance from Cbor
        * @param {number[]} data
        * @returns {TxMetadata}
        */
        static fromCbor(data: number[]): TxMetadata;
        /**
         *
         * @param {number} tag
         * @param {Metadata} data
         */
        add(tag: number, data: Metadata): void;
        /**
         * @type {number[]}
         */
        get keys(): number[];
        /**
         * @returns {Object}
         */
        dump(): any;
        /**
         * @returns {number[]}
         */
        toCbor(): number[];
        #private;
    }
    export namespace CoinSelection {
        function selectExtremumFirst(utxos: TxInput[], amount: Value, largestFirst: boolean): [TxInput[], TxInput[]];
        const selectSmallestFirst: CoinSelectionAlgorithm;
        const selectLargestFirst: CoinSelectionAlgorithm;
    }
    /**
     * An interface type for a wallet that manages a user's UTxOs and addresses.
     * @interface
     * @typedef {object} Wallet
    *  @property {() => Promise<boolean>} isMainnet Returns `true` if the wallet is connected to the mainnet.
    *  @property {Promise<Address[]>} usedAddresses Returns a list of addresses which already contain UTxOs.
    *  @property {Promise<Address[]>} unusedAddresses Returns a list of unique unused addresses which can be used to send UTxOs to with increased anonimity.
    *  @property {Promise<TxInput[]>} utxos Returns a list of all the utxos controlled by the wallet.
    *  @property {Promise<TxInput[]>} collateral
    *  @property {(tx: Tx) => Promise<Signature[]>} signTx Signs a transaction, returning a list of signatures needed for submitting a valid transaction.
    *  @property {(tx: Tx) => Promise<TxId>} submitTx Submits a transaction to the blockchain and returns the id of that transaction upon success.
    */
    /**
     * Convenience type for browser plugin wallets supporting the CIP 30 dApp connector standard (eg. Eternl, Nami, ...).
     *
     * This is useful in typescript projects to avoid type errors when accessing the handles in `window.cardano`.
     *
     * ```ts
     * // refer to this file in the 'typeRoots' list in tsconfig.json
     *
     * type Cip30SimpleHandle = {
     *   name: string,
     *   icon: string,
     *   enable(): Promise<helios.Cip30Handle>,
     *   isEnabled(): boolean
     * }
     *
     * declare global {
     *   interface Window {
     *     cardano: {
     *       [walletName: string]: Cip30SimpleHandle
     *     };
     *   }
     * }
     * ```
     *
     * @typedef {{
     *     getNetworkId(): Promise<number>,
     *     getUsedAddresses(): Promise<string[]>,
     *     getUnusedAddresses(): Promise<string[]>,
     *     getUtxos(): Promise<string[]>,
     *     getCollateral(): Promise<string[]>,
     *     signTx(txHex: string, partialSign: boolean): Promise<string>,
     *     submitTx(txHex: string): Promise<string>,
     *     experimental: {
     *         getCollateral(): Promise<string[]>
     *     },
     * }} Cip30Handle
     */
    /**
     * Implementation of `Wallet` that lets you connect to a browser plugin wallet.
     * @implements {Wallet}
     */
    export class Cip30Wallet implements Wallet {
        /**
         * Constructs Cip30Wallet using the Cip30Handle which is available in the browser window.cardano context.
         *
         * ```ts
         * const handle: helios.Cip30Handle = await window.cardano.eternl.enable()
         * const wallet = new helios.Cip30Wallet(handle)
         * ```
         * @param {Cip30Handle} handle
         */
        constructor(handle: Cip30Handle);
        /**
         * Returns `true` if the wallet is connected to the mainnet.
         * @returns {Promise<boolean>}
         */
        isMainnet(): Promise<boolean>;
        /**
         * Gets a list of addresses which contain(ed) UTxOs.
         * @type {Promise<Address[]>}
         */
        get usedAddresses(): Promise<Address[]>;
        /**
         * Gets a list of unique unused addresses which can be used to UTxOs to.
         * @type {Promise<Address[]>}
         */
        get unusedAddresses(): Promise<Address[]>;
        /**
         * Gets the complete list of UTxOs (as `TxInput` instances) sitting at the addresses owned by the wallet.
         * @type {Promise<TxInput[]>}
         */
        get utxos(): Promise<TxInput[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get collateral(): Promise<TxInput[]>;
        /**
         * Signs a transaction, returning a list of signatures needed for submitting a valid transaction.
         * @param {Tx} tx
         * @returns {Promise<Signature[]>}
         */
        signTx(tx: Tx): Promise<Signature[]>;
        /**
         * Submits a transaction to the blockchain.
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * High-level helper class for instances that implement the `Wallet` interface.
     */
    export class WalletHelper {
        /**
         * @param {Wallet} wallet
         * @param {undefined | ((addr: Address[]) => Promise<TxInput[]>)} getUtxosFallback
         */
        constructor(wallet: Wallet, getUtxosFallback?: ((addr: Address[]) => Promise<TxInput[]>) | undefined);
        /**
         * Concatenation of `usedAddresses` and `unusedAddresses`.
         * @type {Promise<Address[]>}
         */
        get allAddresses(): Promise<Address[]>;
        /**
         * @returns {Promise<Value>}
         */
        calcBalance(): Promise<Value>;
        /**
         * First `Address` in `allAddresses`.
         * @type {Promise<Address>}
         */
        get baseAddress(): Promise<Address>;
        /**
         * First `Address` in `unusedAddresses` (falls back to last `Address` in `usedAddresses` if not defined).
         * @type {Promise<Address>}
         */
        get changeAddress(): Promise<Address>;
        /**
         * First UTxO in `utxos`. Can be used to distinguish between preview and preprod networks.
         * @type {Promise<null | TxInput>}
         */
        get refUtxo(): Promise<TxInput | null>;
        /**
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(): Promise<TxInput[]>;
        /**
         * Pick a number of UTxOs needed to cover a given Value. The default coin selection strategy is to pick the smallest first.
         * @param {Value} amount
         * @param {CoinSelectionAlgorithm} algorithm
         * @returns {Promise<[TxInput[], TxInput[]]>} The first list contains the selected UTxOs, the second list contains the remaining UTxOs.
         */
        pickUtxos(amount: Value, algorithm?: CoinSelectionAlgorithm): Promise<[TxInput[], TxInput[]]>;
        /**
         * Picks a single UTxO intended as collateral.
         * @param {bigint} amount - 2 Ada should cover most things
         * @returns {Promise<TxInput>}
         */
        pickCollateral(amount?: bigint): Promise<TxInput>;
        /**
         * Returns `true` if the `PubKeyHash` in the given `Address` is controlled by the wallet.
         * @param {Address} addr
         * @returns {Promise<boolean>}
         */
        isOwnAddress(addr: Address): Promise<boolean>;
        /**
         * Returns `true` if the given `PubKeyHash` is controlled by the wallet.
         * @param {PubKeyHash} pkh
         * @returns {Promise<boolean>}
         */
        isOwnPubKeyHash(pkh: PubKeyHash): Promise<boolean>;
        /**
         * @returns {Promise<any>}
         */
        toJson(): Promise<any>;
        #private;
    }
    /**
     * @implements {Wallet}
     */
    export class RemoteWallet implements Wallet {
        /**
         * @param {string | Object} obj
         * @returns {RemoteWallet}
         */
        static fromJson(obj: string | any): RemoteWallet;
        /**
         * @param {boolean} isMainnet
         * @param {Address[]} usedAddresses
         * @param {Address[]} unusedAddresses
         * @param {TxInput[]} utxos
         */
        constructor(isMainnet: boolean, usedAddresses: Address[], unusedAddresses: Address[], utxos: TxInput[]);
        /**
         * @returns {Promise<boolean>}
         */
        isMainnet(): Promise<boolean>;
        /**
         * @type {Promise<Address[]>}
         */
        get usedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<Address[]>}
         */
        get unusedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get utxos(): Promise<TxInput[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get collateral(): Promise<TxInput[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<Signature[]>}
         */
        signTx(tx: Tx): Promise<Signature[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * Blockchain query interface.
     * @interface
     * @typedef {object} Network
     * @property {(address: Address) => Promise<TxInput[]>} getUtxos Returns a complete list of UTxOs at a given address.
     * @property {(id: TxOutputId) => Promise<TxInput>} getUtxo Returns a single TxInput (that might already have been spent).
     * @property {() => Promise<NetworkParams>} getParameters Returns the latest network parameters.
     * @property {(tx: Tx) => Promise<TxId>} submitTx Submits a transaction to the blockchain and returns the id of that transaction upon success.
     */
    /**
     * Blockfrost specific implementation of `Network`.
     * @implements {Network}
     */
    export class BlockfrostV0 implements Network {
        /**
         * Throws an error if a Blockfrost project_id is missing for that specific network.
         * @param {TxInput} refUtxo
         * @param {{
         *     preview?: string,
         *     preprod?: string,
         *     mainnet?: string
         * }} projectIds
         * @returns {Promise<BlockfrostV0>}
         */
        static resolveUsingUtxo(refUtxo: TxInput, projectIds: {
            preview?: string;
            preprod?: string;
            mainnet?: string;
        }): Promise<BlockfrostV0>;
        /**
         * Connects to the same network a given `Wallet` is connected to (preview, preprod or mainnet).
         *
         * Throws an error if a Blockfrost project_id is missing for that specific network.
         * @param {Wallet} wallet
         * @param {{
         *     preview?: string,
         *     preprod?: string,
         *     mainnet?: string
         * }} projectIds
         * @returns {Promise<BlockfrostV0>}
         */
        static resolveUsingWallet(wallet: Wallet, projectIds: {
            preview?: string;
            preprod?: string;
            mainnet?: string;
        }): Promise<BlockfrostV0>;
        /**
        * Connects to the same network a given `Wallet` or the given `TxInput` (preview, preprod or mainnet).
        *
        * Throws an error if a Blockfrost project_id is missing for that specific network.
        * @param {TxInput | Wallet} utxoOrWallet
        * @param {{
        *     preview?: string,
        *     preprod?: string,
        *     mainnet?: string
        * }} projectIds
        * @returns {Promise<BlockfrostV0>}
        */
        static resolve(utxoOrWallet: TxInput | Wallet, projectIds: {
            preview?: string;
            preprod?: string;
            mainnet?: string;
        }): Promise<BlockfrostV0>;
        /**
         * @internal
         * @param {{unit: string, quantity: string}[]} obj
         * @returns {Value}
         */
        static parseValue(obj: {
            unit: string;
            quantity: string;
        }[]): Value;
        /**
         * Constructs a BlockfrostV0 using the network name (preview, preprod or mainnet) and your Blockfrost `project_id`.
         * @param {"preview" | "preprod" | "mainnet"} networkName
         * @param {string} projectId
         */
        constructor(networkName: "preview" | "preprod" | "mainnet", projectId: string);
        /**
         * @type {string}
         */
        get networkName(): string;
        /**
         * @returns {Promise<NetworkParams>}
         */
        getParameters(): Promise<NetworkParams>;
        /**
         * @returns {Promise<any>}
         */
        getLatestEpoch(): Promise<any>;
        /**
         * If the UTxO isn't found an error is throw with the following message format: "UTxO <txId.utxoId> not found".
         * @param {TxOutputId} id
         * @returns {Promise<TxInput>}
         */
        getUtxo(id: TxOutputId): Promise<TxInput>;
        /**
         * Used by `BlockfrostV0.resolve()`.
         * @param {TxInput} utxo
         * @returns {Promise<boolean>}
         */
        hasUtxo(utxo: TxInput): Promise<boolean>;
        /**
         * @internal
         * @param {{
         *   address: string
         *   tx_hash: string
         *   output_index: number
         *   amount: {unit: string, quantity: string}[]
         *   inline_datum: null | string
         *   data_hash: null | string
         *   collateral: boolean
         *   reference_script_hash: null | string
         * }} obj
         */
        restoreTxInput(obj: {
            address: string;
            tx_hash: string;
            output_index: number;
            amount: {
                unit: string;
                quantity: string;
            }[];
            inline_datum: null | string;
            data_hash: null | string;
            collateral: boolean;
            reference_script_hash: null | string;
        }): Promise<TxInput>;
        /**
         * Gets a complete list of UTxOs at a given `Address`.
         * Returns oldest UTxOs first, newest last.
         * @param {Address} address
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(address: Address): Promise<TxInput[]>;
        /**
         * Submits a transaction to the blockchain.
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        /**
         * Allows inspecting the live Blockfrost mempool.
         */
        dumpMempool(): Promise<void>;
        #private;
    }
    export namespace rawNetworkEmulatorParams {
        namespace shelleyGenesis {
            const activeSlotsCoeff: number;
            const epochLength: number;
            const genDelegs: {
                "637f2e950b0fd8f8e3e811c5fbeb19e411e7a2bf37272b84b29c1a0b": {
                    delegate: string;
                    vrf: string;
                };
                "8a4b77c4f534f8b8cc6f269e5ebb7ba77fa63a476e50e05e66d7051c": {
                    delegate: string;
                    vrf: string;
                };
                b00470cd193d67aac47c373602fccd4195aad3002c169b5570de1126: {
                    delegate: string;
                    vrf: string;
                };
                b260ffdb6eba541fcf18601923457307647dce807851b9d19da133ab: {
                    delegate: string;
                    vrf: string;
                };
                ced1599fd821a39593e00592e5292bdc1437ae0f7af388ef5257344a: {
                    delegate: string;
                    vrf: string;
                };
                dd2a7d71a05bed11db61555ba4c658cb1ce06c8024193d064f2a66ae: {
                    delegate: string;
                    vrf: string;
                };
                f3b9e74f7d0f24d2314ea5dfbca94b65b2059d1ff94d97436b82d5b4: {
                    delegate: string;
                    vrf: string;
                };
            };
            const initialFunds: {};
            const maxKESEvolutions: number;
            const maxLovelaceSupply: number;
            const networkId: string;
            const networkMagic: number;
            namespace protocolParams {
                const a0: number;
                const decentralisationParam: number;
                const eMax: number;
                namespace extraEntropy {
                    const tag: string;
                }
                const keyDeposit: number;
                const maxBlockBodySize: number;
                const maxBlockHeaderSize: number;
                const maxTxSize: number;
                const minFeeA: number;
                const minFeeB: number;
                const minPoolCost: number;
                const minUTxOValue: number;
                const nOpt: number;
                const poolDeposit: number;
                namespace protocolVersion {
                    const major: number;
                    const minor: number;
                }
                const rho: number;
                const tau: number;
            }
            const securityParam: number;
            const slotLength: number;
            const slotsPerKESPeriod: number;
            namespace staking {
                const pools: {};
                const stake: {};
            }
            const systemStart: string;
            const updateQuorum: number;
        }
        namespace alonzoGenesis {
            const lovelacePerUTxOWord: number;
            namespace executionPrices {
                namespace prSteps {
                    const numerator: number;
                    const denominator: number;
                }
                namespace prMem {
                    const numerator_1: number;
                    export { numerator_1 as numerator };
                    const denominator_1: number;
                    export { denominator_1 as denominator };
                }
            }
            namespace maxTxExUnits {
                const exUnitsMem: number;
                const exUnitsSteps: number;
            }
            namespace maxBlockExUnits {
                const exUnitsMem_1: number;
                export { exUnitsMem_1 as exUnitsMem };
                const exUnitsSteps_1: number;
                export { exUnitsSteps_1 as exUnitsSteps };
            }
            const maxValueSize: number;
            const collateralPercentage: number;
            const maxCollateralInputs: number;
            namespace costModels {
                const PlutusV1: {
                    "sha2_256-memory-arguments": number;
                    "equalsString-cpu-arguments-constant": number;
                    "cekDelayCost-exBudgetMemory": number;
                    "lessThanEqualsByteString-cpu-arguments-intercept": number;
                    "divideInteger-memory-arguments-minimum": number;
                    "appendByteString-cpu-arguments-slope": number;
                    "blake2b-cpu-arguments-slope": number;
                    "iData-cpu-arguments": number;
                    "encodeUtf8-cpu-arguments-slope": number;
                    "unBData-cpu-arguments": number;
                    "multiplyInteger-cpu-arguments-intercept": number;
                    "cekConstCost-exBudgetMemory": number;
                    "nullList-cpu-arguments": number;
                    "equalsString-cpu-arguments-intercept": number;
                    "trace-cpu-arguments": number;
                    "mkNilData-memory-arguments": number;
                    "lengthOfByteString-cpu-arguments": number;
                    "cekBuiltinCost-exBudgetCPU": number;
                    "bData-cpu-arguments": number;
                    "subtractInteger-cpu-arguments-slope": number;
                    "unIData-cpu-arguments": number;
                    "consByteString-memory-arguments-intercept": number;
                    "divideInteger-memory-arguments-slope": number;
                    "divideInteger-cpu-arguments-model-arguments-slope": number;
                    "listData-cpu-arguments": number;
                    "headList-cpu-arguments": number;
                    "chooseData-memory-arguments": number;
                    "equalsInteger-cpu-arguments-intercept": number;
                    "sha3_256-cpu-arguments-slope": number;
                    "sliceByteString-cpu-arguments-slope": number;
                    "unMapData-cpu-arguments": number;
                    "lessThanInteger-cpu-arguments-intercept": number;
                    "mkCons-cpu-arguments": number;
                    "appendString-memory-arguments-intercept": number;
                    "modInteger-cpu-arguments-model-arguments-slope": number;
                    "ifThenElse-cpu-arguments": number;
                    "mkNilPairData-cpu-arguments": number;
                    "lessThanEqualsInteger-cpu-arguments-intercept": number;
                    "addInteger-memory-arguments-slope": number;
                    "chooseList-memory-arguments": number;
                    "constrData-memory-arguments": number;
                    "decodeUtf8-cpu-arguments-intercept": number;
                    "equalsData-memory-arguments": number;
                    "subtractInteger-memory-arguments-slope": number;
                    "appendByteString-memory-arguments-intercept": number;
                    "lengthOfByteString-memory-arguments": number;
                    "headList-memory-arguments": number;
                    "listData-memory-arguments": number;
                    "consByteString-cpu-arguments-intercept": number;
                    "unIData-memory-arguments": number;
                    "remainderInteger-memory-arguments-minimum": number;
                    "bData-memory-arguments": number;
                    "lessThanByteString-cpu-arguments-slope": number;
                    "encodeUtf8-memory-arguments-intercept": number;
                    "cekStartupCost-exBudgetCPU": number;
                    "multiplyInteger-memory-arguments-intercept": number;
                    "unListData-memory-arguments": number;
                    "remainderInteger-cpu-arguments-model-arguments-slope": number;
                    "cekVarCost-exBudgetCPU": number;
                    "remainderInteger-memory-arguments-slope": number;
                    "cekForceCost-exBudgetCPU": number;
                    "sha2_256-cpu-arguments-slope": number;
                    "equalsInteger-memory-arguments": number;
                    "indexByteString-memory-arguments": number;
                    "addInteger-memory-arguments-intercept": number;
                    "chooseUnit-cpu-arguments": number;
                    "sndPair-cpu-arguments": number;
                    "cekLamCost-exBudgetCPU": number;
                    "fstPair-cpu-arguments": number;
                    "quotientInteger-memory-arguments-minimum": number;
                    "decodeUtf8-cpu-arguments-slope": number;
                    "lessThanInteger-memory-arguments": number;
                    "lessThanEqualsInteger-cpu-arguments-slope": number;
                    "fstPair-memory-arguments": number;
                    "modInteger-memory-arguments-intercept": number;
                    "unConstrData-cpu-arguments": number;
                    "lessThanEqualsInteger-memory-arguments": number;
                    "chooseUnit-memory-arguments": number;
                    "sndPair-memory-arguments": number;
                    "addInteger-cpu-arguments-intercept": number;
                    "decodeUtf8-memory-arguments-slope": number;
                    "equalsData-cpu-arguments-intercept": number;
                    "mapData-cpu-arguments": number;
                    "mkPairData-cpu-arguments": number;
                    "quotientInteger-cpu-arguments-constant": number;
                    "consByteString-memory-arguments-slope": number;
                    "cekVarCost-exBudgetMemory": number;
                    "indexByteString-cpu-arguments": number;
                    "unListData-cpu-arguments": number;
                    "equalsInteger-cpu-arguments-slope": number;
                    "cekStartupCost-exBudgetMemory": number;
                    "subtractInteger-cpu-arguments-intercept": number;
                    "divideInteger-cpu-arguments-model-arguments-intercept": number;
                    "divideInteger-memory-arguments-intercept": number;
                    "cekForceCost-exBudgetMemory": number;
                    "blake2b-cpu-arguments-intercept": number;
                    "remainderInteger-cpu-arguments-constant": number;
                    "tailList-cpu-arguments": number;
                    "encodeUtf8-cpu-arguments-intercept": number;
                    "equalsString-cpu-arguments-slope": number;
                    "lessThanByteString-memory-arguments": number;
                    "multiplyInteger-cpu-arguments-slope": number;
                    "appendByteString-cpu-arguments-intercept": number;
                    "lessThanEqualsByteString-cpu-arguments-slope": number;
                    "modInteger-memory-arguments-slope": number;
                    "addInteger-cpu-arguments-slope": number;
                    "equalsData-cpu-arguments-slope": number;
                    "decodeUtf8-memory-arguments-intercept": number;
                    "chooseList-cpu-arguments": number;
                    "constrData-cpu-arguments": number;
                    "equalsByteString-memory-arguments": number;
                    "cekApplyCost-exBudgetCPU": number;
                    "quotientInteger-memory-arguments-slope": number;
                    "verifySignature-cpu-arguments-intercept": number;
                    "unMapData-memory-arguments": number;
                    "mkCons-memory-arguments": number;
                    "sliceByteString-memory-arguments-slope": number;
                    "sha3_256-memory-arguments": number;
                    "ifThenElse-memory-arguments": number;
                    "mkNilPairData-memory-arguments": number;
                    "equalsByteString-cpu-arguments-slope": number;
                    "appendString-cpu-arguments-intercept": number;
                    "quotientInteger-cpu-arguments-model-arguments-slope": number;
                    "cekApplyCost-exBudgetMemory": number;
                    "equalsString-memory-arguments": number;
                    "multiplyInteger-memory-arguments-slope": number;
                    "cekBuiltinCost-exBudgetMemory": number;
                    "remainderInteger-memory-arguments-intercept": number;
                    "sha2_256-cpu-arguments-intercept": number;
                    "remainderInteger-cpu-arguments-model-arguments-intercept": number;
                    "lessThanEqualsByteString-memory-arguments": number;
                    "tailList-memory-arguments": number;
                    "mkNilData-cpu-arguments": number;
                    "chooseData-cpu-arguments": number;
                    "unBData-memory-arguments": number;
                    "blake2b-memory-arguments": number;
                    "iData-memory-arguments": number;
                    "nullList-memory-arguments": number;
                    "cekDelayCost-exBudgetCPU": number;
                    "subtractInteger-memory-arguments-intercept": number;
                    "lessThanByteString-cpu-arguments-intercept": number;
                    "consByteString-cpu-arguments-slope": number;
                    "appendByteString-memory-arguments-slope": number;
                    "trace-memory-arguments": number;
                    "divideInteger-cpu-arguments-constant": number;
                    "cekConstCost-exBudgetCPU": number;
                    "encodeUtf8-memory-arguments-slope": number;
                    "quotientInteger-cpu-arguments-model-arguments-intercept": number;
                    "mapData-memory-arguments": number;
                    "appendString-cpu-arguments-slope": number;
                    "modInteger-cpu-arguments-constant": number;
                    "verifySignature-cpu-arguments-slope": number;
                    "unConstrData-memory-arguments": number;
                    "quotientInteger-memory-arguments-intercept": number;
                    "equalsByteString-cpu-arguments-constant": number;
                    "sliceByteString-memory-arguments-intercept": number;
                    "mkPairData-memory-arguments": number;
                    "equalsByteString-cpu-arguments-intercept": number;
                    "appendString-memory-arguments-slope": number;
                    "lessThanInteger-cpu-arguments-slope": number;
                    "modInteger-cpu-arguments-model-arguments-intercept": number;
                    "modInteger-memory-arguments-minimum": number;
                    "sha3_256-cpu-arguments-intercept": number;
                    "verifySignature-memory-arguments": number;
                    "cekLamCost-exBudgetMemory": number;
                    "sliceByteString-cpu-arguments-intercept": number;
                };
            }
        }
        namespace latestParams {
            const collateralPercentage_1: number;
            export { collateralPercentage_1 as collateralPercentage };
            export namespace costModels_1 {
                const PlutusScriptV1: {
                    "addInteger-cpu-arguments-intercept": number;
                    "addInteger-cpu-arguments-slope": number;
                    "addInteger-memory-arguments-intercept": number;
                    "addInteger-memory-arguments-slope": number;
                    "appendByteString-cpu-arguments-intercept": number;
                    "appendByteString-cpu-arguments-slope": number;
                    "appendByteString-memory-arguments-intercept": number;
                    "appendByteString-memory-arguments-slope": number;
                    "appendString-cpu-arguments-intercept": number;
                    "appendString-cpu-arguments-slope": number;
                    "appendString-memory-arguments-intercept": number;
                    "appendString-memory-arguments-slope": number;
                    "bData-cpu-arguments": number;
                    "bData-memory-arguments": number;
                    "blake2b_256-cpu-arguments-intercept": number;
                    "blake2b_256-cpu-arguments-slope": number;
                    "blake2b_256-memory-arguments": number;
                    "cekApplyCost-exBudgetCPU": number;
                    "cekApplyCost-exBudgetMemory": number;
                    "cekBuiltinCost-exBudgetCPU": number;
                    "cekBuiltinCost-exBudgetMemory": number;
                    "cekConstCost-exBudgetCPU": number;
                    "cekConstCost-exBudgetMemory": number;
                    "cekDelayCost-exBudgetCPU": number;
                    "cekDelayCost-exBudgetMemory": number;
                    "cekForceCost-exBudgetCPU": number;
                    "cekForceCost-exBudgetMemory": number;
                    "cekLamCost-exBudgetCPU": number;
                    "cekLamCost-exBudgetMemory": number;
                    "cekStartupCost-exBudgetCPU": number;
                    "cekStartupCost-exBudgetMemory": number;
                    "cekVarCost-exBudgetCPU": number;
                    "cekVarCost-exBudgetMemory": number;
                    "chooseData-cpu-arguments": number;
                    "chooseData-memory-arguments": number;
                    "chooseList-cpu-arguments": number;
                    "chooseList-memory-arguments": number;
                    "chooseUnit-cpu-arguments": number;
                    "chooseUnit-memory-arguments": number;
                    "consByteString-cpu-arguments-intercept": number;
                    "consByteString-cpu-arguments-slope": number;
                    "consByteString-memory-arguments-intercept": number;
                    "consByteString-memory-arguments-slope": number;
                    "constrData-cpu-arguments": number;
                    "constrData-memory-arguments": number;
                    "decodeUtf8-cpu-arguments-intercept": number;
                    "decodeUtf8-cpu-arguments-slope": number;
                    "decodeUtf8-memory-arguments-intercept": number;
                    "decodeUtf8-memory-arguments-slope": number;
                    "divideInteger-cpu-arguments-constant": number;
                    "divideInteger-cpu-arguments-model-arguments-intercept": number;
                    "divideInteger-cpu-arguments-model-arguments-slope": number;
                    "divideInteger-memory-arguments-intercept": number;
                    "divideInteger-memory-arguments-minimum": number;
                    "divideInteger-memory-arguments-slope": number;
                    "encodeUtf8-cpu-arguments-intercept": number;
                    "encodeUtf8-cpu-arguments-slope": number;
                    "encodeUtf8-memory-arguments-intercept": number;
                    "encodeUtf8-memory-arguments-slope": number;
                    "equalsByteString-cpu-arguments-constant": number;
                    "equalsByteString-cpu-arguments-intercept": number;
                    "equalsByteString-cpu-arguments-slope": number;
                    "equalsByteString-memory-arguments": number;
                    "equalsData-cpu-arguments-intercept": number;
                    "equalsData-cpu-arguments-slope": number;
                    "equalsData-memory-arguments": number;
                    "equalsInteger-cpu-arguments-intercept": number;
                    "equalsInteger-cpu-arguments-slope": number;
                    "equalsInteger-memory-arguments": number;
                    "equalsString-cpu-arguments-constant": number;
                    "equalsString-cpu-arguments-intercept": number;
                    "equalsString-cpu-arguments-slope": number;
                    "equalsString-memory-arguments": number;
                    "fstPair-cpu-arguments": number;
                    "fstPair-memory-arguments": number;
                    "headList-cpu-arguments": number;
                    "headList-memory-arguments": number;
                    "iData-cpu-arguments": number;
                    "iData-memory-arguments": number;
                    "ifThenElse-cpu-arguments": number;
                    "ifThenElse-memory-arguments": number;
                    "indexByteString-cpu-arguments": number;
                    "indexByteString-memory-arguments": number;
                    "lengthOfByteString-cpu-arguments": number;
                    "lengthOfByteString-memory-arguments": number;
                    "lessThanByteString-cpu-arguments-intercept": number;
                    "lessThanByteString-cpu-arguments-slope": number;
                    "lessThanByteString-memory-arguments": number;
                    "lessThanEqualsByteString-cpu-arguments-intercept": number;
                    "lessThanEqualsByteString-cpu-arguments-slope": number;
                    "lessThanEqualsByteString-memory-arguments": number;
                    "lessThanEqualsInteger-cpu-arguments-intercept": number;
                    "lessThanEqualsInteger-cpu-arguments-slope": number;
                    "lessThanEqualsInteger-memory-arguments": number;
                    "lessThanInteger-cpu-arguments-intercept": number;
                    "lessThanInteger-cpu-arguments-slope": number;
                    "lessThanInteger-memory-arguments": number;
                    "listData-cpu-arguments": number;
                    "listData-memory-arguments": number;
                    "mapData-cpu-arguments": number;
                    "mapData-memory-arguments": number;
                    "mkCons-cpu-arguments": number;
                    "mkCons-memory-arguments": number;
                    "mkNilData-cpu-arguments": number;
                    "mkNilData-memory-arguments": number;
                    "mkNilPairData-cpu-arguments": number;
                    "mkNilPairData-memory-arguments": number;
                    "mkPairData-cpu-arguments": number;
                    "mkPairData-memory-arguments": number;
                    "modInteger-cpu-arguments-constant": number;
                    "modInteger-cpu-arguments-model-arguments-intercept": number;
                    "modInteger-cpu-arguments-model-arguments-slope": number;
                    "modInteger-memory-arguments-intercept": number;
                    "modInteger-memory-arguments-minimum": number;
                    "modInteger-memory-arguments-slope": number;
                    "multiplyInteger-cpu-arguments-intercept": number;
                    "multiplyInteger-cpu-arguments-slope": number;
                    "multiplyInteger-memory-arguments-intercept": number;
                    "multiplyInteger-memory-arguments-slope": number;
                    "nullList-cpu-arguments": number;
                    "nullList-memory-arguments": number;
                    "quotientInteger-cpu-arguments-constant": number;
                    "quotientInteger-cpu-arguments-model-arguments-intercept": number;
                    "quotientInteger-cpu-arguments-model-arguments-slope": number;
                    "quotientInteger-memory-arguments-intercept": number;
                    "quotientInteger-memory-arguments-minimum": number;
                    "quotientInteger-memory-arguments-slope": number;
                    "remainderInteger-cpu-arguments-constant": number;
                    "remainderInteger-cpu-arguments-model-arguments-intercept": number;
                    "remainderInteger-cpu-arguments-model-arguments-slope": number;
                    "remainderInteger-memory-arguments-intercept": number;
                    "remainderInteger-memory-arguments-minimum": number;
                    "remainderInteger-memory-arguments-slope": number;
                    "sha2_256-cpu-arguments-intercept": number;
                    "sha2_256-cpu-arguments-slope": number;
                    "sha2_256-memory-arguments": number;
                    "sha3_256-cpu-arguments-intercept": number;
                    "sha3_256-cpu-arguments-slope": number;
                    "sha3_256-memory-arguments": number;
                    "sliceByteString-cpu-arguments-intercept": number;
                    "sliceByteString-cpu-arguments-slope": number;
                    "sliceByteString-memory-arguments-intercept": number;
                    "sliceByteString-memory-arguments-slope": number;
                    "sndPair-cpu-arguments": number;
                    "sndPair-memory-arguments": number;
                    "subtractInteger-cpu-arguments-intercept": number;
                    "subtractInteger-cpu-arguments-slope": number;
                    "subtractInteger-memory-arguments-intercept": number;
                    "subtractInteger-memory-arguments-slope": number;
                    "tailList-cpu-arguments": number;
                    "tailList-memory-arguments": number;
                    "trace-cpu-arguments": number;
                    "trace-memory-arguments": number;
                    "unBData-cpu-arguments": number;
                    "unBData-memory-arguments": number;
                    "unConstrData-cpu-arguments": number;
                    "unConstrData-memory-arguments": number;
                    "unIData-cpu-arguments": number;
                    "unIData-memory-arguments": number;
                    "unListData-cpu-arguments": number;
                    "unListData-memory-arguments": number;
                    "unMapData-cpu-arguments": number;
                    "unMapData-memory-arguments": number;
                    "verifyEd25519Signature-cpu-arguments-intercept": number;
                    "verifyEd25519Signature-cpu-arguments-slope": number;
                    "verifyEd25519Signature-memory-arguments": number;
                };
                const PlutusScriptV2: {
                    "addInteger-cpu-arguments-intercept": number;
                    "addInteger-cpu-arguments-slope": number;
                    "addInteger-memory-arguments-intercept": number;
                    "addInteger-memory-arguments-slope": number;
                    "appendByteString-cpu-arguments-intercept": number;
                    "appendByteString-cpu-arguments-slope": number;
                    "appendByteString-memory-arguments-intercept": number;
                    "appendByteString-memory-arguments-slope": number;
                    "appendString-cpu-arguments-intercept": number;
                    "appendString-cpu-arguments-slope": number;
                    "appendString-memory-arguments-intercept": number;
                    "appendString-memory-arguments-slope": number;
                    "bData-cpu-arguments": number;
                    "bData-memory-arguments": number;
                    "blake2b_256-cpu-arguments-intercept": number;
                    "blake2b_256-cpu-arguments-slope": number;
                    "blake2b_256-memory-arguments": number;
                    "cekApplyCost-exBudgetCPU": number;
                    "cekApplyCost-exBudgetMemory": number;
                    "cekBuiltinCost-exBudgetCPU": number;
                    "cekBuiltinCost-exBudgetMemory": number;
                    "cekConstCost-exBudgetCPU": number;
                    "cekConstCost-exBudgetMemory": number;
                    "cekDelayCost-exBudgetCPU": number;
                    "cekDelayCost-exBudgetMemory": number;
                    "cekForceCost-exBudgetCPU": number;
                    "cekForceCost-exBudgetMemory": number;
                    "cekLamCost-exBudgetCPU": number;
                    "cekLamCost-exBudgetMemory": number;
                    "cekStartupCost-exBudgetCPU": number;
                    "cekStartupCost-exBudgetMemory": number;
                    "cekVarCost-exBudgetCPU": number;
                    "cekVarCost-exBudgetMemory": number;
                    "chooseData-cpu-arguments": number;
                    "chooseData-memory-arguments": number;
                    "chooseList-cpu-arguments": number;
                    "chooseList-memory-arguments": number;
                    "chooseUnit-cpu-arguments": number;
                    "chooseUnit-memory-arguments": number;
                    "consByteString-cpu-arguments-intercept": number;
                    "consByteString-cpu-arguments-slope": number;
                    "consByteString-memory-arguments-intercept": number;
                    "consByteString-memory-arguments-slope": number;
                    "constrData-cpu-arguments": number;
                    "constrData-memory-arguments": number;
                    "decodeUtf8-cpu-arguments-intercept": number;
                    "decodeUtf8-cpu-arguments-slope": number;
                    "decodeUtf8-memory-arguments-intercept": number;
                    "decodeUtf8-memory-arguments-slope": number;
                    "divideInteger-cpu-arguments-constant": number;
                    "divideInteger-cpu-arguments-model-arguments-intercept": number;
                    "divideInteger-cpu-arguments-model-arguments-slope": number;
                    "divideInteger-memory-arguments-intercept": number;
                    "divideInteger-memory-arguments-minimum": number;
                    "divideInteger-memory-arguments-slope": number;
                    "encodeUtf8-cpu-arguments-intercept": number;
                    "encodeUtf8-cpu-arguments-slope": number;
                    "encodeUtf8-memory-arguments-intercept": number;
                    "encodeUtf8-memory-arguments-slope": number;
                    "equalsByteString-cpu-arguments-constant": number;
                    "equalsByteString-cpu-arguments-intercept": number;
                    "equalsByteString-cpu-arguments-slope": number;
                    "equalsByteString-memory-arguments": number;
                    "equalsData-cpu-arguments-intercept": number;
                    "equalsData-cpu-arguments-slope": number;
                    "equalsData-memory-arguments": number;
                    "equalsInteger-cpu-arguments-intercept": number;
                    "equalsInteger-cpu-arguments-slope": number;
                    "equalsInteger-memory-arguments": number;
                    "equalsString-cpu-arguments-constant": number;
                    "equalsString-cpu-arguments-intercept": number;
                    "equalsString-cpu-arguments-slope": number;
                    "equalsString-memory-arguments": number;
                    "fstPair-cpu-arguments": number;
                    "fstPair-memory-arguments": number;
                    "headList-cpu-arguments": number;
                    "headList-memory-arguments": number;
                    "iData-cpu-arguments": number;
                    "iData-memory-arguments": number;
                    "ifThenElse-cpu-arguments": number;
                    "ifThenElse-memory-arguments": number;
                    "indexByteString-cpu-arguments": number;
                    "indexByteString-memory-arguments": number;
                    "lengthOfByteString-cpu-arguments": number;
                    "lengthOfByteString-memory-arguments": number;
                    "lessThanByteString-cpu-arguments-intercept": number;
                    "lessThanByteString-cpu-arguments-slope": number;
                    "lessThanByteString-memory-arguments": number;
                    "lessThanEqualsByteString-cpu-arguments-intercept": number;
                    "lessThanEqualsByteString-cpu-arguments-slope": number;
                    "lessThanEqualsByteString-memory-arguments": number;
                    "lessThanEqualsInteger-cpu-arguments-intercept": number;
                    "lessThanEqualsInteger-cpu-arguments-slope": number;
                    "lessThanEqualsInteger-memory-arguments": number;
                    "lessThanInteger-cpu-arguments-intercept": number;
                    "lessThanInteger-cpu-arguments-slope": number;
                    "lessThanInteger-memory-arguments": number;
                    "listData-cpu-arguments": number;
                    "listData-memory-arguments": number;
                    "mapData-cpu-arguments": number;
                    "mapData-memory-arguments": number;
                    "mkCons-cpu-arguments": number;
                    "mkCons-memory-arguments": number;
                    "mkNilData-cpu-arguments": number;
                    "mkNilData-memory-arguments": number;
                    "mkNilPairData-cpu-arguments": number;
                    "mkNilPairData-memory-arguments": number;
                    "mkPairData-cpu-arguments": number;
                    "mkPairData-memory-arguments": number;
                    "modInteger-cpu-arguments-constant": number;
                    "modInteger-cpu-arguments-model-arguments-intercept": number;
                    "modInteger-cpu-arguments-model-arguments-slope": number;
                    "modInteger-memory-arguments-intercept": number;
                    "modInteger-memory-arguments-minimum": number;
                    "modInteger-memory-arguments-slope": number;
                    "multiplyInteger-cpu-arguments-intercept": number;
                    "multiplyInteger-cpu-arguments-slope": number;
                    "multiplyInteger-memory-arguments-intercept": number;
                    "multiplyInteger-memory-arguments-slope": number;
                    "nullList-cpu-arguments": number;
                    "nullList-memory-arguments": number;
                    "quotientInteger-cpu-arguments-constant": number;
                    "quotientInteger-cpu-arguments-model-arguments-intercept": number;
                    "quotientInteger-cpu-arguments-model-arguments-slope": number;
                    "quotientInteger-memory-arguments-intercept": number;
                    "quotientInteger-memory-arguments-minimum": number;
                    "quotientInteger-memory-arguments-slope": number;
                    "remainderInteger-cpu-arguments-constant": number;
                    "remainderInteger-cpu-arguments-model-arguments-intercept": number;
                    "remainderInteger-cpu-arguments-model-arguments-slope": number;
                    "remainderInteger-memory-arguments-intercept": number;
                    "remainderInteger-memory-arguments-minimum": number;
                    "remainderInteger-memory-arguments-slope": number;
                    "serialiseData-cpu-arguments-intercept": number;
                    "serialiseData-cpu-arguments-slope": number;
                    "serialiseData-memory-arguments-intercept": number;
                    "serialiseData-memory-arguments-slope": number;
                    "sha2_256-cpu-arguments-intercept": number;
                    "sha2_256-cpu-arguments-slope": number;
                    "sha2_256-memory-arguments": number;
                    "sha3_256-cpu-arguments-intercept": number;
                    "sha3_256-cpu-arguments-slope": number;
                    "sha3_256-memory-arguments": number;
                    "sliceByteString-cpu-arguments-intercept": number;
                    "sliceByteString-cpu-arguments-slope": number;
                    "sliceByteString-memory-arguments-intercept": number;
                    "sliceByteString-memory-arguments-slope": number;
                    "sndPair-cpu-arguments": number;
                    "sndPair-memory-arguments": number;
                    "subtractInteger-cpu-arguments-intercept": number;
                    "subtractInteger-cpu-arguments-slope": number;
                    "subtractInteger-memory-arguments-intercept": number;
                    "subtractInteger-memory-arguments-slope": number;
                    "tailList-cpu-arguments": number;
                    "tailList-memory-arguments": number;
                    "trace-cpu-arguments": number;
                    "trace-memory-arguments": number;
                    "unBData-cpu-arguments": number;
                    "unBData-memory-arguments": number;
                    "unConstrData-cpu-arguments": number;
                    "unConstrData-memory-arguments": number;
                    "unIData-cpu-arguments": number;
                    "unIData-memory-arguments": number;
                    "unListData-cpu-arguments": number;
                    "unListData-memory-arguments": number;
                    "unMapData-cpu-arguments": number;
                    "unMapData-memory-arguments": number;
                    "verifyEcdsaSecp256k1Signature-cpu-arguments": number;
                    "verifyEcdsaSecp256k1Signature-memory-arguments": number;
                    "verifyEd25519Signature-cpu-arguments-intercept": number;
                    "verifyEd25519Signature-cpu-arguments-slope": number;
                    "verifyEd25519Signature-memory-arguments": number;
                    "verifySchnorrSecp256k1Signature-cpu-arguments-intercept": number;
                    "verifySchnorrSecp256k1Signature-cpu-arguments-slope": number;
                    "verifySchnorrSecp256k1Signature-memory-arguments": number;
                };
            }
            export { costModels_1 as costModels };
            export namespace executionUnitPrices {
                const priceMemory: number;
                const priceSteps: number;
            }
            const maxBlockBodySize_1: number;
            export { maxBlockBodySize_1 as maxBlockBodySize };
            export namespace maxBlockExecutionUnits {
                const memory: number;
                const steps: number;
            }
            const maxBlockHeaderSize_1: number;
            export { maxBlockHeaderSize_1 as maxBlockHeaderSize };
            const maxCollateralInputs_1: number;
            export { maxCollateralInputs_1 as maxCollateralInputs };
            export namespace maxTxExecutionUnits {
                const memory_1: number;
                export { memory_1 as memory };
                const steps_1: number;
                export { steps_1 as steps };
            }
            const maxTxSize_1: number;
            export { maxTxSize_1 as maxTxSize };
            const maxValueSize_1: number;
            export { maxValueSize_1 as maxValueSize };
            const minPoolCost_1: number;
            export { minPoolCost_1 as minPoolCost };
            export const monetaryExpansion: number;
            export const poolPledgeInfluence: number;
            export const poolRetireMaxEpoch: number;
            export namespace protocolVersion_1 {
                const major_1: number;
                export { major_1 as major };
                const minor_1: number;
                export { minor_1 as minor };
            }
            export { protocolVersion_1 as protocolVersion };
            export const stakeAddressDeposit: number;
            export const stakePoolDeposit: number;
            export const stakePoolTargetNum: number;
            export const treasuryCut: number;
            export const txFeeFixed: number;
            export const txFeePerByte: number;
            export const utxoCostPerByte: number;
        }
        namespace latestTip {
            const epoch: number;
            const hash: string;
            const slot: number;
            const time: number;
        }
    }
    /**
     * An emulated `Wallet`, created by calling `emulator.createWallet()`.
     *
     * This wallet only has a single private/public key, which isn't rotated. Staking is not yet supported.
     * @implements {Wallet}
     */
    export class WalletEmulator implements Wallet {
        /**
         * @param {Network} network
         * @param {Bip32PrivateKey} privateKey
         */
        constructor(network: Network, privateKey: Bip32PrivateKey);
        /**
         * @type {Bip32PrivateKey}
         */
        get privateKey(): Bip32PrivateKey;
        /**
         * @type {PubKey}
         */
        get pubKey(): PubKey;
        /**
         * @type {PubKeyHash}
         */
        get pubKeyHash(): PubKeyHash;
        /**
         * @type {Address}
         */
        get address(): Address;
        /**
         * @returns {Promise<boolean>}
         */
        isMainnet(): Promise<boolean>;
        /**
         * Assumed wallet was initiated with at least 1 UTxO at the pubkeyhash address.
         * @type {Promise<Address[]>}
         */
        get usedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<Address[]>}
         */
        get unusedAddresses(): Promise<Address[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get utxos(): Promise<TxInput[]>;
        /**
         * @type {Promise<TxInput[]>}
         */
        get collateral(): Promise<TxInput[]>;
        /**
         * Simply assumed the tx needs to by signed by this wallet without checking.
         * @param {Tx} tx
         * @returns {Promise<Signature[]>}
         */
        signTx(tx: Tx): Promise<Signature[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * A simple emulated Network.
     * This can be used to do integration tests of whole dApps.
     * Staking is not yet supported.
     * @implements {Network}
     */
    export class NetworkEmulator implements Network {
        /**
         * Instantiates a NetworkEmulator at slot 0.
         * An optional seed number can be specified, from which all emulated randomness is derived.
         * @param {number} seed
         */
        constructor(seed?: number);
        /**
         * @type {bigint}
         */
        get currentSlot(): bigint;
        /**
         * Creates a new `NetworkParams` instance that has access to current slot
         * (so that the `Tx` validity range can be set automatically during `Tx.finalize()`).
         * @param {NetworkParams} networkParams
         * @returns {NetworkParams}
         */
        initNetworkParams(networkParams: NetworkParams): NetworkParams;
        /**
         * Creates a new WalletEmulator and populates it with a given lovelace quantity and assets.
         * Special genesis transactions are added to the emulated chain in order to create these assets.
         * @param {bigint} lovelace
         * @param {Assets} assets
         * @returns {WalletEmulator}
         */
        createWallet(lovelace?: bigint, assets?: Assets): WalletEmulator;
        /**
         * Creates a UTxO using a GenesisTx.
         * @param {WalletEmulator} wallet
         * @param {bigint} lovelace
         * @param {Assets} assets
         */
        createUtxo(wallet: WalletEmulator, lovelace: bigint, assets?: Assets): void;
        /**
         * Mint a block with the current mempool, and advance the slot by a number of slots.
         * @param {bigint} nSlots
         */
        tick(nSlots: bigint): void;
        /**
         * @returns {Promise<NetworkParams>}
         */
        getParameters(): Promise<NetworkParams>;
        warnMempool(): void;
        /**
         * Throws an error if the UTxO isn't found
         * @param {TxOutputId} id
         * @returns {Promise<TxInput>}
         */
        getUtxo(id: TxOutputId): Promise<TxInput>;
        /**
         * @param {Address} address
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(address: Address): Promise<TxInput[]>;
        dump(): void;
        /**
         * @param {TxInput} utxo
         * @returns {boolean}
         */
        isConsumed(utxo: TxInput): boolean;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * Helper that
     * @implements {Network}
     */
    export class TxChain implements Network {
        /**
         * @param {Network} network
         */
        constructor(network: Network);
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        /**
         * @returns {Promise<NetworkParams>}
         */
        getParameters(): Promise<NetworkParams>;
        /**
         * @param {TxOutputId} id
         * @returns {Promise<TxInput>}
         */
        getUtxo(id: TxOutputId): Promise<TxInput>;
        /**
         * @param {TxInput[]} utxos
         * @param {Address[]} addrs
         * @returns {Promise<TxInput[]>}
         */
        getUtxosInternal(utxos: TxInput[], addrs: Address[]): Promise<TxInput[]>;
        /**
         * @param {Address} addr
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(addr: Address): Promise<TxInput[]>;
        /**
         * @param {Wallet} baseWallet
         * @returns {Wallet}
         */
        asWallet(baseWallet: Wallet): Wallet;
        #private;
    }
    /**
     * @typedef {{
     *   [address: string]: TxInput[]
     * }} NetworkSliceUTxOs
     */
    /**
     * @implements {Network}
     */
    export class NetworkSlice implements Network {
        /**
         * @param {Network} network
         * @param {Address[]} addresses
         * @returns {Promise<NetworkSlice>}
         */
        static init(network: Network, addresses: Address[]): Promise<NetworkSlice>;
        /**
         * @param {any} obj
         * @returns {NetworkSlice}
         */
        static fromJson(obj: any): NetworkSlice;
        /**
         * @param {NetworkParams} params
         * @param {NetworkSliceUTxOs} utxos
         */
        constructor(params: NetworkParams, utxos: NetworkSliceUTxOs);
        /**
         * @returns {any}
         */
        toJson(): any;
        /**
         * @returns {Promise<NetworkParams>}
         */
        getParameters(): Promise<NetworkParams>;
        /**
         * @param {TxOutputId} id
         * @returns {Promise<TxInput>}
         */
        getUtxo(id: TxOutputId): Promise<TxInput>;
        /**
         * @param {Address} addr
         * @returns {Promise<TxInput[]>}
         */
        getUtxos(addr: Address): Promise<TxInput[]>;
        /**
         * @param {Tx} tx
         * @returns {Promise<TxId>}
         */
        submitTx(tx: Tx): Promise<TxId>;
        #private;
    }
    /**
     * @typedef {() => UplcData} ValueGenerator
     */
    /**
     * @typedef {(args: UplcValue[], res: (UplcValue | RuntimeError), isSimplfied?: boolean) => (boolean | Object.<string, boolean>)} PropertyTest
     */
    /**
     * Helper class for performing fuzzy property-based tests of Helios scripts.
     */
    export class FuzzyTest {
        /**
         * The simplify argument specifies whether optimized versions of the Helios sources should also be tested.
         * @param {number} seed
         * @param {number} runsPerTest
         * @param {boolean} simplify If true then also test the simplified program
         */
        constructor(seed?: number, runsPerTest?: number, simplify?: boolean);
        reset(): void;
        /**
         * @returns {NumberGenerator}
         */
        newRand(): NumberGenerator;
        /**
         * Returns a gernator for whole numbers between min and max
         * @param {number} min
         * @param {number} max
         * @returns {() => bigint}
         */
        rawInt(min?: number, max?: number): () => bigint;
        /**
         * Returns a generator for whole numbers between min and max, wrapped with IntData
         * @param {number} min
         * @param {number} max
         * @returns {ValueGenerator}
         */
        int(min?: number, max?: number): ValueGenerator;
        /**
         * @param {number} min
         * @param {number} max
         * @returns {ValueGenerator}
         */
        real(min?: number, max?: number): ValueGenerator;
        /**
         * Returns a generator for strings containing any utf-8 character.
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        string(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for strings with ascii characters from 32 (space) to 126 (tilde).
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        ascii(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for bytearrays containing only valid ascii characters
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        asciiBytes(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for bytearrays the are also valid utf8 strings
         * @param {number} minLength - length of the string, not of the bytearray!
         * @param {number} maxLength - length of the string, not of the bytearray!
         * @returns {ValueGenerator}
         */
        utf8Bytes(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for number[]
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {() => number[]}
         */
        rawBytes(minLength?: number, maxLength?: number): () => number[];
        /**
         * Returns a generator for bytearrays
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        bytes(minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for booleans,
         * @returns {() => boolean}
         */
        rawBool(): () => boolean;
        /**
         * Returns a generator for booleans, wrapped with ConstrData
         * @returns {ValueGenerator}
         */
        bool(): ValueGenerator;
        /**
         * Returns a generator for options
         * @param {ValueGenerator} someGenerator
         * @param {number} noneProbability
         * @returns {ValueGenerator}
         */
        option(someGenerator: ValueGenerator, noneProbability?: number): ValueGenerator;
        /**
         * Returns a generator for lists
         * @param {ValueGenerator} itemGenerator
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        list(itemGenerator: ValueGenerator, minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for maps
         * @param {ValueGenerator} keyGenerator
         * @param {ValueGenerator} valueGenerator
         * @param {number} minLength
         * @param {number} maxLength
         * @returns {ValueGenerator}
         */
        map(keyGenerator: ValueGenerator, valueGenerator: ValueGenerator, minLength?: number, maxLength?: number): ValueGenerator;
        /**
         * Returns a generator for objects
         * @param {...ValueGenerator} itemGenerators
         * @returns {ValueGenerator}
         */
        object(...itemGenerators: ValueGenerator[]): ValueGenerator;
        /**
         * Returns a generator for tagged constr
         * @param {number | NumberGenerator} tag
         * @param {...ValueGenerator} fieldGenerators
         * @returns {ValueGenerator}
         */
        constr(tag: number | NumberGenerator, ...fieldGenerators: ValueGenerator[]): ValueGenerator;
        /**
         * Perform a fuzzy/property-based test-run of a Helios source. One value generator must be specified per argument of main.
         *
         * Throws an error if the propTest fails.
         *
         * The propTest can simply return a boolean, or can return an object with boolean values, and if any of these booleans is false the propTest fails (the keys can be used to provide extra information).
         * @param {ValueGenerator[]} argGens
         * @param {string} src
         * @param {PropertyTest} propTest
         * @param {number} nRuns
         * @param {boolean} simplify
         * @returns {Promise<void>} - throws an error if any of the property tests fail
         */
        test(argGens: ValueGenerator[], src: string, propTest: PropertyTest, nRuns?: number, simplify?: boolean): Promise<void>;
        /**
         * @param {Object.<string, ValueGenerator>} paramGenerators
         * @param {string[]} paramArgs
         * @param {string} src
         * @param {PropertyTest} propTest
         * @param {number} nRuns
         * @param {boolean} simplify
         * @returns {Promise<void>}
         */
        testParams(paramGenerators: {
            [x: string]: ValueGenerator;
        }, paramArgs: string[], src: string, propTest: PropertyTest, nRuns?: number, simplify?: boolean): Promise<void>;
        #private;
    }
    /**
     * Needed by transfer() methods
     */
    export type TransferUplcAst = {
        transferByteArrayData: (bytes: number[]) => any;
        transferConstrData: (index: number, fields: any[]) => any;
        transferIntData: (value: bigint) => any;
        transferListData: (items: any[]) => any;
        transferMapData: (pairs: [any, any][]) => any;
        transferSite: (src: any, startPos: number, endPos: number, codeMapSite: null | any) => any;
        transferSource: (raw: string, name: string) => any;
        transferUplcBool: (site: any, value: boolean) => any;
        transferUplcBuiltin: (site: any, name: string | number) => any;
        transferUplcByteArray: (site: any, bytes: number[]) => any;
        transferUplcCall: (site: any, a: any, b: any) => any;
        transferUplcConst: (value: any) => any;
        transferUplcDataValue: (site: any, data: any) => any;
        transferUplcDelay: (site: any, expr: any) => any;
        transferUplcError: (site: any, msg: string) => any;
        transferUplcForce: (site: any, expr: any) => any;
        transferUplcInt: (site: any, value: bigint, signed: boolean) => any;
        transferUplcLambda: (site: any, rhs: any, name: null | string) => any;
        transferUplcList: (site: any, itemType: any, items: any[]) => any;
        transferUplcPair: (site: any, first: any, second: any) => any;
        transferUplcString: (site: any, value: string) => any;
        transferUplcType: (typeBits: string) => any;
        transferUplcUnit: (site: any) => any;
        transferUplcVariable: (site: any, index: any) => any;
    };
    export type CekValue = UplcConst | AppliedUplcBuiltin | UplcLambdaWithEnv | UplcDelayWithEnv;
    export type CekEnv = {
        values: CekValue[];
        callSites: Site[];
    };
    export type ComputingState = {
        computing: UplcTerm;
        env: CekEnv;
    };
    export type ReducingState = {
        reducing: CekValue;
    };
    export type ErrorState = {
        error: string | RuntimeError;
        env: CekEnv;
    };
    export type CekState = ComputingState | ReducingState | ErrorState;
    export type TypeSchema = {
        type: string;
    } | {
        type: "List";
        itemType: TypeSchema;
    } | {
        type: "Map";
        keyType: TypeSchema;
        valueType: TypeSchema;
    } | {
        type: "Option";
        someType: TypeSchema;
    } | {
        type: "Struct";
        fieldTypes: NamedTypeSchema[];
    } | {
        type: "Enum";
        variantTypes: {
            name: string;
            fieldTypes: NamedTypeSchema[];
        }[];
    };
    export type NamedTypeSchema = {
        name: string;
    } & TypeSchema;
    export type ParameterI = {
        name: string;
        typeClass: TypeClass;
    };
    export type InferenceMap = Map<ParameterI, Type>;
    /**
     * Used by the bundle cli command to generate a typescript annotations and (de)serialization code
     * inputTypes form a type union
     */
    export type TypeDetails = {
        inputType: string;
        outputType: string;
        internalType: TypeSchema;
    };
    export type JsToUplcHelpers = {
        [name: string]: (obj: any) => Promise<UplcData>;
    };
    export type UplcToJsHelpers = {
        [name: string]: (data: UplcData) => Promise<any>;
    };
    export type JsToUplcConverter = (obj: any, helpers: JsToUplcHelpers) => Promise<UplcData>;
    export type UplcToJsConverter = (data: UplcData, helpers: UplcToJsHelpers) => Promise<any>;
    export type DataType = Named & Type & {
        asDataType: DataType;
        fieldNames: string[];
        offChainType: (null | HeliosDataClass<HeliosData>);
        typeDetails?: TypeDetails;
        jsToUplc: JsToUplcConverter;
        uplcToJs: UplcToJsConverter;
        ready: boolean;
    };
    export type EnumMemberType = DataType & {
        asEnumMemberType: EnumMemberType;
        constrIndex: number;
        parentType: DataType;
    };
    /**
     * EvalEntities assert themselves
     */
    export type EvalEntity = {
        asDataType: (null | DataType);
        asEnumMemberType: (null | EnumMemberType);
        asFunc: (null | Func);
        asInstance: (null | Instance);
        asMulti: (null | Multi);
        asNamed: (null | Named);
        asNamespace: (null | Namespace);
        asParametric: (null | Parametric);
        asType: (null | Type);
        asTyped: (null | Typed);
        asTypeClass: (null | TypeClass);
        toString(): string;
    };
    export type Func = EvalEntity & {
        asTyped: Typed;
        type: Type;
    } & {
        asFunc: Func;
        funcType: FuncType;
        call(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        } | undefined): (null | Typed | Multi);
    };
    export type Instance = Typed & {
        asInstance: Instance;
        fieldNames: string[];
        instanceMembers: InstanceMembers;
    };
    export type Multi = EvalEntity & {
        asMulti: Multi;
        values: Typed[];
    };
    export type Named = EvalEntity & {
        asNamed: Named;
        name: string;
        path: string;
    };
    export type Namespace = EvalEntity & {
        asNamespace: Namespace;
        namespaceMembers: NamespaceMembers;
    };
    export type Parametric = EvalEntity & {
        asParametric: Parametric;
        offChainType: ((...any: any[]) => HeliosDataClass<HeliosData>) | null;
        typeClasses: TypeClass[];
        apply(types: Type[], site?: Site): EvalEntity;
        inferCall(site: Site, args: Typed[], namedArgs?: {
            [name: string]: Typed;
        } | undefined, paramTypes?: Type[]): Func;
        infer(site: Site, map: InferenceMap): Parametric;
    };
    export type Type = EvalEntity & {
        asType: Type;
        instanceMembers: InstanceMembers;
        typeMembers: TypeMembers;
        isBaseOf(type: Type): boolean;
        infer(site: Site, map: InferenceMap, type: null | Type): Type;
        toTyped(): Typed;
        isParametric(): boolean;
    };
    export type Typed = EvalEntity & {
        asTyped: Typed;
        type: Type;
    };
    export type TypeClass = EvalEntity & {
        asTypeClass: TypeClass;
        genInstanceMembers(impl: Type): TypeClassMembers;
        genTypeMembers(impl: Type): TypeClassMembers;
        isImplementedBy(type: Type): boolean;
        toType(name: string, path: string, parameter?: null | ParameterI): Type;
    };
    export type InstanceMembers = {
        [name: string]: Type | Parametric;
    };
    export type NamespaceMembers = {
        [name: string]: EvalEntity;
    };
    export type TypeMembers = {
        [name: string]: Type | Typed | Parametric;
    };
    export type TypeClassMembers = {
        [name: string]: Type;
    };
    /**
     * The inner 'any' is also Metadata, but jsdoc doesn't allow declaring recursive types
     * Metadata is essentially a JSON schema object
     */
    export type Metadata = {
        map: [any, any][];
    } | any[] | string | number;
    /**
     * Function that generates a random number between 0 and 1
     */
    export type NumberGenerator = () => number;
    export type CodeMap = [number, Site][];
    export type IRDefinitions = Map<string, IR>;
    export type CurvePoint<T extends CurvePoint<T>> = {
        add(other: T): T;
        mul(scalar: bigint): T;
        equals(other: T): boolean;
        encode(): number[];
    };
    export type Decoder = (i: number, bytes: number[]) => void;
    /**
     * Deprecated
     */
    export type HeliosDataClass<T extends HeliosData> = {
        new (...args: any[]): T;
        fromUplcCbor: (bytes: (string | number[])) => T;
        fromUplcData: (data: UplcData) => T;
        isBuiltin(): boolean;
    };
    export type HIntProps = number | bigint;
    export type TimeProps = number | bigint | string | Date;
    export type DurationProps = HIntProps;
    export type BoolProps = boolean | string;
    export type HStringProps = string;
    export type ByteArrayProps = number[] | string;
    export type HashProps = number[] | string;
    export type DatumHashProps = HashProps;
    export type PubKeyProps = number[] | string;
    /**
     * Represents a blake2b-224 hash of a PubKey
     *
     * **Note**: A `PubKeyHash` can also be used as the second part of a payment `Address`, or to construct a `StakeAddress`.
     */
    export type PubKeyHashProps = HashProps;
    export type ScriptHashProps = HashProps;
    export type MintingPolicyHashProps = HashProps;
    export type StakingValidatorHashProps = HashProps;
    export type ValidatorHashProps = HashProps;
    export type TxIdProps = HashProps;
    export type TxOutputIdProps = string | [
        TxId | TxIdProps,
        HInt | HIntProps
    ] | {
        txId: TxId | TxIdProps;
        utxoId: HInt | HIntProps;
    };
    /**
     * An array of bytes, a Bech32 encoded address, or the hexadecimal representation of the underlying bytes.
     */
    export type AddressProps = number[] | string;
    export type AssetClassProps = string | [
        MintingPolicyHash | MintingPolicyHashProps,
        ByteArray | ByteArrayProps
    ] | {
        mph: MintingPolicyHash | MintingPolicyHashProps;
        tokenName: ByteArray | ByteArrayProps;
    };
    export type AssetsProps = [
        AssetClass | AssetClassProps,
        HInt | HIntProps
    ][] | [
        MintingPolicyHash | MintingPolicyHashProps,
        [
            ByteArray | ByteArrayProps,
            HInt | HIntProps
        ][]
    ][];
    export type ValueProps = HInt | HIntProps | [
        HInt | HIntProps,
        Assets | AssetsProps
    ] | {
        lovelace: HInt | HIntProps;
        assets?: Assets | AssetsProps;
    };
    export type Cost = {
        mem: bigint;
        cpu: bigint;
    };
    export type LiveSlotGetter = () => bigint;
    export type CostModelClass = {
        fromParams: (params: NetworkParams, baseName: string) => CostModel;
    };
    /**
     * A Helios/Uplc Program can have different purposes
     */
    export type ScriptPurpose = "testing" | "minting" | "spending" | "staking" | "endpoint" | "module" | "unknown";
    export type UplcRawStack = [null | string, UplcValue][];
    export type UplcRTECallbacks = {
        onPrint: (msg: string) => Promise<void>;
        onStartCall: (site: Site, rawStack: UplcRawStack) => Promise<boolean>;
        onEndCall: (site: Site, rawStack: UplcRawStack) => Promise<void>;
        onIncrCost: (name: string, isTerm: boolean, cost: Cost) => void;
    };
    export type UplcRTECallbacksInternal = UplcRTECallbacks & {
        macros?: {
            [name: string]: (rte: UplcRte, args: UplcValue[]) => Promise<UplcValue>;
        } | undefined;
    };
    /**
     * TODO: purpose as enum type
     */
    export type ProgramProperties = {
        purpose: null | ScriptPurpose;
        callsTxTimeRange: boolean;
        name?: string;
    };
    /**
     * The constructor returns 'any' because it is an instance of TransferableUplcProgram, and the instance methods don't need to be defined here
     */
    export type TransferableUplcProgram<TInstance> = {
        transferUplcProgram: (expr: any, properties: ProgramProperties, version: any[]) => TInstance;
        transferUplcAst: TransferUplcAst;
    };
    /**
     * mem:  in 8 byte words (i.e. 1 mem unit is 64 bits)
     * cpu:  in reference cpu microseconds
     * size: in bytes
     * builtins: breakdown per builtin
     * terms: breakdown per termtype
     * result: result of evaluation
     * messages: printed messages (can be helpful when debugging)
     */
    export type Profile = {
        mem: bigint;
        cpu: bigint;
        size?: number | undefined;
        builtins?: {
            [name: string]: Cost;
        } | undefined;
        terms?: {
            [name: string]: Cost;
        } | undefined;
        result?: RuntimeError | UplcValue | undefined;
        messages?: string[] | undefined;
    };
    export type GenericTypeProps<T extends HeliosData> = {
        name: string;
        path?: string | undefined;
        offChainType?: HeliosDataClass<T> | null | undefined;
        genOffChainType?: (() => HeliosDataClass<T>) | null | undefined;
        fieldNames?: string[] | undefined;
        genInstanceMembers: (self: Type) => InstanceMembers;
        genTypeMembers: (self: Type) => TypeMembers;
        genTypeDetails?: ((self: Type) => TypeDetails) | undefined;
        jsToUplc?: JsToUplcConverter | undefined;
        uplcToJs?: UplcToJsConverter | undefined;
    };
    export type GenericEnumMemberTypeProps<T extends HeliosData> = {
        name: string;
        path?: string | undefined;
        constrIndex: number;
        parentType: DataType;
        offChainType?: HeliosDataClass<T> | undefined;
        genOffChainType?: (() => HeliosDataClass<T>) | undefined;
        fieldNames?: string[] | undefined;
        genInstanceMembers: (self: Type) => InstanceMembers;
        genTypeMembers?: ((self: Type) => TypeMembers) | undefined;
        genTypeDetails?: ((self: Type) => TypeDetails) | undefined;
        jsToUplc?: JsToUplcConverter | undefined;
        uplcToJs?: UplcToJsConverter | undefined;
    };
    export type ScriptTypes = {
        [name: string]: ScriptHashType;
    };
    export type IRLiteralRegistry = Map<IRVariable, IRLiteralExpr>;
    export type UserTypes = {
        [name: string]: any;
    };
    export type ProgramConfig = {
        allowPosParams: boolean;
        invertEntryPoint: boolean;
    };
    export type PrivateKey = {
        /**
         * Generates the corresponding public key.
         */
        derivePubKey: () => PubKey;
        /**
         * Signs a byte-array payload, returning the signature.
         */
        sign: (msg: number[]) => Signature;
    };
    /**
     * Returns two lists. The first list contains the selected UTxOs, the second list contains the remaining UTxOs.
     */
    export type CoinSelectionAlgorithm = (utxos: TxInput[], amount: Value) => [TxInput[], TxInput[]];
    /**
     * An interface type for a wallet that manages a user's UTxOs and addresses.
     */
    export type Wallet = {
        /**
         * Returns `true` if the wallet is connected to the mainnet.
         */
        isMainnet: () => Promise<boolean>;
        /**
         * Returns a list of addresses which already contain UTxOs.
         */
        usedAddresses: Promise<Address[]>;
        /**
         * Returns a list of unique unused addresses which can be used to send UTxOs to with increased anonimity.
         */
        unusedAddresses: Promise<Address[]>;
        /**
         * Returns a list of all the utxos controlled by the wallet.
         */
        utxos: Promise<TxInput[]>;
        collateral: Promise<TxInput[]>;
        /**
         * Signs a transaction, returning a list of signatures needed for submitting a valid transaction.
         */
        signTx: (tx: Tx) => Promise<Signature[]>;
        /**
         * Submits a transaction to the blockchain and returns the id of that transaction upon success.
         */
        submitTx: (tx: Tx) => Promise<TxId>;
    };
    /**
     * Convenience type for browser plugin wallets supporting the CIP 30 dApp connector standard (eg. Eternl, Nami, ...).
     *
     * This is useful in typescript projects to avoid type errors when accessing the handles in `window.cardano`.
     *
     * ```ts
     * // refer to this file in the 'typeRoots' list in tsconfig.json
     *
     * type Cip30SimpleHandle = {
     *   name: string,
     *   icon: string,
     *   enable(): Promise<helios.Cip30Handle>,
     *   isEnabled(): boolean
     * }
     *
     * declare global {
     *   interface Window {
     *     cardano: {
     *       [walletName: string]: Cip30SimpleHandle
     *     };
     *   }
     * }
     * ```
     */
    export type Cip30Handle = {
        getNetworkId(): Promise<number>;
        getUsedAddresses(): Promise<string[]>;
        getUnusedAddresses(): Promise<string[]>;
        getUtxos(): Promise<string[]>;
        getCollateral(): Promise<string[]>;
        signTx(txHex: string, partialSign: boolean): Promise<string>;
        submitTx(txHex: string): Promise<string>;
        experimental: {
            getCollateral(): Promise<string[]>;
        };
    };
    /**
     * Blockchain query interface.
     */
    export type Network = {
        /**
         * Returns a complete list of UTxOs at a given address.
         */
        getUtxos: (address: Address) => Promise<TxInput[]>;
        /**
         * Returns a single TxInput (that might already have been spent).
         */
        getUtxo: (id: TxOutputId) => Promise<TxInput>;
        /**
         * Returns the latest network parameters.
         */
        getParameters: () => Promise<NetworkParams>;
        /**
         * Submits a transaction to the blockchain and returns the id of that transaction upon success.
         */
        submitTx: (tx: Tx) => Promise<TxId>;
    };
    /**
     * collectUtxos removes tx inputs from the list, and appends txoutputs sent to the address to the end.
     */
    export type EmulatorTx = {
        id(): TxId;
        consumes(utxo: TxInput): boolean;
        collectUtxos(address: Address, utxos: TxInput[]): TxInput[];
        getUtxo(id: TxOutputId): (null | TxInput);
        dump(): void;
    };
    export type NetworkSliceUTxOs = {
        [address: string]: TxInput[];
    };
    export type ValueGenerator = () => UplcData;
    export type PropertyTest = (args: UplcValue[], res: (UplcValue | RuntimeError), isSimplfied?: boolean) => (boolean | {
        [x: string]: boolean;
    });
    /**
     * UplcStack contains a value that can be retrieved using a Debruijn index.
     */
    class UplcStack {
        /**
         * @param {null | UplcStack | UplcRte} parent
         * @param {null | UplcValue} value
         * @param {null | string} valueName
         */
        constructor(parent: null | UplcStack | UplcRte, value?: null | UplcValue, valueName?: null | string);
        incrStartupCost(): void;
        incrVariableCost(): void;
        incrLambdaCost(): void;
        incrDelayCost(): void;
        incrCallCost(): void;
        incrConstCost(): void;
        incrForceCost(): void;
        incrBuiltinCost(): void;
        /**
         * @param {UplcBuiltin} fn
         * @param {UplcValue[]} args
         */
        calcAndIncrCost(fn: UplcBuiltin, ...args: UplcValue[]): void;
        /**
         * Gets a value using the Debruijn index. If 'i == 1' then the current value is returned.
         * Otherwise 'i' is decrement and passed to the parent stack.
         * @param {number} i
         * @returns {UplcValue}
         */
        get(i: number): UplcValue;
        /**
         *
         * @param {string} name
         * @param {UplcValue[]} args
         * @returns {Promise<UplcValue>}
         */
        callMacro(name: string, args: UplcValue[]): Promise<UplcValue>;
        /**
         * Instantiates a child stack.
         * @param {UplcValue} value
         * @param {?string} valueName
         * @returns {UplcStack}
         */
        push(value: UplcValue, valueName?: string | null): UplcStack;
        /**
         * Calls the onPrint callback in the RTE (root of stack).
         * @param {string} msg
         * @returns {Promise<void>}
         */
        print(msg: string): Promise<void>;
        /**
         * Calls the onStartCall callback in the RTE (root of stack).
         * @param {Site} site
         * @param {UplcRawStack} rawStack
         * @returns {Promise<void>}
         */
        startCall(site: Site, rawStack: UplcRawStack): Promise<void>;
        /**
         * Calls the onEndCall callback in the RTE (root of stack).
         * @param {Site} site
         * @param {UplcRawStack} rawStack
         * @param {UplcValue} result
         * @returns {Promise<void>}
         */
        endCall(site: Site, rawStack: UplcRawStack, result: UplcValue): Promise<void>;
        /**
         * @returns {UplcRawStack}
         */
        toList(): UplcRawStack;
        #private;
    }
    /**
     * @internal
     * @extends {UplcTermWithEnv<UplcLambda>}
     */
    class UplcLambdaWithEnv extends UplcTermWithEnv<UplcLambda> {
        /**
         * @param {T} term
         * @param {CekEnv} env
         */
        constructor(term: UplcLambda, env: CekEnv);
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {PreCallFrame} frame
         * @returns {Promise<CekState>}
         */
        reducePreCallFrame(rte: UplcRte, stack: UplcFrame[], frame: PreCallFrame): Promise<CekState>;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ForceFrame} frame
         * @returns {Promise<CekState>}
         */
        reduceForceFrame(rte: UplcRte, stack: UplcFrame[], frame: ForceFrame): Promise<CekState>;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ReducingState} state
         * @param {CallFrame} frame
         * @returns {Promise<CekState>}
         */
        reduceCallFrame(rte: UplcRte, stack: UplcFrame[], state: ReducingState, frame: CallFrame): Promise<CekState>;
    }
    /**
     * @internal
     */
    class AppliedUplcBuiltin {
        /**
         * @param {UplcBuiltin} term
         * @param {number} forceCount
         * @param {CekValue[]} args
         */
        constructor(term: UplcBuiltin, forceCount?: number, args?: CekValue[]);
        /**
         * @readonly
         * @type {UplcBuiltin}
         */
        readonly term: UplcBuiltin;
        /**
         * @readonly
         * @type {number}
         */
        readonly forceCount: number;
        /**
         * @readonly
         * @type {CekValue[]}
         */
        readonly args: CekValue[];
        /**
         * @type {Site}
         */
        get site(): Site;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @returns {AppliedUplcBuiltin}
         */
        force(): AppliedUplcBuiltin;
        /**
         * @param {CekValue} arg
         * @returns {AppliedUplcBuiltin}
         */
        apply(arg: CekValue): AppliedUplcBuiltin;
        /**
         * @returns {boolean}
         */
        isFullForced(): boolean;
        /**
         * @returns {boolean}
         */
        isFullyApplied(): boolean;
        /**
         * @internal
         * @param {UplcRte} rte
         * @param {Site[]} sites
         * @returns {Promise<CekValue>}
         */
        evalCek(rte: UplcRte, sites: Site[]): Promise<CekValue>;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {PreCallFrame} frame
         * @returns {Promise<CekState>}
         */
        reducePreCallFrame(rte: UplcRte, stack: UplcFrame[], frame: PreCallFrame): Promise<CekState>;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ForceFrame} frame
         * @returns {Promise<CekState>}
         */
        reduceForceFrame(rte: UplcRte, stack: UplcFrame[], frame: ForceFrame): Promise<CekState>;
        /**
         *
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ReducingState} state
         * @param {CallFrame} frame
         * @returns {Promise<CekState>}
         */
        reduceCallFrame(rte: UplcRte, stack: UplcFrame[], state: ReducingState, frame: CallFrame): Promise<CekState>;
    }
    /**
     * Wrapper for a builtin function (written in IR)
     */
    class RawFunc {
        /**
         * Construct a RawFunc, and immediately scan the definition for dependencies
         * @param {string} name
         * @param {string} definition
         */
        constructor(name: string, definition: string);
        get name(): string;
        /**
         * @returns {IR}
         */
        toIR(): IR;
        /**
         * Loads 'this.#dependecies' (if not already loaded), then load 'this'
         * @param {Map<string, RawFunc>} db
         * @param {IRDefinitions} dst
         * @returns {void}
         */
        load(db: Map<string, RawFunc>, dst: IRDefinitions): void;
        #private;
    }
    /**
     * Parent class of EnumSwitchExpr and DataSwitchExpr
     */
    class SwitchExpr extends Expr {
        /**
         * @param {Site} site
         * @param {Expr} controlExpr - input value of the switch
         * @param {SwitchCase[]} cases
         * @param {null | SwitchDefault} defaultCase
        */
        constructor(site: Site, controlExpr: Expr, cases: SwitchCase[], defaultCase?: null | SwitchDefault);
        get controlExpr(): Expr;
        get cases(): SwitchCase[];
        get defaultCase(): SwitchDefault | null;
        /**
         * If there isn't enough coverage then we can simply set the default case to void, so the other branches can be error, print or assert
         */
        setDefaultCaseToVoid(): void;
        #private;
    }
    /**
     * A Module is a collection of statements
     */
    class Module {
        /**
         * @param {string} rawSrc
         * @returns {Module}
         */
        static new(rawSrc: string): Module;
        /**
         * @param {Word} name
         * @param {Statement[]} statements
         */
        constructor(name: Word, statements: Statement[]);
        throwErrors(): void;
        /**
         * @type {Word}
         */
        get name(): Word;
        /**
         * @type {Statement[]}
         */
        get statements(): Statement[];
        /**
         * @param {string} namespace
         * @param {(name: string, cs: ConstStatement) => void} callback
         */
        loopConstStatements(namespace: string, callback: (name: string, cs: ConstStatement) => void): void;
        /**
         * @returns {string}
         */
        toString(): string;
        /**
         * @param {ModuleScope} scope
         */
        evalTypes(scope: ModuleScope): void;
        /**
         * This module can depend on other modules
         * TODO: detect circular dependencies
         * @param {Module[]} modules
         * @param {Module[]} stack
         * @returns {Module[]}
         */
        filterDependencies(modules: Module[], stack?: Module[]): Module[];
        #private;
    }
    /**
     * The entrypoint module
     */
    class MainModule extends Module {
        /**
         * @type {FuncStatement}
         */
        get mainFunc(): FuncStatement;
    }
    /**
     * @internal
     * @extends {UplcTermWithEnv<UplcDelay>}
     */
    class UplcDelayWithEnv extends UplcTermWithEnv<UplcDelay> {
        /**
         * @param {T} term
         * @param {CekEnv} env
         */
        constructor(term: UplcDelay, env: CekEnv);
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {PreCallFrame} frame
         * @returns {CekState}
         */
        reducePreCallFrame(rte: UplcRte, stack: UplcFrame[], frame: PreCallFrame): CekState;
        /**
         * @param {UplcRte} rte
         * @param {UplcFrame[]} stack
         * @param {ForceFrame} frame
         * @returns {CekState}
         */
        reduceForceFrame(rte: UplcRte, stack: UplcFrame[], frame: ForceFrame): CekState;
    }
    /**
     * @internal
     * @template {UplcTerm} T
     */
    class UplcTermWithEnv<T extends UplcTerm> {
        /**
         * @param {T} term
         * @param {CekEnv} env
         */
        constructor(term: T, env: CekEnv);
        /**
        * @readonly
        * @type {T}
        */
        readonly term: T;
        /**
         * @readonly
         * @type {CekEnv}
         */
        readonly env: CekEnv;
        /**
         * @type {Site}
         */
        get site(): Site;
        toString(): string;
    }
    export {};
}
